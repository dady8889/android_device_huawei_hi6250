From 6e5dc0f72cf4296c7aeb03bb568b6b614ba1d5cf Mon Sep 17 00:00:00 2001
From: Daniel <dady8889@gmail.com>
Date: Sun, 27 Nov 2016 02:10:35 +0100
Subject: [PATCH] Fix Bluetooth

Change-Id: I771b1f7a53185c97024f7b905d2112a6178c979c
---
 core/java/android/bluetooth/BluetoothAdapter.java  |   5 +-
 .../bluetooth/BluetoothAvrcpController.java        |  87 ++-
 .../java/android/bluetooth/BluetoothAvrcpInfo.aidl |  34 +
 .../java/android/bluetooth/BluetoothAvrcpInfo.java | 306 ++++++++
 core/java/android/bluetooth/BluetoothHeadset.java  | 116 +--
 .../bluetooth/IBluetoothAvrcpController.aidl       |   8 +
 core/java/android/bluetooth/IBluetoothManager.aidl |   6 +-
 core/java/android/provider/Settings.java           |  11 +
 media/java/android/media/AudioManager.java         | 101 ++-
 media/java/android/media/IAudioService.aidl        |  12 +
 media/java/android/media/IRemoteControlClient.aidl |   7 +-
 media/java/android/media/RemoteController.java     | 186 +++++
 media/java/android/media/session/ISession.aidl     |   4 +
 .../android/media/session/ISessionCallback.aidl    |   3 +
 .../android/media/session/ISessionController.aidl  |   3 +
 .../media/session/ISessionControllerCallback.aidl  |   4 +
 .../android/media/session/MediaController.java     | 114 +++
 media/java/android/media/session/MediaSession.java | 141 ++++
 .../android/server/BluetoothManagerService.java    | 334 ++------
 .../com/android/server/audio/AudioService.java     | 864 +++++----------------
 .../android/server/audio/MediaFocusControl.java    |  79 ++
 .../android/server/media/MediaSessionRecord.java   | 182 +++++
 22 files changed, 1639 insertions(+), 968 deletions(-)
 create mode 100644 core/java/android/bluetooth/BluetoothAvrcpInfo.aidl
 create mode 100644 core/java/android/bluetooth/BluetoothAvrcpInfo.java

diff --git a/core/java/android/bluetooth/BluetoothAdapter.java b/core/java/android/bluetooth/BluetoothAdapter.java
index 1f3ff51..0193fca 100644
--- a/core/java/android/bluetooth/BluetoothAdapter.java
+++ b/core/java/android/bluetooth/BluetoothAdapter.java
@@ -18,6 +18,7 @@
 package android.bluetooth;
 
 import android.Manifest;
+import android.app.ActivityThread;
 import android.annotation.IntDef;
 import android.annotation.RequiresPermission;
 import android.annotation.SdkConstant;
@@ -762,7 +763,7 @@ public final class BluetoothAdapter {
         try {
             if (DBG) Log.d(TAG, "Calling enableBLE");
             mManagerService.updateBleAppCount(mToken, true);
-            return mManagerService.enable();
+            return mManagerService.enable(ActivityThread.currentPackageName());
         } catch (RemoteException e) {
             Log.e(TAG, "", e);
         }
@@ -898,7 +899,7 @@ public final class BluetoothAdapter {
                 return true;
         }
         try {
-            return mManagerService.enable();
+            return mManagerService.enable(ActivityThread.currentPackageName());
         } catch (RemoteException e) {Log.e(TAG, "", e);}
         return false;
     }
diff --git a/core/java/android/bluetooth/BluetoothAvrcpController.java b/core/java/android/bluetooth/BluetoothAvrcpController.java
index b53a8fc..4851087 100644
--- a/core/java/android/bluetooth/BluetoothAvrcpController.java
+++ b/core/java/android/bluetooth/BluetoothAvrcpController.java
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
  * Copyright (C) 2014 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -210,7 +211,7 @@ public final class BluetoothAvrcpController implements BluetoothProfile {
     }
 
     public void sendPassThroughCmd(BluetoothDevice device, int keyCode, int keyState) {
-        if (DBG) Log.d(TAG, "sendPassThroughCmd");
+        if (DBG) Log.d(TAG, "sendPassThroughCmd dev = " + device + " key " + keyCode + " State = " + keyState);
         if (mService != null && isEnabled()) {
             try {
                 mService.sendPassThroughCmd(device, keyCode, keyState);
@@ -223,6 +224,90 @@ public final class BluetoothAvrcpController implements BluetoothProfile {
         if (mService == null) Log.w(TAG, "Proxy not attached to service");
     }
 
+    public void getMetaData(int[] attributeIds) {
+        if (DBG) Log.d(TAG, "getMetaData num requested Ids = " + attributeIds.length);
+        if (mService != null && isEnabled()) {
+            try {
+                mService.getMetaData(attributeIds);
+                return;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in getMetaData", e);
+                return;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+    }
+
+    public void getPlayStatus(int[] playStatusIds) {
+        if (DBG) Log.d(TAG, "getPlayStatus num requested Ids  = "+ playStatusIds.length);
+        if (mService != null && isEnabled()) {
+            try {
+                mService.getPlayStatus(playStatusIds);
+                return;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in getPlayStatus()", e);
+                return;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+    }
+
+    public void getPlayerApplicationSetting() {
+        if (DBG) Log.d(TAG, "getPlayerApplicationSetting");
+        if (mService != null && isEnabled()) {
+            try {
+                mService.getPlayerApplicationSetting();
+                return;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in getPlayerApplicationSetting()", e);
+                return;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+    }
+
+    public void setPlayerApplicationSetting(int attributeId, int attributeVal) {
+        if (DBG) Log.d(TAG, "setPlayerApplicationSetting attribId = " + attributeId + " attribVal = " + attributeVal);
+        if (mService != null && isEnabled()) {
+            try {
+                mService.setPlayerApplicationSetting(attributeId, attributeVal);
+                return;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting()", e);
+                return;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+    }
+
+    public BluetoothAvrcpInfo getSupportedPlayerAppSetting(BluetoothDevice device) {
+        if (DBG) Log.d(TAG, "getSupportedPlayerAppSetting dev = " + device);
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getSupportedPlayerAppSetting(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in getSupportedPlayerAppSetting()", e);
+                return null;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return null;
+    }
+
+    public int getSupportedFeatures(BluetoothDevice device) {
+        if (DBG) Log.d(TAG, "getSupportedFeatures dev = " + device);
+        if (mService != null && isEnabled()) {
+            try {
+                return mService.getSupportedFeatures(device);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Error talking to BT service in getSupportedFeatures()", e);
+                return 0;
+            }
+        }
+        if (mService == null) Log.w(TAG, "Proxy not attached to service");
+        return 0;
+    }
+
     private final ServiceConnection mConnection = new ServiceConnection() {
         public void onServiceConnected(ComponentName className, IBinder service) {
             if (DBG) Log.d(TAG, "Proxy object connected");
diff --git a/core/java/android/bluetooth/BluetoothAvrcpInfo.aidl b/core/java/android/bluetooth/BluetoothAvrcpInfo.aidl
new file mode 100644
index 0000000..9b85c80
--- /dev/null
+++ b/core/java/android/bluetooth/BluetoothAvrcpInfo.aidl
@@ -0,0 +1,34 @@
+/*
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *    * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package android.bluetooth;
+
+parcelable BluetoothAvrcpInfo;
diff --git a/core/java/android/bluetooth/BluetoothAvrcpInfo.java b/core/java/android/bluetooth/BluetoothAvrcpInfo.java
new file mode 100644
index 0000000..a815d10
--- /dev/null
+++ b/core/java/android/bluetooth/BluetoothAvrcpInfo.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *    * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+package android.bluetooth;
+
+import java.util.ArrayList;
+import android.util.Log;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.provider.BaseColumns;
+import android.net.Uri;
+
+/**
+ * Represents the AVRCP Metadata of remote Bluetooth Device.
+ *
+ * {@see BluetoothAvrcpController}
+ *
+ * {@hide}
+ */
+public final class BluetoothAvrcpInfo implements Parcelable, BaseColumns{
+
+    private byte[] supportedPlayerAttributes;// attributes supported
+    private byte[] numSupportedPlayerAttribValues; // number of values of each attribute
+    private String TAG = "BluetoothAvrcpInfo";
+    /*
+     * This would a list of values of all AttributeIds
+     */
+    private byte[] supportedPlayerAtribValues; // actual values lies here.
+
+    /* Default Constructor */
+    public BluetoothAvrcpInfo() {
+        supportedPlayerAttributes = null;
+        numSupportedPlayerAttribValues = null;
+        supportedPlayerAtribValues = null;
+    }
+    public BluetoothAvrcpInfo(byte[] attribIds, byte[] numValueSupported, byte[] valuesSupported) {
+        int numAttributes = attribIds.length;
+        int zz = 0;
+        supportedPlayerAttributes = new byte[numAttributes];
+        numSupportedPlayerAttribValues = new byte[numAttributes];
+        supportedPlayerAtribValues = new byte[valuesSupported.length];
+        for (zz = 0; zz < numAttributes; zz++) {
+            supportedPlayerAttributes[zz] = attribIds[zz];
+            numSupportedPlayerAttribValues[zz] = numValueSupported[zz];
+        }
+        for (zz = 0; zz < supportedPlayerAtribValues.length; zz++)
+            supportedPlayerAtribValues[zz] = valuesSupported[zz];
+    }
+    /*
+     * Reading Structure back from Paracel
+     */
+    public BluetoothAvrcpInfo(Parcel source){
+        ArrayList<Byte> attribs =  new ArrayList<Byte>();
+        ArrayList<Byte> numAttribVal =  new ArrayList<Byte>();
+        ArrayList<Byte> attribVals =  new ArrayList<Byte>();
+        Byte numAttributes = source.readByte();
+        /*
+         * Read from Source
+         */
+        for(int xx = 0; xx < numAttributes ; xx++) {
+            attribs.add(source.readByte());
+            numAttribVal.add(source.readByte());
+            for (int zz = 0; zz < numAttribVal.get(xx); zz++) {
+                attribVals.add(source.readByte());
+            }
+        }
+
+        /*
+         * Write Back to Private Data Structures
+         */
+        supportedPlayerAttributes =  new byte[attribs.size()];
+        for (int zz = 0; zz< attribs.size(); zz++) {
+            supportedPlayerAttributes[zz] = attribs.get(zz);
+        }
+
+        numSupportedPlayerAttribValues =  new byte[numAttribVal.size()];
+        for (int zz = 0; zz< numAttribVal.size(); zz++) {
+            numSupportedPlayerAttribValues[zz] = numAttribVal.get(zz);
+        }
+
+        supportedPlayerAtribValues =  new byte[attribVals.size()];
+        for (int zz = 0; zz< attribVals.size(); zz++) {
+            supportedPlayerAtribValues[zz] = attribVals.get(zz);
+        }
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    /* While flatenning the structure we would use the follwing way
+     * NumAttributes,ID, numValues, Values
+     */
+    public void writeToParcel(Parcel out, int flags) {
+        byte numSuppAttributes = (byte)supportedPlayerAttributes.length;
+        out.writeByte(numSuppAttributes);
+        for (int xx = 0; xx < numSuppAttributes; xx++) {
+            out.writeByte(supportedPlayerAttributes[xx]);
+            out.writeByte(numSupportedPlayerAttribValues[xx]);
+            for (int zz = 0; zz < numSupportedPlayerAttribValues[xx]; zz++) {
+                out.writeByte(supportedPlayerAtribValues[zz]);
+            }
+        }
+    }
+
+    public byte[] getSupportedPlayerAttributes() {
+        return supportedPlayerAttributes;
+    }
+
+    public byte getNumSupportedPlayerAttributeVal(byte playerAttributeId) {
+        for (int zz = 0; zz < supportedPlayerAttributes.length; zz++) {
+            if (playerAttributeId == supportedPlayerAttributes[zz]) {
+                return numSupportedPlayerAttribValues[zz];
+            }
+        }
+        return 0;
+    }
+
+    public byte[] getSupportedPlayerAttributeVlaues (byte playerAttributeId) {
+        int index = 0;
+        int zz = 0;
+        boolean attributeFound = false;
+        for (zz = 0; zz < supportedPlayerAttributes.length; zz++) {
+            if (playerAttributeId == supportedPlayerAttributes[zz]) {
+                attributeFound = true;
+                break;
+            }
+            else
+               index = index + numSupportedPlayerAttribValues[zz];
+        }
+        if (attributeFound) {
+            byte[] supportedValues =  new byte[numSupportedPlayerAttribValues[zz]];
+            for (int xx = 0; xx < numSupportedPlayerAttribValues[zz]; xx++)
+                supportedValues[xx] = supportedPlayerAtribValues[xx + index];
+            return supportedValues;
+        }
+        else
+            return new byte[0];
+    }
+    public void putPlayerSettingAttributes(byte[] attribIds, byte[] numValueSupported, byte[] valuesSupported) {
+        int numAttributes = attribIds.length;
+        int zz = 0;
+        supportedPlayerAttributes = new byte[numAttributes];
+        numSupportedPlayerAttribValues = new byte[numAttributes];
+        supportedPlayerAtribValues = new byte[valuesSupported.length];
+        for (zz = 0; zz < numAttributes; zz++) {
+            supportedPlayerAttributes[zz] = attribIds[zz];
+            numSupportedPlayerAttribValues[zz] = numValueSupported[zz];
+        }
+        for (zz = 0; zz < supportedPlayerAtribValues.length; zz++)
+            supportedPlayerAtribValues[zz] = valuesSupported[zz];
+   }
+    public static final Parcelable.Creator<BluetoothAvrcpInfo> CREATOR =
+        new Parcelable.Creator<BluetoothAvrcpInfo>() {
+            public BluetoothAvrcpInfo createFromParcel(Parcel in) {
+                return new BluetoothAvrcpInfo(in);
+            }
+            public BluetoothAvrcpInfo[] newArray(int size) {
+                return new BluetoothAvrcpInfo[size];
+            }
+    };
+
+    public static final String PERMISSION_ACCESS = "android.permission.ACCESS_BLUETOOTH_AVRCP_CT_DATA";
+    public static final Uri CONTENT_URI = Uri.parse("content://com.android.bluetooth.avrcp/btavrcp_ct");
+
+    /*
+     * BaseColumns already has _ID and COUNT values
+     * Below mentioned strings are used to implement different columns
+     * of AVRCP MetaData table.
+     * TRACK_NUM       : Ineteger value containing the order number of
+     *                   the audio-file on its original recording.
+     *                   Numeric ASCII string converted to Integer
+     * TITLE           : Text field representing the title, song name
+     * ARTIST_NAME     : Text field representing artist(s), performer(s)
+     * ALBUM_NAME      : Text field representing the title of the recording
+     *                   (source) from which the audio in the file is taken.
+     * TOTAL_TRACKS    : Integet value containing the total number of tracks
+     *                   or elements on the original recording.
+     * GENRE           : Text field representing the category of the composition
+     *                   characterized by a particular style.
+     * PLAYING_TIME    : Integer containing the length of the audio file in
+     *                   milliseconds for eg 02:30 = 150000
+     * PLAY_STATUS     : Text feild showing current state of track. Possible
+     *                   values would be Playing, Stopped, Paused, Forward_Seek
+     *                   REV_SEEK
+     * REPEAT_STATUS   : String describing Repeat mode status on remote Media Player
+     *                   Posible values "NOT SUPPORTED", "OFF" "Single Track Repeat"
+     *                   "All Track Repeat" "Group Repeat"
+     * SHUFFLE_STATUS  : String describing Shuffle mode status on remote Media Player
+     *                   Posible values "NOT SUPPORTED", "OFF" "All Track Shuffle"
+     *                   "Group Shuffle"
+     * SCAN_STAUS      : String describing SCAN mode status on remote Media Player
+     *                   Possible values "NOT SUPPORTED", "OFF","ALL Tracks Scan"
+     *                   "Group Scan"
+     *
+     * EQUALIZER_STATUS: String describing EQUALIZER mode status on remote Media Player
+     *                   Possible values "NOT SUPPORTED", "OFF","ON"
+     */
+    public static final String TRACK_NUM = "track_num";
+    public static final String TITLE = "title";
+    public static final String ARTIST_NAME = "artist_name";
+    public static final String ALBUM_NAME = "album_name";
+    public static final String TOTAL_TRACKS = "total_tracks";
+    public static final String GENRE = "genre";
+    public static final String PLAYING_TIME = "playing_time";
+    public static final String TOTAL_TRACK_TIME = "total_track_time";
+    public static final String PLAY_STATUS = "play_status";
+    public static final String REPEAT_STATUS = "repeat_status";
+    public static final String SHUFFLE_STATUS = "shuffle_status";
+    public static final String SCAN_STATUS = "scan_status";
+    public static final String EQUALIZER_STATUS = "equalizer_status";
+
+    /*
+     * Default values for each of the items
+    */
+    public static final int TRACK_NUM_INVALID = 0xFF;
+    public static final String TITLE_INVALID = "NOT_SUPPORTED";
+    public static final String ARTIST_NAME_INVALID = "NOT_SUPPORTED";
+    public static final String ALBUM_NAME_INVALID = "NOT_SUPPORTED";
+    public static final int TOTAL_TRACKS_INVALID = 0xFF;
+    public static final String GENRE_INVALID = "NOT_SUPPORTED";
+    public static final int PLAYING_TIME_INVALID = 0xFF;
+    public static final int TOTAL_TRACK_TIME_INVALID = 0xFF;
+    public static final String PLAY_STATUS_INVALID = "NOT_SUPPORTED";
+    public static final String REPEAT_STATUS_INVALID = "NOT_SUPPORTED";
+    public static final String SHUFFLE_STATUS_INVALID = "NOT_SUPPORTED";
+    public static final String SCAN_STATUS_INVALID = "NOT_SUPPORTED";
+    public static final String EQUALIZER_STATUS_INVALID = "NOT_SUPPORTED";
+
+    /*
+     *Element Id Values for GetMetaData
+    */
+    public static final int MEDIA_ATTRIBUTE_ALL = 0x00;
+    public static final int MEDIA_ATTRIBUTE_TITLE = 0x01;
+    public static final int MEDIA_ATTRIBUTE_ARTIST_NAME = 0x02;
+    public static final int MEDIA_ATTRIBUTE_ALBUM_NAME = 0x03;
+    public static final int MEDIA_ATTRIBUTE_TRACK_NUMBER = 0x04;
+    public static final int MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER = 0x05;
+    public static final int MEDIA_ATTRIBUTE_GENRE = 0x06;
+    public static final int MEDIA_ATTRIBUTE_PLAYING_TIME = 0x07;
+
+    /*
+     *PlayStatusId Values for GetPlayStatus
+    */
+    public static final int MEDIA_PLAYSTATUS_ALL = 0x08;
+    public static final int MEDIA_PLAYSTATUS_SONG_TOTAL_LEN = 0x09;
+    public static final int MEDIA_PLAYSTATUS_SONG_CUR_POS = 0x0a;
+    public static final int MEDIA_PLAYSTATUS_SONG_PLAY_STATUS = 0x0b;
+
+    /*
+     * Values for SetPlayerApplicationSettings
+    */
+    public static final byte ATTRIB_EQUALIZER_STATUS = 0x01;
+    public static final byte ATTRIB_REPEAT_STATUS = 0x02;
+    public static final byte ATTRIB_SHUFFLE_STATUS = 0x03;
+    public static final byte ATTRIB_SCAN_STATUS = 0x04;
+
+    public static final byte EQUALIZER_STATUS_OFF = 0x01;
+    public static final byte EQUALIZER_STATUS_ON = 0x02;
+
+    public static final byte REPEAT_STATUS_OFF = 0x01;
+    public static final byte REPEAT_STATUS_SINGLE_TRACK_REPEAT = 0x02;
+    public static final byte REPEAT_STATUS_ALL_TRACK_REPEAT = 0x03;
+    public static final byte REPEAT_STATUS_GROUP_REPEAT = 0x04;
+
+    public static final byte SHUFFLE_STATUS_OFF = 0x01;
+    public static final byte SHUFFLE_STATUS_ALL_TRACK_SHUFFLE = 0x02;
+    public static final byte SHUFFLE_STATUS_GROUP_SHUFFLE = 0x03;
+
+    public static final byte SCAN_STATUS_OFF = 0x01;
+    public static final byte SCAN_STATUS_ALL_TRACK_SCAN = 0x02;
+    public static final byte SCAN_STATUS_GROUP_SCAN = 0x03;
+
+    public static final int BTRC_FEAT_METADATA = 0x01;
+    public static final int BTRC_FEAT_ABSOLUTE_VOLUME = 0x02;
+    public static final int BTRC_FEAT_BROWSE = 0x04;
+
+}
diff --git a/core/java/android/bluetooth/BluetoothHeadset.java b/core/java/android/bluetooth/BluetoothHeadset.java
index 09a15de..da81032 100644
--- a/core/java/android/bluetooth/BluetoothHeadset.java
+++ b/core/java/android/bluetooth/BluetoothHeadset.java
@@ -20,11 +20,11 @@ import android.annotation.SdkConstant;
 import android.annotation.SdkConstant.SdkConstantType;
 import android.content.ComponentName;
 import android.content.Context;
-import android.os.Handler;
+import android.content.Intent;
+import android.content.ServiceConnection;
 import android.os.IBinder;
-import android.os.Looper;
-import android.os.Message;
 import android.os.RemoteException;
+import android.os.UserHandle;
 import android.util.Log;
 
 import java.util.ArrayList;
@@ -47,7 +47,7 @@ import java.util.List;
 public final class BluetoothHeadset implements BluetoothProfile {
     private static final String TAG = "BluetoothHeadset";
     private static final boolean DBG = true;
-    private static final boolean VDBG = false;
+    private static final boolean VDBG = true;
 
     /**
      * Intent used to broadcast the change in connection state of the Headset
@@ -129,6 +129,13 @@ public final class BluetoothHeadset implements BluetoothProfile {
             "android.bluetooth.headset.action.VENDOR_SPECIFIC_HEADSET_EVENT";
 
     /**
+     * @hide Broadcast intent when HF indicator value changed is updated by HS.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_HF_INDICATOR_VALUE_CHANGED =
+            "codeaurora.bluetooth.headset.action.ACTION_HF_INDICATOR_VALUE_CHANGED";
+
+    /**
      * A String extra field in {@link #ACTION_VENDOR_SPECIFIC_HEADSET_EVENT}
      * intents that contains the name of the vendor-specific command.
      */
@@ -199,6 +206,20 @@ public final class BluetoothHeadset implements BluetoothProfile {
     public static final String VENDOR_RESULT_CODE_COMMAND_ANDROID = "+ANDROID";
 
     /**
+     * @hide Used for sharing the HF indicator assigned number.
+     */
+    public static final String HF_INDICATOR_ASSIGNED_NUMBER  =
+            "codeaurora.bluetooth.headset.intent.category.anum";
+
+
+    /**
+     * @hide Used for sharing the HF indicator assigned number's value.
+     */
+    public static final String HF_INDICATOR_ASSIGNED_NUMBER_VALUE  =
+            "codeaurora.bluetooth.headset.intent.category.anumvalue";
+
+
+    /**
      * Headset state when SCO audio is not connected.
      * This state can be one of
      * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
@@ -222,8 +243,6 @@ public final class BluetoothHeadset implements BluetoothProfile {
      */
     public static final int STATE_AUDIO_CONNECTED = 12;
 
-    private static final int MESSAGE_HEADSET_SERVICE_CONNECTED = 100;
-    private static final int MESSAGE_HEADSET_SERVICE_DISCONNECTED = 101;
 
     private Context mContext;
     private ServiceListener mServiceListener;
@@ -236,7 +255,14 @@ public final class BluetoothHeadset implements BluetoothProfile {
                     if (DBG) Log.d(TAG, "onBluetoothStateChange: up=" + up);
                     if (!up) {
                         if (VDBG) Log.d(TAG,"Unbinding service...");
-                        doUnbind();
+                        synchronized (mConnection) {
+                            try {
+                                mService = null;
+                                mContext.unbindService(mConnection);
+                            } catch (Exception re) {
+                                Log.e(TAG,"",re);
+                            }
+                        }
                     } else {
                         synchronized (mConnection) {
                             try {
@@ -273,26 +299,15 @@ public final class BluetoothHeadset implements BluetoothProfile {
     }
 
     boolean doBind() {
-        try {
-            return mAdapter.getBluetoothManager().bindBluetoothProfileService(
-                    BluetoothProfile.HEADSET, mConnection);
-        } catch (RemoteException e) {
-            Log.e(TAG, "Unable to bind HeadsetService", e);
-        }
-        return false;
-    }
-
-    void doUnbind() {
-        synchronized (mConnection) {
-            if (mService != null) {
-                try {
-                    mAdapter.getBluetoothManager().unbindBluetoothProfileService(
-                            BluetoothProfile.HEADSET, mConnection);
-                } catch (RemoteException e) {
-                    Log.e(TAG,"Unable to unbind HeadsetService", e);
-                }
-            }
+        Intent intent = new Intent(IBluetoothHeadset.class.getName());
+        ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
+        intent.setComponent(comp);
+        if (comp == null || !mContext.bindServiceAsUser(intent, mConnection, 0,
+                UserHandle.CURRENT_OR_SELF)) {
+            Log.e(TAG, "Could not bind to Bluetooth Headset Service with " + intent);
+            return false;
         }
+        return true;
     }
 
     /**
@@ -312,8 +327,18 @@ public final class BluetoothHeadset implements BluetoothProfile {
                 Log.e(TAG,"",e);
             }
         }
+
+        synchronized (mConnection) {
+            if (mService != null) {
+                try {
+                    mService = null;
+                    mContext.unbindService(mConnection);
+                } catch (Exception re) {
+                    Log.e(TAG,"",re);
+                }
+            }
+        }
         mServiceListener = null;
-        doUnbind();
     }
 
     /**
@@ -969,21 +994,21 @@ public final class BluetoothHeadset implements BluetoothProfile {
         return false;
     }
 
-    private final IBluetoothProfileServiceConnection mConnection
-            = new IBluetoothProfileServiceConnection.Stub()  {
-        @Override
+    private final ServiceConnection mConnection = new ServiceConnection() {
         public void onServiceConnected(ComponentName className, IBinder service) {
             if (DBG) Log.d(TAG, "Proxy object connected");
             mService = IBluetoothHeadset.Stub.asInterface(service);
-            mHandler.sendMessage(mHandler.obtainMessage(
-                    MESSAGE_HEADSET_SERVICE_CONNECTED));
+
+            if (mServiceListener != null) {
+                mServiceListener.onServiceConnected(BluetoothProfile.HEADSET, BluetoothHeadset.this);
+            }
         }
-        @Override
         public void onServiceDisconnected(ComponentName className) {
             if (DBG) Log.d(TAG, "Proxy object disconnected");
             mService = null;
-            mHandler.sendMessage(mHandler.obtainMessage(
-                    MESSAGE_HEADSET_SERVICE_DISCONNECTED));
+            if (mServiceListener != null) {
+                mServiceListener.onServiceDisconnected(BluetoothProfile.HEADSET);
+            }
         }
     };
 
@@ -1007,25 +1032,4 @@ public final class BluetoothHeadset implements BluetoothProfile {
     private static void log(String msg) {
         Log.d(TAG, msg);
     }
-
-    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case MESSAGE_HEADSET_SERVICE_CONNECTED: {
-                    if (mServiceListener != null) {
-                        mServiceListener.onServiceConnected(BluetoothProfile.HEADSET,
-                                BluetoothHeadset.this);
-                    }
-                    break;
-                }
-                case MESSAGE_HEADSET_SERVICE_DISCONNECTED: {
-                    if (mServiceListener != null) {
-                        mServiceListener.onServiceDisconnected(BluetoothProfile.HEADSET);
-                    }
-                    break;
-                }
-            }
-        }
-    };
 }
diff --git a/core/java/android/bluetooth/IBluetoothAvrcpController.aidl b/core/java/android/bluetooth/IBluetoothAvrcpController.aidl
index f917a50..fb61c98 100644
--- a/core/java/android/bluetooth/IBluetoothAvrcpController.aidl
+++ b/core/java/android/bluetooth/IBluetoothAvrcpController.aidl
@@ -1,4 +1,5 @@
 /*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
  * Copyright (C) 2014 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -17,6 +18,7 @@
 package android.bluetooth;
 
 import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothAvrcpInfo;
 
 /**
  * APIs for Bluetooth AVRCP controller service
@@ -28,4 +30,10 @@ interface IBluetoothAvrcpController {
     List<BluetoothDevice> getDevicesMatchingConnectionStates(in int[] states);
     int getConnectionState(in BluetoothDevice device);
     void sendPassThroughCmd(in BluetoothDevice device, int keyCode, int keyState);
+    void getMetaData(in int[] attributeIds);
+    void getPlayStatus(in int[] playStatusIds);
+    void getPlayerApplicationSetting();
+    void setPlayerApplicationSetting(in int attributeId, in int attribVal);
+    BluetoothAvrcpInfo getSupportedPlayerAppSetting(in BluetoothDevice device);
+    int getSupportedFeatures(in BluetoothDevice device);
 }
diff --git a/core/java/android/bluetooth/IBluetoothManager.aidl b/core/java/android/bluetooth/IBluetoothManager.aidl
index 0b81ee8..bd8c6c9 100644
--- a/core/java/android/bluetooth/IBluetoothManager.aidl
+++ b/core/java/android/bluetooth/IBluetoothManager.aidl
@@ -19,7 +19,6 @@ package android.bluetooth;
 import android.bluetooth.IBluetooth;
 import android.bluetooth.IBluetoothGatt;
 import android.bluetooth.IBluetoothManagerCallback;
-import android.bluetooth.IBluetoothProfileServiceConnection;
 import android.bluetooth.IBluetoothStateChangeCallback;
 
 /**
@@ -34,14 +33,11 @@ interface IBluetoothManager
     void registerStateChangeCallback(in IBluetoothStateChangeCallback callback);
     void unregisterStateChangeCallback(in IBluetoothStateChangeCallback callback);
     boolean isEnabled();
-    boolean enable();
+    boolean enable(String callingPackage);
     boolean enableNoAutoConnect();
     boolean disable(boolean persist);
     IBluetoothGatt getBluetoothGatt();
 
-    boolean bindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);
-    void unbindBluetoothProfileService(int profile, IBluetoothProfileServiceConnection proxy);
-
     String getAddress();
     String getName();
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index f0f72a3..4f3583c 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -7333,6 +7333,9 @@ public final class Settings {
                 BLUETOOTH_A2DP_SINK_PRIORITY_PREFIX = "bluetooth_a2dp_sink_priority_";
         /** {@hide} */
         public static final String
+                BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX = "bluetooth_a2dp_src_priority_";
+        /** {@hide} */
+        public static final String
                 BLUETOOTH_INPUT_DEVICE_PRIORITY_PREFIX = "bluetooth_input_device_priority_";
         /** {@hide} */
         public static final String
@@ -7435,6 +7438,14 @@ public final class Settings {
         }
 
         /**
+         * Get the key that retrieves a bluetooth a2dp src's priority.
+         * @hide
+         */
+        public static final String getBluetoothA2dpSrcPriorityKey(String address) {
+            return BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX + address.toUpperCase(Locale.ROOT);
+        }
+
+        /**
          * Get the key that retrieves a bluetooth Input Device's priority.
          * @hide
          */
diff --git a/media/java/android/media/AudioManager.java b/media/java/android/media/AudioManager.java
index 875e716..fc917f6 100644
--- a/media/java/android/media/AudioManager.java
+++ b/media/java/android/media/AudioManager.java
@@ -67,7 +67,6 @@ public class AudioManager {
     private final boolean mUseFixedVolume;
     private static String TAG = "AudioManager";
     private static final AudioPortEventHandler sAudioPortEventHandler = new AudioPortEventHandler();
-
     /**
      * Broadcast intent, a hint for applications that audio is about to become
      * 'noisy' due to a change in audio outputs. For example, this intent may
@@ -310,6 +309,32 @@ public class AudioManager {
      */
     public static final String EXTRA_ENCODINGS = "android.media.extra.ENCODINGS";
 
+    /**
+     * @hide Broadcast intent when RemoteControlClient list is updated.
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String RCC_CHANGED_ACTION =
+                "org.codeaurora.bluetooth.RCC_CHANGED_ACTION";
+
+    /**
+     * @hide Used for sharing the calling package name
+     */
+    public static final String EXTRA_CALLING_PACKAGE_NAME =
+            "org.codeaurora.bluetooth.EXTRA_CALLING_PACKAGE_NAME";
+
+    /**
+     * @hide Used for sharing the focus changed value
+     */
+    public static final String EXTRA_FOCUS_CHANGED_VALUE =
+            "org.codeaurora.bluetooth.EXTRA_FOCUS_CHANGED_VALUE";
+
+    /**
+     * @hide Used for sharing the availability changed value
+     */
+    public static final String EXTRA_AVAILABLITY_CHANGED_VALUE =
+            "org.codeaurora.bluetooth.EXTRA_AVAILABLITY_CHANGED_VALUE";
+
+
     /** The audio stream for phone calls */
     public static final int STREAM_VOICE_CALL = AudioSystem.STREAM_VOICE_CALL;
     /** The audio stream for system sounds */
@@ -2481,6 +2506,7 @@ public class AudioManager {
 
     //====================================================================
     // Remote Control
+
     /**
      * Register a component to be the sole receiver of MEDIA_BUTTON intents.
      * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}
@@ -2499,6 +2525,7 @@ public class AudioManager {
                     "receiver and context package names don't match");
             return;
         }
+
         // construct a PendingIntent for the media button and register it
         Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
         //     the associated intent will be handled by the component being registered
@@ -2508,6 +2535,7 @@ public class AudioManager {
         registerMediaButtonIntent(pi, eventReceiver);
     }
 
+
     /**
      * Register a component to be the sole receiver of MEDIA_BUTTON intents.  This is like
      * {@link #registerMediaButtonEventReceiver(android.content.ComponentName)}, but allows
@@ -2637,6 +2665,13 @@ public class AudioManager {
             return false;
         }
         rctlr.startListeningToSessions();
+        IAudioService service = getService();
+        try {
+            service.updateRemoteControllerOnExistingMediaPlayers();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error in calling Audio service interface" +
+                "updateRemoteControllerOnExistingMediaPlayers() due to " + e);
+        }
         return true;
     }
 
@@ -2660,6 +2695,24 @@ public class AudioManager {
 
     /**
      * @hide
+     */
+    public void updateMediaPlayerList(String packageName, boolean toAdd) {
+        IAudioService service = getService();
+        try {
+            if (toAdd) {
+                Log.d(TAG, "updateMediaPlayerList: Add RCC " + packageName + " to List");
+                service.addMediaPlayerAndUpdateRemoteController(packageName);
+            } else {
+                Log.d(TAG, "updateMediaPlayerList: Remove RCC " + packageName + " from List");
+                service.removeMediaPlayerAndUpdateRemoteController(packageName);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Exception while executing updateMediaPlayerList: " + e);
+        }
+    }
+
+    /**
+     * @hide
      * Registers a remote control display that will be sent information by remote control clients.
      * Use this method if your IRemoteControlDisplay is not going to display artwork, otherwise
      * use {@link #registerRemoteControlDisplay(IRemoteControlDisplay, int, int)} to pass the
@@ -2811,6 +2864,52 @@ public class AudioManager {
         }
     }
 
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to play the requested item.
+     * @param generationId the RemoteControlClient generation counter for which this request is
+     *     issued.
+     * @param uid uid of the song to be played.
+     * @scope scope of the file system to use
+     */
+    public void setRemoteControlClientPlayItem(long uid, int scope) {
+        IAudioService service = getService();
+        try {
+            service.setRemoteControlClientPlayItem(uid, scope);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setRemoteControlClientPlayItem(" +
+                                                    uid + ", " + scope + ")", e);
+        }
+    }
+
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to provide with the now playing list entries.
+     * @param generationId the RemoteControlClient generation counter for which this request is
+     *     issued.
+     */
+    public void getRemoteControlClientNowPlayingEntries() {
+        IAudioService service = getService();
+        try {
+            service.getRemoteControlClientNowPlayingEntries();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getRemoteControlClientNowPlayingEntries(" + ")", e);
+        }
+    }
+
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to set the music player as current browsed player.
+     */
+    public void setRemoteControlClientBrowsedPlayer() {
+        Log.d(TAG, "setRemoteControlClientBrowsedPlayer: ");
+        IAudioService service = getService();
+        try {
+            service.setRemoteControlClientBrowsedPlayer();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in setRemoteControlClientBrowsedPlayer(" + ")", e);
+        }
+    }
 
     /**
      *  @hide
diff --git a/media/java/android/media/IAudioService.aidl b/media/java/android/media/IAudioService.aidl
index 8aebe11..0b98e1b 100644
--- a/media/java/android/media/IAudioService.aidl
+++ b/media/java/android/media/IAudioService.aidl
@@ -215,4 +215,16 @@ interface IAudioService {
     int setFocusPropertiesForPolicy(int duckingBehavior, in IAudioPolicyCallback pcb);
 
     void setVolumePolicy(in VolumePolicy policy);
+
+    void setRemoteControlClientBrowsedPlayer();
+
+    void getRemoteControlClientNowPlayingEntries();
+
+    void setRemoteControlClientPlayItem(long uid, int scope);
+
+    void updateRemoteControllerOnExistingMediaPlayers();
+
+    void addMediaPlayerAndUpdateRemoteController(String packageName);
+
+    void removeMediaPlayerAndUpdateRemoteController(String packageName);
 }
diff --git a/media/java/android/media/IRemoteControlClient.aidl b/media/java/android/media/IRemoteControlClient.aidl
index aa142d6..bbeef62 100644
--- a/media/java/android/media/IRemoteControlClient.aidl
+++ b/media/java/android/media/IRemoteControlClient.aidl
@@ -52,11 +52,14 @@ oneway interface IRemoteControlClient
      */
     void setCurrentClientGenerationId(int clientGeneration);
 
-    void   plugRemoteControlDisplay(IRemoteControlDisplay rcd, int w, int h);
+    void plugRemoteControlDisplay(IRemoteControlDisplay rcd, int w, int h);
     void unplugRemoteControlDisplay(IRemoteControlDisplay rcd);
     void setBitmapSizeForDisplay(IRemoteControlDisplay rcd, int w, int h);
     void setWantsSyncForDisplay(IRemoteControlDisplay rcd, boolean wantsSync);
     void enableRemoteControlDisplay(IRemoteControlDisplay rcd, boolean enabled);
     void seekTo(int clientGeneration, long timeMs);
     void updateMetadata(int clientGeneration, int key, in Rating value);
-}
\ No newline at end of file
+    void setPlayItem(int scope, long uid);
+    void setBrowsedPlayer();
+    void getNowPlayingEntries();
+}
diff --git a/media/java/android/media/RemoteController.java b/media/java/android/media/RemoteController.java
index d84cf30..aba7ad6 100644
--- a/media/java/android/media/RemoteController.java
+++ b/media/java/android/media/RemoteController.java
@@ -88,6 +88,7 @@ import java.util.List;
     private boolean mIsRegistered = false;
     private PendingIntent mClientPendingIntentCurrent;
     private OnClientUpdateListener mOnClientUpdateListener;
+    private OnClientAvrcpUpdateListener mOnClientAvrcpUpdateListener;
     private PlaybackInfo mLastPlaybackInfo;
     private int mArtworkWidth = -1;
     private int mArtworkHeight = -1;
@@ -150,6 +151,25 @@ import java.util.List;
         }
     }
 
+    /**
+     * @hide
+     */
+    public RemoteController(Context context, OnClientUpdateListener updateListener, Looper looper,
+                OnClientAvrcpUpdateListener avrcpUpdateListener) throws IllegalArgumentException {
+        this(context, updateListener, looper);
+        mOnClientAvrcpUpdateListener = avrcpUpdateListener;
+    }
+
+    /**
+     * @hide
+     */
+    public interface OnClientAvrcpUpdateListener {
+        public void onClientFolderInfoBrowsedPlayer(String stringUri);
+        public void onClientUpdateNowPlayingEntries(long[] playList);
+        public void onClientNowPlayingContentChange();
+        public void onClientPlayItemResponse(boolean success);
+    };
+
 
     /**
      * Interface definition for the callbacks to be invoked whenever media events, metadata
@@ -355,6 +375,7 @@ import java.util.List;
      * @throws IllegalArgumentException
      */
     public boolean seekTo(long timeMs) throws IllegalArgumentException {
+        Log.e(TAG, "seekTo() in RemoteController");
         if (!mEnabled) {
             Log.e(TAG, "Cannot use seekTo() from a disabled RemoteController");
             return false;
@@ -370,6 +391,69 @@ import java.util.List;
         return true;
     }
 
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to play the requested item.
+     * @param generationId the RemoteControlClient generation counter for which this request is
+     *     issued.
+     * @param uid uid of the song to be played.
+     * @scope scope of the file system to use
+     */
+    public void setRemoteControlClientPlayItem(long uid, int scope) {
+        Log.e(TAG, "setRemoteControlClientPlayItem()");
+        if (!mEnabled) {
+            Log.e(TAG, "Cannot use setRemoteControlClientPlayItem()" +
+                                            " from a disabled RemoteController");
+            return;
+        }
+        synchronized (mInfoLock) {
+            if (mCurrentSession != null) {
+                mCurrentSession.getTransportControls().setRemoteControlClientPlayItem(uid, scope);
+            }
+        }
+        return;
+    }
+
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to provide with the now playing list entries.
+     * @param generationId the RemoteControlClient generation counter for which this request is
+     *     issued.
+     */
+    public void getRemoteControlClientNowPlayingEntries() {
+        Log.e(TAG, "getRemoteControlClientNowPlayingEntries()");
+        if (!mEnabled) {
+            Log.e(TAG, "Cannot use getRemoteControlClientNowPlayingEntries()" +
+                                            " from a disabled RemoteController");
+            return;
+        }
+        synchronized (mInfoLock) {
+            if (mCurrentSession != null) {
+                mCurrentSession.getTransportControls().getRemoteControlClientNowPlayingEntries();
+            }
+        }
+        return;
+    }
+
+    /**
+     * @hide
+     * Request the user of a RemoteControlClient to set the music player as current browsed player.
+     * @param packageName package name of the targeted media player.
+     */
+    public void setRemoteControlClientBrowsedPlayer() {
+        Log.e(TAG, "setRemoteControlClientBrowsedPlayer()");
+        if (!mEnabled) {
+            Log.e(TAG, "Cannot use setRemoteControlClientBrowsedPlayer()" +
+                                            " from a disabled RemoteController");
+            return;
+        }
+        synchronized (mInfoLock) {
+            if (mCurrentSession != null) {
+                mCurrentSession.getTransportControls().setRemoteControlClientBrowsedPlayer();
+            }
+        }
+        return;
+    }
 
     /**
      * @hide
@@ -704,6 +788,30 @@ import java.util.List;
         public void onMetadataChanged(MediaMetadata metadata) {
             onNewMediaMetadata(metadata);
         }
+
+        @Override
+        public void onUpdateFolderInfoBrowsedPlayer(String stringUri) {
+            Log.d(TAG, "MediaControllerCallback: onUpdateFolderInfoBrowsedPlayer");
+            onFolderInfoBrowsedPlayer(stringUri);
+        }
+
+        @Override
+        public void onUpdateNowPlayingEntries(long[] playList) {
+            Log.d(TAG, "MediaControllerCallback: onUpdateNowPlayingEntries");
+            onNowPlayingEntriesUpdate(playList);
+        }
+
+        @Override
+        public void onUpdateNowPlayingContentChange() {
+            Log.d(TAG, "MediaControllerCallback: onUpdateNowPlayingContentChange");
+            onNowPlayingContentChange();
+        }
+
+        @Override
+        public void onPlayItemResponse(boolean success) {
+            Log.d(TAG, "MediaControllerCallback: onPlayItemResponse");
+            onSetPlayItemResponse(success);
+        }
     }
 
     /**
@@ -980,6 +1088,8 @@ import java.util.List;
         synchronized (mInfoLock) {
             if (controller == null) {
                 if (mCurrentSession != null) {
+                    Log.v(TAG, "Updating current controller as null");
+                    mAudioManager.updateMediaPlayerList(mCurrentSession.getPackageName(), false);
                     mCurrentSession.unregisterCallback(mSessionCb);
                     mCurrentSession = null;
                     sendMsg(mEventHandler, MSG_CLIENT_CHANGE, SENDMSG_REPLACE,
@@ -989,13 +1099,21 @@ import java.util.List;
                     || !controller.getSessionToken()
                             .equals(mCurrentSession.getSessionToken())) {
                 if (mCurrentSession != null) {
+                    Log.v(TAG, "Updating current controller package as " +
+                     controller.getPackageName() + " from " + mCurrentSession.getPackageName());
                     mCurrentSession.unregisterCallback(mSessionCb);
+                } else {
+                    Log.v(TAG, "Updating current controller package as " +
+                      controller.getPackageName() + " from null");
                 }
+
                 sendMsg(mEventHandler, MSG_CLIENT_CHANGE, SENDMSG_REPLACE,
                         0 /* genId */, 0 /* clearing */, null /* obj */, 0 /* delay */);
                 mCurrentSession = controller;
                 mCurrentSession.registerCallback(mSessionCb, mEventHandler);
 
+                mAudioManager.updateMediaPlayerList(mCurrentSession.getPackageName(), true);
+
                 PlaybackState state = controller.getPlaybackState();
                 sendMsg(mEventHandler, MSG_NEW_PLAYBACK_STATE, SENDMSG_REPLACE,
                         0 /* genId */, 0, state /* obj */, 0 /* delay */);
@@ -1052,6 +1170,74 @@ import java.util.List;
         }
     }
 
+    private void onFolderInfoBrowsedPlayer(String stringUri) {
+        Log.d(TAG, "RemoteController: onFolderInfoBrowsedPlayer");
+        final OnClientAvrcpUpdateListener l;
+
+        synchronized(mInfoLock) {
+            l = mOnClientAvrcpUpdateListener;
+        }
+
+        try {
+            if (l != null) {
+                l.onClientFolderInfoBrowsedPlayer(stringUri);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error Updating AVRCP on receiving Browsed player response", e);
+        }
+    }
+
+    private void onNowPlayingEntriesUpdate(long[] playList) {
+        Log.d(TAG, "RemoteController: onUpdateNowPlayingEntries");
+        final OnClientAvrcpUpdateListener l;
+
+        synchronized(mInfoLock) {
+            l = mOnClientAvrcpUpdateListener;
+        }
+
+        try {
+            if (l != null) {
+                l.onClientUpdateNowPlayingEntries(playList);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error Updating AVRCP on receiving Now Playing Entries", e);
+        }
+    }
+
+    private void onNowPlayingContentChange() {
+        Log.d(TAG, "RemoteController: onNowPlayingContentChange");
+        final OnClientAvrcpUpdateListener l;
+
+        synchronized(mInfoLock) {
+            l = mOnClientAvrcpUpdateListener;
+        }
+
+        try {
+            if (l != null) {
+                l.onClientNowPlayingContentChange();
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error Updating AVRCP on Now Playing Content Change", e);
+        }
+    }
+
+    private void onSetPlayItemResponse(boolean success) {
+        Log.d(TAG, "RemoteController: onPlayItemResponse");
+        final OnClientAvrcpUpdateListener l;
+
+        synchronized(mInfoLock) {
+            l = mOnClientAvrcpUpdateListener;
+        }
+
+        try {
+            if (l != null) {
+                l.onClientPlayItemResponse(success);
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Error Updating AVRCP on receiving Play Item response", e);
+        }
+    }
+
     //==================================================
     private static class PlaybackInfo {
         int mState;
diff --git a/media/java/android/media/session/ISession.aidl b/media/java/android/media/session/ISession.aidl
index bd0019f..34eadcb 100644
--- a/media/java/android/media/session/ISession.aidl
+++ b/media/java/android/media/session/ISession.aidl
@@ -45,6 +45,10 @@ interface ISession {
     void setQueueTitle(CharSequence title);
     void setExtras(in Bundle extras);
     void setRatingType(int type);
+    void playItemResponse(boolean success);
+    void updateNowPlayingEntries(in long[] playList);
+    void updateFolderInfoBrowsedPlayer(String stringUri);
+    void updateNowPlayingContentChange();
 
     // These commands relate to volume handling
     void setPlaybackToLocal(in AudioAttributes attributes);
diff --git a/media/java/android/media/session/ISessionCallback.aidl b/media/java/android/media/session/ISessionCallback.aidl
index adb6b06..ed13ff6 100644
--- a/media/java/android/media/session/ISessionCallback.aidl
+++ b/media/java/android/media/session/ISessionCallback.aidl
@@ -41,6 +41,9 @@ oneway interface ISessionCallback {
     void onFastForward();
     void onRewind();
     void onSeekTo(long pos);
+    void setRemoteControlClientBrowsedPlayer();
+    void setRemoteControlClientPlayItem(long uid, int scope);
+    void getRemoteControlClientNowPlayingEntries();
     void onRate(in Rating rating);
     void onCustomAction(String action, in Bundle args);
 
diff --git a/media/java/android/media/session/ISessionController.aidl b/media/java/android/media/session/ISessionController.aidl
index 285e5f7..006ffac 100644
--- a/media/java/android/media/session/ISessionController.aidl
+++ b/media/java/android/media/session/ISessionController.aidl
@@ -62,6 +62,9 @@ interface ISessionController {
     void fastForward();
     void rewind();
     void seekTo(long pos);
+    void setRemoteControlClientBrowsedPlayer();
+    void setRemoteControlClientPlayItem(long uid, int scope);
+    void getRemoteControlClientNowPlayingEntries();
     void rate(in Rating rating);
     void sendCustomAction(String action, in Bundle args);
     MediaMetadata getMetadata();
diff --git a/media/java/android/media/session/ISessionControllerCallback.aidl b/media/java/android/media/session/ISessionControllerCallback.aidl
index cf31767..a5ad913 100644
--- a/media/java/android/media/session/ISessionControllerCallback.aidl
+++ b/media/java/android/media/session/ISessionControllerCallback.aidl
@@ -36,4 +36,8 @@ oneway interface ISessionControllerCallback {
     void onQueueTitleChanged(CharSequence title);
     void onExtrasChanged(in Bundle extras);
     void onVolumeInfoChanged(in ParcelableVolumeInfo info);
+    void onPlayItemResponse(boolean success);
+    void onUpdateNowPlayingEntries(in long[] playList);
+    void onUpdateFolderInfoBrowsedPlayer(String stringUri);
+    void onUpdateNowPlayingContentChange();
 }
diff --git a/media/java/android/media/session/MediaController.java b/media/java/android/media/session/MediaController.java
index b1a51a5..f1f9516 100644
--- a/media/java/android/media/session/MediaController.java
+++ b/media/java/android/media/session/MediaController.java
@@ -64,6 +64,10 @@ public final class MediaController {
     private static final int MSG_UPDATE_QUEUE_TITLE = 6;
     private static final int MSG_UPDATE_EXTRAS = 7;
     private static final int MSG_DESTROYED = 8;
+    private static final int MSG_FOLDER_INFO_BROWSED_PLAYER = 9;
+    private static final int MSG_UPDATE_NOWPLAYING_ENTRIES = 10;
+    private static final int MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE = 11;
+    private static final int MSG_PLAY_ITEM_RESPONSE = 12;
 
     private final ISessionController mSessionBinder;
 
@@ -579,6 +583,31 @@ public final class MediaController {
          */
         public void onAudioInfoChanged(PlaybackInfo info) {
         }
+
+        /**
+         * @hide
+         */
+        public void onUpdateFolderInfoBrowsedPlayer(String stringUri) {
+        }
+
+        /**
+         * @hide
+         */
+        public void onUpdateNowPlayingEntries(long[] playList) {
+        }
+
+        /**
+         * @hide
+         */
+        public void onUpdateNowPlayingContentChange() {
+        }
+
+        /**
+         * @hide
+         */
+        public void onPlayItemResponse(boolean success) {
+        }
+
     }
 
     /**
@@ -704,6 +733,7 @@ public final class MediaController {
          * @param pos Position to move to, in milliseconds.
          */
         public void seekTo(long pos) {
+            Log.d(TAG, "seekTo in TransportControls");
             try {
                 mSessionBinder.seekTo(pos);
             } catch (RemoteException e) {
@@ -712,6 +742,42 @@ public final class MediaController {
         }
 
         /**
+         * @hide
+         */
+        public void setRemoteControlClientBrowsedPlayer() {
+            Log.d(TAG, "setRemoteControlClientBrowsedPlayer in TransportControls");
+            try {
+                mSessionBinder.setRemoteControlClientBrowsedPlayer();
+            } catch (RemoteException e) {
+                Log.wtf(TAG, "Error calling setRemoteControlClientBrowsedPlayer.", e);
+            }
+        }
+
+        /**
+         * @hide
+         */
+        public void setRemoteControlClientPlayItem(long uid, int scope) {
+            Log.d(TAG, "setRemoteControlClientPlayItem in TransportControls");
+            try {
+                mSessionBinder.setRemoteControlClientPlayItem(uid, scope);
+            } catch (RemoteException e) {
+                Log.wtf(TAG, "Error calling setRemoteControlClientPlayItem.", e);
+            }
+        }
+
+        /**
+         * @hide
+         */
+        public void getRemoteControlClientNowPlayingEntries() {
+            Log.d(TAG, "getRemoteControlClientNowPlayingEntries in TransportControls");
+            try {
+                mSessionBinder.getRemoteControlClientNowPlayingEntries();
+            } catch (RemoteException e) {
+                Log.wtf(TAG, "Error calling getRemoteControlClientNowPlayingEntries.", e);
+            }
+        }
+
+        /**
          * Start fast forwarding. If playback is already fast forwarding this
          * may increase the rate.
          */
@@ -973,6 +1039,42 @@ public final class MediaController {
             }
         }
 
+        @Override
+        public void onUpdateFolderInfoBrowsedPlayer(String stringUri) {
+            Log.d(TAG, "CallBackStub: onUpdateFolderInfoBrowsedPlayer");
+            MediaController controller = mController.get();
+            if (controller != null) {
+                controller.postMessage(MSG_FOLDER_INFO_BROWSED_PLAYER, stringUri, null);
+            }
+        }
+
+        @Override
+        public void onUpdateNowPlayingEntries(long[] playList) {
+            Log.d(TAG, "CallBackStub: onUpdateNowPlayingEntries");
+            MediaController controller = mController.get();
+            if (controller != null) {
+                controller.postMessage(MSG_UPDATE_NOWPLAYING_ENTRIES, playList, null);
+            }
+        }
+
+        @Override
+        public void onUpdateNowPlayingContentChange() {
+            Log.d(TAG, "CallBackStub: onUpdateNowPlayingContentChange");
+            MediaController controller = mController.get();
+            if (controller != null) {
+                controller.postMessage(MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE, null, null);
+            }
+        }
+
+        @Override
+        public void onPlayItemResponse(boolean success) {
+            Log.d(TAG, "CallBackStub: onPlayItemResponse");
+            MediaController controller = mController.get();
+            if (controller != null) {
+                controller.postMessage(MSG_PLAY_ITEM_RESPONSE, new Boolean(success), null);
+            }
+        }
+
     }
 
     private final static class MessageHandler extends Handler {
@@ -1014,6 +1116,18 @@ public final class MediaController {
                 case MSG_DESTROYED:
                     mCallback.onSessionDestroyed();
                     break;
+                case MSG_FOLDER_INFO_BROWSED_PLAYER:
+                    mCallback.onUpdateFolderInfoBrowsedPlayer((String) msg.obj);
+                    break;
+                case MSG_UPDATE_NOWPLAYING_ENTRIES:
+                    mCallback.onUpdateNowPlayingEntries((long[]) msg.obj);
+                    break;
+                case MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE:
+                    mCallback.onUpdateNowPlayingContentChange();
+                    break;
+                case MSG_PLAY_ITEM_RESPONSE:
+                    mCallback.onPlayItemResponse(((Boolean)(msg.obj)).booleanValue());
+                    break;
             }
         }
 
diff --git a/media/java/android/media/session/MediaSession.java b/media/java/android/media/session/MediaSession.java
index e1e9b79..be89dfc 100644
--- a/media/java/android/media/session/MediaSession.java
+++ b/media/java/android/media/session/MediaSession.java
@@ -493,6 +493,58 @@ public final class MediaSession {
     }
 
     /**
+    * @hide
+    */
+    public void playItemResponse(boolean success) {
+        Log.d(TAG, "MediaSession: playItemResponse");
+
+        try {
+            mBinder.playItemResponse(success);
+        } catch (RemoteException e) {
+            Log.wtf(TAG, "Dead object in playItemResponse.", e);
+        }
+    }
+
+    /**
+    * @hide
+    */
+    public void updateNowPlayingEntries(long[] playList) {
+        Log.d(TAG, "MediaSession: updateNowPlayingEntries");
+
+        try {
+            mBinder.updateNowPlayingEntries(playList);
+        } catch (RemoteException e) {
+            Log.wtf(TAG, "Dead object in updateNowPlayingEntries.", e);
+        }
+    }
+
+    /**
+    * @hide
+    */
+    public void updateFolderInfoBrowsedPlayer(String stringUri) {
+        Log.d(TAG, "MediaSession: updateFolderInfoBrowsedPlayer");
+
+        try {
+            mBinder.updateFolderInfoBrowsedPlayer(stringUri);
+        } catch (RemoteException e) {
+            Log.wtf(TAG, "Dead object in updateFolderInfoBrowsedPlayer.", e);
+        }
+    }
+
+    /**
+    * @hide
+    */
+    public void updateNowPlayingContentChange() {
+        Log.d(TAG, "MediaSession: updateNowPlayingContentChange");
+
+        try {
+            mBinder.updateNowPlayingContentChange();
+        } catch (RemoteException e) {
+            Log.wtf(TAG, "Dead object in updateNowPlayingContentChange.", e);
+        }
+    }
+
+    /**
      * Notify the system that the remote volume changed.
      *
      * @param provider The provider that is handling volume changes.
@@ -572,6 +624,34 @@ public final class MediaSession {
         postToCallback(CallbackMessageHandler.MSG_MEDIA_BUTTON, mediaButtonIntent);
     }
 
+    private void dispatchSetBrowsedPlayerCommand() {
+        postToCallback(CallbackMessageHandler.MSG_SET_BROWSED_PLAYER);
+    }
+
+    private void dispatchSetPlayItemCommand(long uid, int scope) {
+        PlayItemToken playItemToken = new PlayItemToken(uid, scope);
+        postToCallback(CallbackMessageHandler.MSG_SET_PLAY_ITEM, playItemToken);
+    }
+
+    private class PlayItemToken {
+        private long mUid;
+        private int mScope;
+        public PlayItemToken(long uid, int scope) {
+            mUid = uid;
+            mScope = scope;
+        }
+        public int getScope() {
+            return mScope;
+        }
+        public long getUid() {
+            return mUid;
+        }
+    }
+
+    private void dispatchGetNowPlayingItemsCommand() {
+        postToCallback(CallbackMessageHandler.MSG_GET_NOW_PLAYING_ITEMS);
+    }
+
     private void dispatchAdjustVolume(int direction) {
         postToCallback(CallbackMessageHandler.MSG_ADJUST_VOLUME, direction);
     }
@@ -894,6 +974,25 @@ public final class MediaSession {
          */
         public void onCustomAction(@NonNull String action, @Nullable Bundle extras) {
         }
+
+        /**
+         * @hide
+         */
+        public void setBrowsedPlayer() {
+        }
+
+        /**
+         * @hide
+         */
+        public void setPlayItem(int scope, long uid) {
+        }
+
+        /**
+         * @hide
+         */
+        public void getNowPlayingEntries() {
+        }
+
     }
 
     /**
@@ -1034,6 +1133,33 @@ public final class MediaSession {
         }
 
         @Override
+        public void setRemoteControlClientBrowsedPlayer() throws RemoteException {
+            Log.d(TAG, "setRemoteControlClientBrowsedPlayer in CallbackStub");
+            MediaSession session = mMediaSession.get();
+            if (session != null) {
+                session.dispatchSetBrowsedPlayerCommand();
+            }
+        }
+
+        @Override
+        public void setRemoteControlClientPlayItem(long uid, int scope) throws RemoteException {
+            Log.d(TAG, "setRemoteControlClientPlayItem in CallbackStub");
+            MediaSession session = mMediaSession.get();
+            if (session != null) {
+                session.dispatchSetPlayItemCommand(uid, scope);
+            }
+        }
+
+        @Override
+        public void getRemoteControlClientNowPlayingEntries() throws RemoteException {
+            Log.d(TAG, "getRemoteControlClientNowPlayingEntries in CallbackStub");
+            MediaSession session = mMediaSession.get();
+            if (session != null) {
+                session.dispatchGetNowPlayingItemsCommand();
+            }
+        }
+
+        @Override
         public void onCustomAction(String action, Bundle args) {
             MediaSession session = mMediaSession.get();
             if (session != null) {
@@ -1173,6 +1299,9 @@ public final class MediaSession {
         private static final int MSG_ADJUST_VOLUME = 16;
         private static final int MSG_SET_VOLUME = 17;
         private static final int MSG_PLAY_URI = 18;
+        private static final int MSG_SET_BROWSED_PLAYER = 19;
+        private static final int MSG_SET_PLAY_ITEM = 20;
+        private static final int MSG_GET_NOW_PLAYING_ITEMS = 21;
 
         private MediaSession.Callback mCallback;
 
@@ -1267,6 +1396,18 @@ public final class MediaSession {
                     if (vp != null) {
                         vp.onSetVolumeTo((int) msg.obj);
                     }
+                case MSG_SET_BROWSED_PLAYER:
+                    Log.d(TAG, "MSG_SET_BROWSED_PLAYER received in CallbackMessageHandler");
+                    mCallback.setBrowsedPlayer();
+                    break;
+                case MSG_SET_PLAY_ITEM:
+                    Log.d(TAG, "MSG_SET_PLAY_ITEM received in CallbackMessageHandler");
+                    PlayItemToken playItemToken = (PlayItemToken) msg.obj;
+                    mCallback.setPlayItem(playItemToken.getScope(), playItemToken.getUid());
+                    break;
+                case MSG_GET_NOW_PLAYING_ITEMS:
+                    Log.d(TAG, "MSG_GET_NOW_PLAYING_ITEMS received in CallbackMessageHandler");
+                    mCallback.getNowPlayingEntries();
                     break;
             }
         }
diff --git a/services/core/java/com/android/server/BluetoothManagerService.java b/services/core/java/com/android/server/BluetoothManagerService.java
index d5c4a41..f6f5867 100644
--- a/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/services/core/java/com/android/server/BluetoothManagerService.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,14 +23,11 @@ import android.Manifest;
 import android.app.ActivityManager;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetooth;
 import android.bluetooth.IBluetoothCallback;
 import android.bluetooth.IBluetoothGatt;
-import android.bluetooth.IBluetoothHeadset;
 import android.bluetooth.IBluetoothManager;
 import android.bluetooth.IBluetoothManagerCallback;
-import android.bluetooth.IBluetoothProfileServiceConnection;
 import android.bluetooth.IBluetoothStateChangeCallback;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -63,7 +63,7 @@ import java.util.Map;
 
 class BluetoothManagerService extends IBluetoothManager.Stub {
     private static final String TAG = "BluetoothManagerService";
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
 
     private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
     private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
@@ -80,8 +80,6 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     private static final int ERROR_RESTART_TIME_MS = 3000;
     //Maximum msec to delay MESSAGE_USER_SWITCHED
     private static final int USER_SWITCHED_TIME_MS = 200;
-    // Delay for the addProxy function in msec
-    private static final int ADD_PROXY_DELAY_MS = 100;
 
     private static final int MESSAGE_ENABLE = 1;
     private static final int MESSAGE_DISABLE = 2;
@@ -98,8 +96,6 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     private static final int MESSAGE_GET_NAME_AND_ADDRESS=200;
     private static final int MESSAGE_SAVE_NAME_AND_ADDRESS=201;
     private static final int MESSAGE_USER_SWITCHED = 300;
-    private static final int MESSAGE_ADD_PROXY_DELAYED = 400;
-    private static final int MESSAGE_BIND_PROFILE_SERVICE = 401;
     private static final int MAX_SAVE_RETRIES=3;
     private static final int MAX_ERROR_RESTART_RETRIES=6;
 
@@ -151,11 +147,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     private final BluetoothHandler mHandler;
     private int mErrorRecoveryRetryCounter;
     private final int mSystemUiUid;
-
-    // Save a ProfileServiceConnections object for each of the bound
-    // bluetooth profile services
-    private final Map <Integer, ProfileServiceConnections> mProfileServices =
-            new HashMap <Integer, ProfileServiceConnections>();
+    private boolean mIntentPending = false;
 
     private void registerForAirplaneMode(IntentFilter filter) {
         final ContentResolver resolver = mContext.getContentResolver();
@@ -619,7 +611,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         return true;
 
     }
-    public boolean enable() {
+    public boolean enable(String callingPackage) {
         if ((Binder.getCallingUid() != Process.SYSTEM_UID) &&
             (!checkIfCallerIsForegroundUser())) {
             Log.w(TAG,"enable(): not allowed for non-active and non system user");
@@ -707,69 +699,6 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         return mBluetoothGatt;
     }
 
-    @Override
-    public boolean bindBluetoothProfileService(int bluetoothProfile,
-            IBluetoothProfileServiceConnection proxy) {
-        if (!mEnable) {
-            if (DBG) {
-                Log.d(TAG, "Trying to bind to profile: " + bluetoothProfile +
-                        ", while Bluetooth was disabled");
-            }
-            return false;
-        }
-        synchronized (mProfileServices) {
-            ProfileServiceConnections psc = mProfileServices.get(new Integer(bluetoothProfile));
-            if (psc == null) {
-                if (DBG) {
-                    Log.d(TAG, "Creating new ProfileServiceConnections object for"
-                            + " profile: " + bluetoothProfile);
-                }
-
-                if (bluetoothProfile != BluetoothProfile.HEADSET) return false;
-
-                Intent intent = new Intent(IBluetoothHeadset.class.getName());
-                psc = new ProfileServiceConnections(intent);
-                if (!psc.bindService()) return false;
-
-                mProfileServices.put(new Integer(bluetoothProfile), psc);
-            }
-        }
-
-        // Introducing a delay to give the client app time to prepare
-        Message addProxyMsg = mHandler.obtainMessage(MESSAGE_ADD_PROXY_DELAYED);
-        addProxyMsg.arg1 = bluetoothProfile;
-        addProxyMsg.obj = proxy;
-        mHandler.sendMessageDelayed(addProxyMsg, ADD_PROXY_DELAY_MS);
-        return true;
-    }
-
-    @Override
-    public void unbindBluetoothProfileService(int bluetoothProfile,
-            IBluetoothProfileServiceConnection proxy) {
-        synchronized (mProfileServices) {
-            ProfileServiceConnections psc = mProfileServices.get(new Integer(bluetoothProfile));
-            if (psc == null) {
-                return;
-            }
-            psc.removeProxy(proxy);
-        }
-    }
-
-    private void unbindAllBluetoothProfileServices() {
-        synchronized (mProfileServices) {
-            for (Integer i : mProfileServices.keySet()) {
-                ProfileServiceConnections psc = mProfileServices.get(i);
-                try {
-                    mContext.unbindService(psc);
-                } catch (IllegalArgumentException e) {
-                    Log.e(TAG, "Unable to unbind service with intent: " + psc.mIntent, e);
-                }
-                psc.removeAllProxies();
-            }
-            mProfileServices.clear();
-        }
-    }
-
     /**
      * Send enable message and set adapter name and address. Called when the boot phase becomes
      * PHASE_SYSTEM_SERVICES_READY.
@@ -795,148 +724,6 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_USER_SWITCHED, userHandle, 0));
     }
 
-    /**
-     * This class manages the clients connected to a given ProfileService
-     * and maintains the connection with that service.
-     */
-    final private class ProfileServiceConnections implements ServiceConnection,
-            IBinder.DeathRecipient {
-        final RemoteCallbackList<IBluetoothProfileServiceConnection> mProxies =
-                new RemoteCallbackList <IBluetoothProfileServiceConnection>();
-        IBinder mService;
-        ComponentName mClassName;
-        Intent mIntent;
-        boolean mInvokingProxyCallbacks = false;
-
-        ProfileServiceConnections(Intent intent) {
-            mService = null;
-            mClassName = null;
-            mIntent = intent;
-        }
-
-        private boolean bindService() {
-            if (mIntent != null && mService == null &&
-                    doBind(mIntent, this, 0, UserHandle.CURRENT_OR_SELF)) {
-                Message msg = mHandler.obtainMessage(MESSAGE_BIND_PROFILE_SERVICE);
-                msg.obj = this;
-                mHandler.sendMessageDelayed(msg, TIMEOUT_BIND_MS);
-                return true;
-            }
-            Log.w(TAG, "Unable to bind with intent: " + mIntent);
-            return false;
-        }
-
-        private void addProxy(IBluetoothProfileServiceConnection proxy) {
-            mProxies.register(proxy);
-            if (mService != null) {
-                try{
-                    proxy.onServiceConnected(mClassName, mService);
-                } catch (RemoteException e) {
-                    Log.e(TAG, "Unable to connect to proxy", e);
-                }
-            } else {
-                if (!mHandler.hasMessages(MESSAGE_BIND_PROFILE_SERVICE, this)) {
-                    Message msg = mHandler.obtainMessage(MESSAGE_BIND_PROFILE_SERVICE);
-                    msg.obj = this;
-                    mHandler.sendMessage(msg);
-                }
-            }
-        }
-
-        private void removeProxy(IBluetoothProfileServiceConnection proxy) {
-            if (proxy != null) {
-                if (mProxies.unregister(proxy)) {
-                    try {
-                        proxy.onServiceDisconnected(mClassName);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Unable to disconnect proxy", e);
-                    }
-                }
-            } else {
-                Log.w(TAG, "Trying to remove a null proxy");
-            }
-        }
-
-        private void removeAllProxies() {
-            onServiceDisconnected(mClassName);
-            mProxies.kill();
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            // remove timeout message
-            mHandler.removeMessages(MESSAGE_BIND_PROFILE_SERVICE, this);
-            mService = service;
-            mClassName = className;
-            try {
-                mService.linkToDeath(this, 0);
-            } catch (RemoteException e) {
-                Log.e(TAG, "Unable to linkToDeath", e);
-            }
-
-            if (mInvokingProxyCallbacks) {
-                Log.e(TAG, "Proxy callbacks already in progress.");
-                return;
-            }
-            mInvokingProxyCallbacks = true;
-
-            final int n = mProxies.beginBroadcast();
-            try {
-                for (int i = 0; i < n; i++) {
-                    try {
-                        mProxies.getBroadcastItem(i).onServiceConnected(className, service);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Unable to connect to proxy", e);
-                    }
-                }
-            } finally {
-                mProxies.finishBroadcast();
-                mInvokingProxyCallbacks = false;
-            }
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName className) {
-            if (mService == null) return;
-            mService.unlinkToDeath(this, 0);
-            mService = null;
-            mClassName = null;
-
-            if (mInvokingProxyCallbacks) {
-                Log.e(TAG, "Proxy callbacks already in progress.");
-                return;
-            }
-            mInvokingProxyCallbacks = true;
-
-            final int n = mProxies.beginBroadcast();
-            try {
-                for (int i = 0; i < n; i++) {
-                    try {
-                        mProxies.getBroadcastItem(i).onServiceDisconnected(className);
-                    } catch (RemoteException e) {
-                        Log.e(TAG, "Unable to disconnect from proxy", e);
-                    }
-                }
-            } finally {
-                mProxies.finishBroadcast();
-                mInvokingProxyCallbacks = false;
-            }
-        }
-
-        @Override
-        public void binderDied() {
-            if (DBG) {
-                Log.w(TAG, "Profile service for profile: " + mClassName
-                        + " died.");
-            }
-            onServiceDisconnected(mClassName);
-            // Trigger rebind
-            Message msg = mHandler.obtainMessage(MESSAGE_BIND_PROFILE_SERVICE);
-            msg.obj = this;
-            mHandler.sendMessageDelayed(msg, TIMEOUT_BIND_MS);
-        }
-    }
-
     private void sendBluetoothStateCallback(boolean isUp) {
         try {
             int n = mStateChangeCallbacks.beginBroadcast();
@@ -968,6 +755,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     }  catch (RemoteException e) {
                         Log.e(TAG, "Unable to call onBluetoothServiceUp() on callback #" + i, e);
                     }
+                    Log.d(TAG, "Broadcasted onBluetoothServiceUp() to " + mCallbacks.getBroadcastItem(i));
                 }
             } finally {
                 mCallbacks.finishBroadcast();
@@ -989,6 +777,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     }  catch (RemoteException e) {
                         Log.e(TAG, "Unable to call onBluetoothServiceDown() on callback #" + i, e);
                     }
+                    Log.d(TAG, "Broadcasted onBluetoothServiceDown() to " + mCallbacks.getBroadcastItem(i));
                 }
             } finally {
                 mCallbacks.finishBroadcast();
@@ -1258,28 +1047,6 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     }
                     break;
                 }
-                case MESSAGE_ADD_PROXY_DELAYED:
-                {
-                    ProfileServiceConnections psc = mProfileServices.get(
-                            new Integer(msg.arg1));
-                    if (psc == null) {
-                        break;
-                    }
-                    IBluetoothProfileServiceConnection proxy =
-                            (IBluetoothProfileServiceConnection) msg.obj;
-                    psc.addProxy(proxy);
-                    break;
-                }
-                case MESSAGE_BIND_PROFILE_SERVICE:
-                {
-                    ProfileServiceConnections psc = (ProfileServiceConnections) msg.obj;
-                    removeMessages(MESSAGE_BIND_PROFILE_SERVICE, msg.obj);
-                    if (psc == null) {
-                        break;
-                    }
-                    psc.bindService();
-                    break;
-                }
                 case MESSAGE_BLUETOOTH_SERVICE_CONNECTED:
                 {
                     if (DBG) Log.d(TAG,"MESSAGE_BLUETOOTH_SERVICE_CONNECTED: " + msg.arg1);
@@ -1372,8 +1139,13 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                         recoverBluetoothServiceFromError();
                     }
                     if ((prevState == BluetoothAdapter.STATE_TURNING_ON) &&
-                        (newState == BluetoothAdapter.STATE_BLE_ON) &&
-                        (mBluetooth != null) && mEnable) {
+                            (newState == BluetoothAdapter.STATE_OFF) &&
+                            (mBluetooth != null) && mEnable) {
+                        persistBluetoothSetting(BLUETOOTH_OFF);
+                    }
+                    if ((prevState == BluetoothAdapter.STATE_TURNING_ON) &&
+                            (newState == BluetoothAdapter.STATE_BLE_ON) &&
+                            (mBluetooth != null) && mEnable) {
                         recoverBluetoothServiceFromError();
                     }
                     if (newState == BluetoothAdapter.STATE_ON ||
@@ -1483,20 +1255,19 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                             mState = BluetoothAdapter.STATE_TURNING_ON;
                         }
 
-                        waitForOnOff(true, false);
+                        waitForMonitoredOnOff(true, false);
 
                         if (mState == BluetoothAdapter.STATE_TURNING_ON) {
                             bluetoothStateChangeHandler(mState, BluetoothAdapter.STATE_ON);
                         }
 
-                        unbindAllBluetoothProfileServices();
                         // disable
                         handleDisable();
                         // Pbap service need receive STATE_TURNING_OFF intent to close
                         bluetoothStateChangeHandler(BluetoothAdapter.STATE_ON,
                                                     BluetoothAdapter.STATE_TURNING_OFF);
 
-                        waitForOnOff(false, true);
+                        waitForMonitoredOnOff(false, true);
 
                         bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
                                                     BluetoothAdapter.STATE_OFF);
@@ -1666,7 +1437,11 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                         unbindAndFinish();
                         sendBleStateChanged(prevState, newState);
                         // Don't broadcast as it has already been broadcast before
-                        isStandardBroadcast = false;
+                        if(!mIntentPending) {
+                            isStandardBroadcast = false;
+                        } else {
+                            mIntentPending = false;
+                        }
                     }
 
                 } else if (!intermediate_off) {
@@ -1695,6 +1470,13 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                     // Broadcast as STATE_OFF
                     newState = BluetoothAdapter.STATE_OFF;
                     sendBrEdrDownCallback();
+                    if(!isBleAppPresent()){
+                        isStandardBroadcast = false;
+                        mIntentPending = true;
+                    } else {
+                        mIntentPending = false;
+                        isStandardBroadcast = true;
+                    }
                 }
             } else if (newState == BluetoothAdapter.STATE_ON) {
                 boolean isUp = (newState==BluetoothAdapter.STATE_ON);
@@ -1711,15 +1493,25 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
                 sendBleStateChanged(prevState, newState);
             }
 
+            if( newState == BluetoothAdapter.STATE_TURNING_ON
+               && prevState == BluetoothAdapter.STATE_BLE_ON) {
+                mEnable = true;
+            }
+
             if (isStandardBroadcast) {
                 if (prevState == BluetoothAdapter.STATE_BLE_ON) {
                     // Show prevState of BLE_ON as OFF to standard users
                     prevState = BluetoothAdapter.STATE_OFF;
                 }
+                else if (prevState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
+                    // show prevState to TURNING_OFF
+                    prevState = BluetoothAdapter.STATE_TURNING_OFF;
+                }
                 Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
                 intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
                 intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
                 intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                 mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
             }
         }
@@ -1759,6 +1551,48 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         return false;
     }
 
+    /**
+     *  if on is true, wait for state become ON
+     *  if off is true, wait for state become OFF
+     *  if both on and off are false, wait for state not ON
+     */
+    private boolean waitForMonitoredOnOff(boolean on, boolean off) {
+        int i = 0;
+        while (i < 10) {
+            synchronized(mConnection) {
+                try {
+                    if (mBluetooth == null) break;
+                    if (on) {
+                        if (mBluetooth.getState() == BluetoothAdapter.STATE_ON) return true;
+                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
+                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_BLE_TURNING_ON,
+                                                        BluetoothAdapter.STATE_BLE_ON);
+                        }
+                    } else if (off) {
+                        if (mBluetooth.getState() == BluetoothAdapter.STATE_OFF) return true;
+                        if (mBluetooth.getState() == BluetoothAdapter.STATE_BLE_ON) {
+                            bluetoothStateChangeHandler(BluetoothAdapter.STATE_TURNING_OFF,
+                                                        BluetoothAdapter.STATE_BLE_ON);
+                        }
+                    } else {
+                        if (mBluetooth.getState() != BluetoothAdapter.STATE_ON) return true;
+                    }
+                } catch (RemoteException e) {
+                    Log.e(TAG, "getState()", e);
+                    break;
+                }
+            }
+            if (on || off) {
+                SystemClock.sleep(800);
+            } else {
+                SystemClock.sleep(50);
+            }
+            i++;
+        }
+        Log.e(TAG,"waitForOnOff time out");
+        return false;
+    }
+
     private void sendDisableMsg() {
         mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_DISABLE));
     }
@@ -1811,7 +1645,11 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             if (mBluetooth != null) {
                 mBluetooth = null;
                 //Unbind
-                mContext.unbindService(mConnection);
+                try {
+                    mContext.unbindService(mConnection);
+                } catch (Exception e) {
+                    Log.e(TAG, "Unable to unbind",e);
+                }
             }
             mBluetoothGatt = null;
         }
diff --git a/services/core/java/com/android/server/audio/AudioService.java b/services/core/java/com/android/server/audio/AudioService.java
index 0f957db..1e3a77a 100644
--- a/services/core/java/com/android/server/audio/AudioService.java
+++ b/services/core/java/com/android/server/audio/AudioService.java
@@ -13,15 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.android.server.audio;
-
 import static android.Manifest.permission.REMOTE_AUDIO_PLAYBACK;
 import static android.media.AudioManager.RINGER_MODE_NORMAL;
 import static android.media.AudioManager.RINGER_MODE_SILENT;
 import static android.media.AudioManager.RINGER_MODE_VIBRATE;
 import static android.os.Process.FIRST_APPLICATION_UID;
-
 import android.Manifest;
 import android.app.ActivityManager;
 import android.app.ActivityManagerInternal;
@@ -35,6 +32,7 @@ import android.bluetooth.BluetoothClass;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothHeadset;
 import android.bluetooth.BluetoothProfile;
+import android.content.ActivityNotFoundException;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
@@ -59,6 +57,7 @@ import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.media.AudioManagerInternal;
 import android.media.AudioPort;
+import android.media.AudioRecord;
 import android.media.AudioRoutesInfo;
 import android.media.IAudioFocusDispatcher;
 import android.media.IAudioRoutesObserver;
@@ -106,14 +105,11 @@ import android.view.OrientationEventListener;
 import android.view.Surface;
 import android.view.WindowManager;
 import android.view.accessibility.AccessibilityManager;
-
 import com.android.internal.util.XmlUtils;
 import com.android.server.EventLogTags;
 import com.android.server.LocalServices;
 import com.android.server.pm.UserManagerService;
-
 import org.xmlpull.v1.XmlPullParserException;
-
 import java.io.FileDescriptor;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -124,7 +120,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.Objects;
-
 /**
  * The implementation of the volume manager service.
  * <p>
@@ -138,51 +133,56 @@ import java.util.Objects;
  * @hide
  */
 public class AudioService extends IAudioService.Stub {
-
     private static final String TAG = "AudioService";
-
     /** Debug audio mode */
     protected static final boolean DEBUG_MODE = Log.isLoggable(TAG + ".MOD", Log.DEBUG);
-
     /** Debug audio policy feature */
     protected static final boolean DEBUG_AP = Log.isLoggable(TAG + ".AP", Log.DEBUG);
-
     /** Debug volumes */
     protected static final boolean DEBUG_VOL = Log.isLoggable(TAG + ".VOL", Log.DEBUG);
-
     /** debug calls to devices APIs */
     protected static final boolean DEBUG_DEVICES = Log.isLoggable(TAG + ".DEVICES", Log.DEBUG);
-
     /** How long to delay before persisting a change in volume/ringer mode. */
     private static final int PERSIST_DELAY = 500;
-
     /** How long to delay after a volume down event before unmuting a stream */
     private static final int UNMUTE_STREAM_DELAY = 350;
-
     /**
      * Only used in the result from {@link #checkForRingerModeChange(int, int, int)}
      */
     private static final int FLAG_ADJUST_VOLUME = 1;
-
     private final Context mContext;
     private final ContentResolver mContentResolver;
     private final AppOpsManager mAppOps;
-
     // the platform type affects volume and silent mode behavior
     private final int mPlatformType;
-
+    private static final ArrayList<MediaPlayerInfo> mMediaPlayers =
+                                        new ArrayList<MediaPlayerInfo>();
+    private class MediaPlayerInfo {
+        private String mPackageName;
+        private boolean mIsfocussed;
+        public MediaPlayerInfo(String packageName, boolean isfocussed) {
+            mPackageName = packageName;
+            mIsfocussed = isfocussed;
+        }
+        public boolean isFocussed() {
+            return mIsfocussed;
+        }
+        public void setFocus(boolean focus) {
+            mIsfocussed = focus;
+        }
+        public String getPackageName() {
+            return mPackageName;
+        }
+    }
     private boolean isPlatformVoice() {
         return mPlatformType == AudioSystem.PLATFORM_VOICE;
     }
-
     private boolean isPlatformTelevision() {
         return mPlatformType == AudioSystem.PLATFORM_TELEVISION;
     }
-
     /** The controller for the volume UI. */
     private final VolumeController mVolumeController = new VolumeController();
     private final ControllerService mControllerService = new ControllerService();
-
     // sendMsg() flags
     /** If the msg is already queued, replace it with this one. */
     private static final int SENDMSG_REPLACE = 0;
@@ -190,7 +190,6 @@ public class AudioService extends IAudioService.Stub {
     private static final int SENDMSG_NOOP = 1;
     /** If the msg is already queued, queue this one and leave the old. */
     private static final int SENDMSG_QUEUE = 2;
-
     // AudioHandler messages
     private static final int MSG_SET_DEVICE_VOLUME = 0;
     private static final int MSG_PERSIST_VOLUME = 1;
@@ -225,14 +224,11 @@ public class AudioService extends IAudioService.Stub {
     private static final int MSG_SET_A2DP_SRC_CONNECTION_STATE = 101;
     private static final int MSG_SET_A2DP_SINK_CONNECTION_STATE = 102;
     // end of messages handled under wakelock
-
     private static final int BTA2DP_DOCK_TIMEOUT_MILLIS = 8000;
     // Timeout for connection to bluetooth headset service
     private static final int BT_HEADSET_CNCT_TIMEOUT_MS = 3000;
-
     // retry delay in case of failure to indicate system ready to AudioFlinger
     private static final int INDICATE_SYSTEM_READY_RETRY_DELAY_MS = 1000;
-
     /** @see AudioSystemThread */
     private AudioSystemThread mAudioSystemThread;
     /** @see AudioHandler */
@@ -240,24 +236,19 @@ public class AudioService extends IAudioService.Stub {
     /** @see VolumeStreamState */
     private VolumeStreamState[] mStreamStates;
     private SettingsObserver mSettingsObserver;
-
     private int mMode = AudioSystem.MODE_NORMAL;
     // protects mRingerMode
     private final Object mSettingsLock = new Object();
-
     private SoundPool mSoundPool;
     private final Object mSoundEffectsLock = new Object();
     private static final int NUM_SOUNDPOOL_CHANNELS = 4;
-
     /* Sound effect file names  */
     private static final String SOUND_EFFECTS_PATH = "/media/audio/ui/";
     private static final List<String> SOUND_EFFECT_FILES = new ArrayList<String>();
-
     /* Sound effect file name mapping sound effect id (AudioManager.FX_xxx) to
      * file index in SOUND_EFFECT_FILES[] (first column) and indicating if effect
      * uses soundpool (second column) */
     private final int[][] SOUND_EFFECT_FILES_MAP = new int[AudioManager.NUM_SOUND_EFFECTS][2];
-
    /** Maximum volume index values for audio streams */
     private static int[] MAX_STREAM_VOLUME = new int[] {
         5,  // STREAM_VOICE_CALL
@@ -271,7 +262,6 @@ public class AudioService extends IAudioService.Stub {
         15, // STREAM_DTMF
         15  // STREAM_TTS
     };
-
     /** Minimum volume index values for audio streams */
     private static int[] MIN_STREAM_VOLUME = new int[] {
         1,  // STREAM_VOICE_CALL
@@ -285,7 +275,6 @@ public class AudioService extends IAudioService.Stub {
         0,  // STREAM_DTMF
         0   // STREAM_TTS
     };
-
     /* mStreamVolumeAlias[] indicates for each stream if it uses the volume settings
      * of another stream: This avoids multiplying the volume settings for hidden
      * stream types that follow other stream behavior for volume settings
@@ -332,7 +321,6 @@ public class AudioService extends IAudioService.Stub {
         AudioSystem.STREAM_MUSIC            // STREAM_TTS
     };
     private int[] mStreamVolumeAlias;
-
     /**
      * Map AudioSystem.STREAM_* constants to app ops.  This should be used
      * after mapping through mStreamVolumeAlias.
@@ -349,9 +337,7 @@ public class AudioService extends IAudioService.Stub {
         AppOpsManager.OP_AUDIO_MEDIA_VOLUME,            // STREAM_DTMF
         AppOpsManager.OP_AUDIO_MEDIA_VOLUME,            // STREAM_TTS
     };
-
     private final boolean mUseFixedVolume;
-
     private final AudioSystem.ErrorCallback mAudioSystemCallback = new AudioSystem.ErrorCallback() {
         public void onError(int error) {
             switch (error) {
@@ -364,7 +350,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     };
-
     /**
      * Current ringer mode from one of {@link AudioManager#RINGER_MODE_NORMAL},
      * {@link AudioManager#RINGER_MODE_SILENT}, or
@@ -373,73 +358,55 @@ public class AudioService extends IAudioService.Stub {
     // protected by mSettingsLock
     private int mRingerMode;  // internal ringer mode, affects muting of underlying streams
     private int mRingerModeExternal = -1;  // reported ringer mode to outside clients (AudioManager)
-
     /** @see System#MODE_RINGER_STREAMS_AFFECTED */
     private int mRingerModeAffectedStreams = 0;
-
     // Streams currently muted by ringer mode
     private int mRingerModeMutedStreams;
-
     /** Streams that can be muted. Do not resolve to aliases when checking.
      * @see System#MUTE_STREAMS_AFFECTED */
     private int mMuteAffectedStreams;
-
-    /**
-     * NOTE: setVibrateSetting(), getVibrateSetting(), shouldVibrate() are deprecated.
-     * mVibrateSetting is just maintained during deprecation period but vibration policy is
-     * now only controlled by mHasVibrator and mRingerMode
-     */
     private int mVibrateSetting;
-
     // Is there a vibrator
     private final boolean mHasVibrator;
-
     // Broadcast receiver for device connections intent broadcasts
     private final BroadcastReceiver mReceiver = new AudioServiceBroadcastReceiver();
-
     // Devices currently connected
     // Use makeDeviceListKey() to make a unique key for this list.
     private class DeviceListSpec {
         int mDeviceType;
         String mDeviceName;
         String mDeviceAddress;
-
         public DeviceListSpec(int deviceType, String deviceName, String deviceAddress) {
             mDeviceType = deviceType;
             mDeviceName = deviceName;
             mDeviceAddress = deviceAddress;
         }
-
         public String toString() {
             return "[type:0x" + Integer.toHexString(mDeviceType) + " name:" + mDeviceName
                     + " address:" + mDeviceAddress + "]";
         }
     }
-
     // Generate a unique key for the mConnectedDevices List by composing the device "type"
     // and the "address" associated with a specific instance of that device type
     private String makeDeviceListKey(int device, String deviceAddress) {
         return "0x" + Integer.toHexString(device) + ":" + deviceAddress;
     }
-
     private final ArrayMap<String, DeviceListSpec> mConnectedDevices = new ArrayMap<>();
-
+    private String mA2dpConnectedDevice = ""; //Used for BT a2dp connection
+    //Add connected A2dp devices in this list
+    private ArrayList<BluetoothDevice> mConnectedBTDevicesList =
+            new ArrayList<BluetoothDevice>();
     // Forced device usage for communications
     private int mForcedUseForComm;
-
     // List of binder death handlers for setMode() client processes.
     // The last process to have called setMode() is at the top of the list.
     private final ArrayList <SetModeDeathHandler> mSetModeDeathHandlers = new ArrayList <SetModeDeathHandler>();
-
     // List of clients having issued a SCO start request
     private final ArrayList <ScoClient> mScoClients = new ArrayList <ScoClient>();
-
     // BluetoothHeadset API to control SCO connection
     private BluetoothHeadset mBluetoothHeadset;
-
     // Bluetooth headset device
     private BluetoothDevice mBluetoothHeadsetDevice;
-
     // Indicate if SCO audio connection is currently active and if the initiator is
     // audio service (internal) or bluetooth headset (external)
     private int mScoAudioState;
@@ -451,14 +418,12 @@ public class AudioService extends IAudioService.Stub {
     private static final int SCO_STATE_ACTIVE_INTERNAL = 3;
     // SCO audio deactivation request waiting for headset service to connect
     private static final int SCO_STATE_DEACTIVATE_REQ = 5;
-
     // SCO audio state is active due to an action in BT handsfree (either voice recognition or
     // in call audio)
     private static final int SCO_STATE_ACTIVE_EXTERNAL = 2;
     // Deactivation request for all SCO connections (initiated by audio mode change)
     // waiting for headset service to connect
     private static final int SCO_STATE_DEACTIVATE_EXT_REQ = 4;
-
     // Indicates the mode used for SCO audio connection. The mode is virtual call if the request
     // originated from an app targeting an API version before JB MR2 and raw audio after that.
     private int mScoAudioMode;
@@ -470,12 +435,9 @@ public class AudioService extends IAudioService.Stub {
     private static final int SCO_MODE_RAW = 1;
     // SCO audio mode is Voice Recognition (BluetoothHeadset.startVoiceRecognition())
     private static final int SCO_MODE_VR = 2;
-
     private static final int SCO_MODE_MAX = 2;
-
     // Current connection state indicated by bluetooth headset
     private int mScoConnectionState;
-
     // true if boot sequence has been completed
     private boolean mSystemReady;
     // listener for SoundPool sample load completion indication
@@ -500,57 +462,43 @@ public class AudioService extends IAudioService.Stub {
     private ForceControlStreamClient mForceControlStreamClient = null;
     // Used to play ringtones outside system_server
     private volatile IRingtonePlayer mRingtonePlayer;
-
     private int mDeviceOrientation = Configuration.ORIENTATION_UNDEFINED;
-
     // Request to override default use of A2DP for media.
     private boolean mBluetoothA2dpEnabled;
     private final Object mBluetoothA2dpEnabledLock = new Object();
-
     // Monitoring of audio routes.  Protected by mCurAudioRoutes.
     final AudioRoutesInfo mCurAudioRoutes = new AudioRoutesInfo();
     final RemoteCallbackList<IAudioRoutesObserver> mRoutesObservers
             = new RemoteCallbackList<IAudioRoutesObserver>();
-
     // Devices for which the volume is fixed and VolumePanel slider should be disabled
     int mFixedVolumeDevices = AudioSystem.DEVICE_OUT_HDMI |
             AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
-            AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET |
+
             AudioSystem.DEVICE_OUT_HDMI_ARC |
             AudioSystem.DEVICE_OUT_SPDIF |
             AudioSystem.DEVICE_OUT_AUX_LINE;
     int mFullVolumeDevices = 0;
-
     // TODO merge orientation and rotation
     private final boolean mMonitorOrientation;
     private final boolean mMonitorRotation;
-
     private boolean mDockAudioMediaEnabled = true;
-
     private int mDockState = Intent.EXTRA_DOCK_STATE_UNDOCKED;
-
     // Used when safe volume warning message display is requested by setStreamVolume(). In this
     // case, the new requested volume, stream type and device are stored in mPendingVolumeCommand
     // and used later when/if disableSafeMediaVolume() is called.
     private StreamVolumeCommand mPendingVolumeCommand;
-
     private PowerManager.WakeLock mAudioEventWakeLock;
-
     private final MediaFocusControl mMediaFocusControl;
-
     // Reference to BluetoothA2dp to query for AbsoluteVolume.
     private BluetoothA2dp mA2dp;
     // lock always taken synchronized on mConnectedDevices
     private final Object mA2dpAvrcpLock = new Object();
     // If absolute volume is supported in AVRCP device
     private boolean mAvrcpAbsVolSupported = false;
-
     private static Long mLastDeviceConnectMsgTime = new Long(0);
-
     private AudioManagerInternal.RingerModeDelegate mRingerModeDelegate;
     private VolumePolicy mVolumePolicy = VolumePolicy.DEFAULT;
     private long mLoweredFromNormalToVibrateTime;
-
     // Intent "extra" data keys.
     public static final String CONNECT_INTENT_KEY_PORT_NAME = "portName";
     public static final String CONNECT_INTENT_KEY_STATE = "state";
@@ -559,30 +507,23 @@ public class AudioService extends IAudioService.Stub {
     public static final String CONNECT_INTENT_KEY_HAS_CAPTURE = "hasCapture";
     public static final String CONNECT_INTENT_KEY_HAS_MIDI = "hasMIDI";
     public static final String CONNECT_INTENT_KEY_DEVICE_CLASS = "class";
-
     // Defines the format for the connection "address" for ALSA devices
     public static String makeAlsaAddressString(int card, int device) {
         return "card=" + card + ";device=" + device + ";";
     }
-
     ///////////////////////////////////////////////////////////////////////////
     // Construction
     ///////////////////////////////////////////////////////////////////////////
-
     /** @hide */
     public AudioService(Context context) {
         mContext = context;
         mContentResolver = context.getContentResolver();
         mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
-
         mPlatformType = AudioSystem.getPlatformType(context);
-
         PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
         mAudioEventWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "handleAudioEvent");
-
         Vibrator vibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
         mHasVibrator = vibrator == null ? false : vibrator.hasVibrator();
-
         // Initialize volume
         int maxVolume = SystemProperties.getInt("ro.config.vc_call_vol_steps",
                 MAX_STREAM_VOLUME[AudioSystem.STREAM_VOICE_CALL]);
@@ -596,16 +537,11 @@ public class AudioService extends IAudioService.Stub {
             MAX_STREAM_VOLUME[AudioSystem.STREAM_MUSIC] = maxVolume;
             AudioSystem.DEFAULT_STREAM_VOLUME[AudioSystem.STREAM_MUSIC] = (maxVolume * 3) / 4;
         }
-
         sSoundEffectVolumeDb = context.getResources().getInteger(
                 com.android.internal.R.integer.config_soundEffectVolumeDb);
-
         mForcedUseForComm = AudioSystem.FORCE_NONE;
-
         createAudioSystemThread();
-
         AudioSystem.setErrorCallback(mAudioSystemCallback);
-
         boolean cameraSoundForced = readCameraSoundForced();
         mCameraSoundForced = new Boolean(cameraSoundForced);
         sendMsg(mAudioHandler,
@@ -616,7 +552,6 @@ public class AudioService extends IAudioService.Stub {
                         AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
                 null,
                 0);
-
         mSafeMediaVolumeState = new Integer(Settings.Global.getInt(mContentResolver,
                                                         Settings.Global.AUDIO_SAFE_VOLUME_STATE,
                                                         SAFE_MEDIA_VOLUME_NOT_CONFIGURED));
@@ -624,27 +559,21 @@ public class AudioService extends IAudioService.Stub {
         // the mcc is read by onConfigureSafeVolume()
         mSafeMediaVolumeIndex = mContext.getResources().getInteger(
                 com.android.internal.R.integer.config_safe_media_volume_index) * 10;
-
         mUseFixedVolume = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_useFixedVolume);
-
         // must be called before readPersistedSettings() which needs a valid mStreamVolumeAlias[]
         // array initialized by updateStreamVolumeAlias()
         updateStreamVolumeAlias(false /*updateVolumes*/, TAG);
         readPersistedSettings();
         mSettingsObserver = new SettingsObserver();
         createStreamStates();
-
         mMediaFocusControl = new MediaFocusControl(mAudioHandler.getLooper(),
                 mContext, mVolumeController, this);
-
         readAndSetLowRamDevice();
-
         // Call setRingerModeInt() to apply correct mute
         // state on streams affected by ringer mode.
         mRingerModeMutedStreams = 0;
         setRingerModeInt(getRingerModeInternal(), false);
-
         // Register for device connection intent broadcasts.
         IntentFilter intentFilter =
                 new IntentFilter(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED);
@@ -656,8 +585,8 @@ public class AudioService extends IAudioService.Stub {
         intentFilter.addAction(Intent.ACTION_USER_BACKGROUND);
         intentFilter.addAction(Intent.ACTION_USER_FOREGROUND);
         intentFilter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);
-
         intentFilter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
+        intentFilter.addAction(Intent.ACTION_SHUTDOWN);
         // TODO merge orientation and rotation
         mMonitorOrientation = SystemProperties.getBoolean("ro.audio.monitorOrientation", false);
         if (mMonitorOrientation) {
@@ -669,22 +598,17 @@ public class AudioService extends IAudioService.Stub {
         if (mMonitorRotation) {
             RotationHelper.init(mContext, mAudioHandler);
         }
-
         context.registerReceiverAsUser(mReceiver, UserHandle.ALL, intentFilter, null, null);
-
         LocalServices.addService(AudioManagerInternal.class, new AudioServiceInternal());
     }
-
     public void systemReady() {
         sendMsg(mAudioHandler, MSG_SYSTEM_READY, SENDMSG_QUEUE,
                 0, 0, null, 0);
     }
-
     public void onSystemReady() {
         mSystemReady = true;
         sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE,
                 0, 0, null, 0);
-
         mKeyguardManager =
                 (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
         mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
@@ -696,13 +620,11 @@ public class AudioService extends IAudioService.Stub {
         newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE,
                 AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
         sendStickyBroadcastToAll(newIntent);
-
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
         if (adapter != null) {
             adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener,
                                     BluetoothProfile.A2DP);
         }
-
         mHdmiManager =
                 (HdmiControlManager) mContext.getSystemService(Context.HDMI_CONTROL_SERVICE);
         if (mHdmiManager != null) {
@@ -715,7 +637,6 @@ public class AudioService extends IAudioService.Stub {
                 mHdmiCecSink = false;
             }
         }
-
         sendMsg(mAudioHandler,
                 MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED,
                 SENDMSG_REPLACE,
@@ -723,12 +644,10 @@ public class AudioService extends IAudioService.Stub {
                 0,
                 TAG,
                 SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
-
         StreamOverride.init(mContext);
         mControllerService.init();
         onIndicateSystemReady();
     }
-
     void onIndicateSystemReady() {
         if (AudioSystem.systemReady() == AudioSystem.SUCCESS) {
             return;
@@ -741,7 +660,6 @@ public class AudioService extends IAudioService.Stub {
                 null,
                 INDICATE_SYSTEM_READY_RETRY_DELAY_MS);
     }
-
     public void onMediaServerDied() {
         if (!mSystemReady ||
                 (AudioSystem.checkAudioFlinger() != AudioSystem.AUDIO_STATUS_OK)) {
@@ -751,15 +669,12 @@ public class AudioService extends IAudioService.Stub {
             return;
         }
         Log.e(TAG, "Media server started.");
-
         // indicate to audio HAL that we start the reconfiguration phase after a media
         // server crash
         // Note that we only execute this when the media server
         // process restarts after a crash, not the first time it is started.
         AudioSystem.setParameters("restarting=true");
-
         readAndSetLowRamDevice();
-
         // Restore device connection states
         synchronized (mConnectedDevices) {
             for (int i = 0; i < mConnectedDevices.size(); i++) {
@@ -773,25 +688,20 @@ public class AudioService extends IAudioService.Stub {
         }
         // Restore call state
         AudioSystem.setPhoneState(mMode);
-
         // Restore forced usage for communcations and record
         AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION, mForcedUseForComm);
         AudioSystem.setForceUse(AudioSystem.FOR_RECORD, mForcedUseForComm);
         AudioSystem.setForceUse(AudioSystem.FOR_SYSTEM, mCameraSoundForced ?
                         AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE);
-
         // Restore stream volumes
         int numStreamTypes = AudioSystem.getNumStreamTypes();
         for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
             VolumeStreamState streamState = mStreamStates[streamType];
             AudioSystem.initStreamVolume(streamType, 0, (streamState.mIndexMax + 5) / 10);
-
             streamState.applyAllVolumes();
         }
-
         // Restore ringer mode
         setRingerModeInt(getRingerModeInternal(), false);
-
         // Reset device orientation (if monitored for this device)
         if (mMonitorOrientation) {
             setOrientationForAudioSystem();
@@ -799,13 +709,11 @@ public class AudioService extends IAudioService.Stub {
         if (mMonitorRotation) {
             RotationHelper.updateOrientation();
         }
-
         synchronized (mBluetoothA2dpEnabledLock) {
             AudioSystem.setForceUse(AudioSystem.FOR_MEDIA,
                     mBluetoothA2dpEnabled ?
                             AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
         }
-
         synchronized (mSettingsLock) {
             AudioSystem.setForceUse(AudioSystem.FOR_DOCK,
                     mDockAudioMediaEnabled ?
@@ -818,24 +726,20 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         synchronized (mAudioPolicies) {
             for (AudioPolicyProxy policy : mAudioPolicies.values()) {
                 policy.connectMixes();
             }
         }
-
         onIndicateSystemReady();
         // indicate the end of reconfiguration phase to audio HAL
         AudioSystem.setParameters("restarting=false");
     }
-
     private void createAudioSystemThread() {
         mAudioSystemThread = new AudioSystemThread();
         mAudioSystemThread.start();
         waitForAudioHandlerCreation();
     }
-
     /** Waits for the volume handler to be created by the other thread. */
     private void waitForAudioHandlerCreation() {
         synchronized(this) {
@@ -849,7 +753,103 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
+    /**
+     * @hide
+     */
+    public void addMediaPlayerAndUpdateRemoteController (String packageName) {
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "addMediaPlayerAndUpdateRemoteController: size of existing list: " +
+                    mMediaPlayers.size());
+            boolean playerToAdd = true;
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo player = rccIterator.next();
+                    if (packageName.equals(player.getPackageName())) {
+                        Log.e(TAG, "Player entry present, no need to add");
+                        playerToAdd = false;
+                        player.setFocus(true);
+                    } else {
+                        Log.e(TAG, "Player: " + player.getPackageName()+ "Lost Focus");
+                        player.setFocus(false);
+                    }
+                }
+            }
+            if (playerToAdd) {
+                Log.e(TAG, "Adding Player: " + packageName + " to available player list");
+                mMediaPlayers.add(new MediaPlayerInfo(packageName, true));
+            }
+            Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+            intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
+            intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, true);
+            intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
+            sendBroadcastToAll(intent);
+            Log.v(TAG, "updating focussed RCC change to RCD: CallingPackageName:"
+                    + packageName);
+        }
+    }
+    /**
+     * @hide
+     */
+    public void updateRemoteControllerOnExistingMediaPlayers() {
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "updateRemoteControllerOnExistingMediaPlayers: size of Player list: " +
+                                                                mMediaPlayers.size());
+            if (mMediaPlayers.size() > 0) {
+                Log.v(TAG, "Inform RemoteController regarding existing RCC entry");
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo player = rccIterator.next();
+                    Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+                    intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME,
+                                                        player.getPackageName());
+                    intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE,
+                                                        player.isFocussed());
+                    intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, true);
+                    sendBroadcastToAll(intent);
+                    Log.v(TAG, "updating RCC change: CallingPackageName:" +
+                                                        player.getPackageName());
+                }
+            } else {
+                Log.e(TAG, "No RCC entry present to update");
+            }
+        }
+    }
+    /**
+     * @hide
+     */
+    public void removeMediaPlayerAndUpdateRemoteController (String packageName) {
+        synchronized(mMediaPlayers) {
+            Log.v(TAG, "removeMediaPlayerAndUpdateRemoteController: size of existing list: " +
+                                                                    mMediaPlayers.size());
+            boolean playerToRemove = false;
+            int index = -1;
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    index++;
+                    final MediaPlayerInfo player = rccIterator.next();
+                    if (packageName.equals(player.getPackageName())) {
+                        Log.v(TAG, "Player entry present remove and update RemoteController");
+                        playerToRemove = true;
+                        break;
+                    } else {
+                        Log.v(TAG, "Player entry for " + player.getPackageName()+ " is not present");
+                    }
+                }
+            }
+            if (playerToRemove) {
+                Log.e(TAG, "Removing Player: " + packageName + " from index" + index);
+                mMediaPlayers.remove(index);
+            }
+            Intent intent = new Intent(AudioManager.RCC_CHANGED_ACTION);
+            intent.putExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME, packageName);
+            intent.putExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE, false);
+            intent.putExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE, false);
+            sendBroadcastToAll(intent);
+            Log.v(TAG, "Updated List size: " + mMediaPlayers.size());
+        }
+    }
     private void checkAllAliasStreamVolumes() {
         synchronized (VolumeStreamState.class) {
             int numStreamTypes = AudioSystem.getNumStreamTypes();
@@ -866,7 +866,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void checkAllFixedVolumeDevices()
     {
         int numStreamTypes = AudioSystem.getNumStreamTypes();
@@ -874,11 +873,9 @@ public class AudioService extends IAudioService.Stub {
             mStreamStates[streamType].checkFixedVolumeDevices();
         }
     }
-
     private void checkAllFixedVolumeDevices(int streamType) {
         mStreamStates[streamType].checkFixedVolumeDevices();
     }
-
     private void checkMuteAffectedStreams() {
         // any stream with a min level > 0 is not muteable by definition
         for (int i = 0; i < mStreamStates.length; i++) {
@@ -888,20 +885,16 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void createStreamStates() {
         int numStreamTypes = AudioSystem.getNumStreamTypes();
         VolumeStreamState[] streams = mStreamStates = new VolumeStreamState[numStreamTypes];
-
         for (int i = 0; i < numStreamTypes; i++) {
             streams[i] = new VolumeStreamState(System.VOLUME_SETTINGS[mStreamVolumeAlias[i]], i);
         }
-
         checkAllFixedVolumeDevices();
         checkAllAliasStreamVolumes();
         checkMuteAffectedStreams();
     }
-
     private void dumpStreamStates(PrintWriter pw) {
         pw.println("\nStream volumes (device: index)");
         int numStreamTypes = AudioSystem.getNumStreamTypes();
@@ -913,10 +906,8 @@ public class AudioService extends IAudioService.Stub {
         pw.print("\n- mute affected streams = 0x");
         pw.println(Integer.toHexString(mMuteAffectedStreams));
     }
-
     private void updateStreamVolumeAlias(boolean updateVolumes, String caller) {
         int dtmfStreamAlias;
-
         switch (mPlatformType) {
         case AudioSystem.PLATFORM_VOICE:
             mStreamVolumeAlias = STREAM_VOLUME_ALIAS_VOICE;
@@ -930,7 +921,6 @@ public class AudioService extends IAudioService.Stub {
             mStreamVolumeAlias = STREAM_VOLUME_ALIAS_DEFAULT;
             dtmfStreamAlias = AudioSystem.STREAM_MUSIC;
         }
-
         if (isPlatformTelevision()) {
             mRingerModeAffectedStreams = 0;
         } else {
@@ -941,7 +931,6 @@ public class AudioService extends IAudioService.Stub {
                 mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_DTMF);
             }
         }
-
         mStreamVolumeAlias[AudioSystem.STREAM_DTMF] = dtmfStreamAlias;
         if (updateVolumes) {
             mStreamStates[AudioSystem.STREAM_DTMF].setAllIndexes(mStreamStates[dtmfStreamAlias],
@@ -956,12 +945,10 @@ public class AudioService extends IAudioService.Stub {
                     mStreamStates[AudioSystem.STREAM_DTMF], 0);
         }
     }
-
     private void readDockAudioSettings(ContentResolver cr)
     {
         mDockAudioMediaEnabled = Settings.Global.getInt(
                                         cr, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED, 0) == 1;
-
         sendMsg(mAudioHandler,
                 MSG_SET_FORCE_USE,
                 SENDMSG_QUEUE,
@@ -971,10 +958,8 @@ public class AudioService extends IAudioService.Stub {
                 null,
                 0);
     }
-
     private void readPersistedSettings() {
         final ContentResolver cr = mContentResolver;
-
         int ringerModeFromSettings =
                 Settings.Global.getInt(
                         cr, Settings.Global.MODE_RINGER, AudioManager.RINGER_MODE_NORMAL);
@@ -998,7 +983,6 @@ public class AudioService extends IAudioService.Stub {
             if (mRingerModeExternal == -1) {
                 mRingerModeExternal = mRingerMode;
             }
-
             // System.VIBRATE_ON is not used any more but defaults for mVibrateSetting
             // are still needed while setVibrateSetting() and getVibrateSetting() are being
             // deprecated.
@@ -1010,15 +994,12 @@ public class AudioService extends IAudioService.Stub {
                                             AudioManager.VIBRATE_TYPE_RINGER,
                                             mHasVibrator ? AudioManager.VIBRATE_SETTING_ONLY_SILENT
                                                             : AudioManager.VIBRATE_SETTING_OFF);
-
             updateRingerModeAffectedStreams();
             readDockAudioSettings(cr);
         }
-
         mMuteAffectedStreams = System.getIntForUser(cr,
                 System.MUTE_STREAMS_AFFECTED, AudioSystem.DEFAULT_MUTE_STREAMS_AFFECTED,
                 UserHandle.USER_CURRENT);
-
         boolean masterMute = System.getIntForUser(cr, System.VOLUME_MASTER_MUTE,
                 0, UserHandle.USER_CURRENT) == 1;
         if (mUseFixedVolume) {
@@ -1027,29 +1008,22 @@ public class AudioService extends IAudioService.Stub {
         }
         AudioSystem.setMasterMute(masterMute);
         broadcastMasterMuteStatus(masterMute);
-
         boolean microphoneMute =
                 System.getIntForUser(cr, System.MICROPHONE_MUTE, 0, UserHandle.USER_CURRENT) == 1;
         AudioSystem.muteMicrophone(microphoneMute);
-
         // Each stream will read its own persisted settings
-
         // Broadcast the sticky intents
         broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, mRingerModeExternal);
         broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, mRingerMode);
-
         // Broadcast vibrate settings
         broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_RINGER);
         broadcastVibrateSetting(AudioManager.VIBRATE_TYPE_NOTIFICATION);
-
         // Load settings for the volume controller
         mVolumeController.loadSettings(cr);
     }
-
     private int rescaleIndex(int index, int srcStream, int dstStream) {
         return (index * mStreamStates[dstStream].getMaxIndex() + mStreamStates[srcStream].getMaxIndex() / 2) / mStreamStates[srcStream].getMaxIndex();
     }
-
     ///////////////////////////////////////////////////////////////////////////
     // IPC methods
     ///////////////////////////////////////////////////////////////////////////
@@ -1059,7 +1033,6 @@ public class AudioService extends IAudioService.Stub {
         adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage,
                 caller, Binder.getCallingUid());
     }
-
     private void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,
             String callingPackage, String caller, int uid) {
         if (DEBUG_VOL) Log.d(TAG, "adjustSuggestedStreamVolume() stream=" + suggestedStreamType
@@ -1073,13 +1046,11 @@ public class AudioService extends IAudioService.Stub {
         }
         ensureValidStreamType(streamType);
         final int resolvedStream = mStreamVolumeAlias[streamType];
-
         // Play sounds on STREAM_RING only.
         if ((flags & AudioManager.FLAG_PLAY_SOUND) != 0 &&
                 resolvedStream != AudioSystem.STREAM_RING) {
             flags &= ~AudioManager.FLAG_PLAY_SOUND;
         }
-
         // For notifications/ring, show the ui before making any adjustments
         // Don't suppress mute/unmute requests
         if (mVolumeController.suppressAdjustment(resolvedStream, flags, isMute)) {
@@ -1088,17 +1059,14 @@ public class AudioService extends IAudioService.Stub {
             flags &= ~AudioManager.FLAG_VIBRATE;
             if (DEBUG_VOL) Log.d(TAG, "Volume controller suppressed adjustment");
         }
-
         adjustStreamVolume(streamType, direction, flags, callingPackage, caller, uid);
     }
-
     /** @see AudioManager#adjustStreamVolume(int, int, int) */
     public void adjustStreamVolume(int streamType, int direction, int flags,
             String callingPackage) {
         adjustStreamVolume(streamType, direction, flags, callingPackage, callingPackage,
                 Binder.getCallingUid());
     }
-
     private void adjustStreamVolume(int streamType, int direction, int flags,
             String callingPackage, String caller, int uid) {
         if (mUseFixedVolume) {
@@ -1106,36 +1074,27 @@ public class AudioService extends IAudioService.Stub {
         }
         if (DEBUG_VOL) Log.d(TAG, "adjustStreamVolume() stream=" + streamType + ", dir=" + direction
                 + ", flags=" + flags + ", caller=" + caller);
-
         ensureValidDirection(direction);
         ensureValidStreamType(streamType);
-
         boolean isMuteAdjust = isMuteAdjust(direction);
-
         if (isMuteAdjust && !isStreamAffectedByMute(streamType)) {
             return;
         }
-
         // use stream type alias here so that streams with same alias have the same behavior,
         // including with regard to silent mode control (e.g the use of STREAM_RING below and in
         // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
         int streamTypeAlias = mStreamVolumeAlias[streamType];
-
         VolumeStreamState streamState = mStreamStates[streamTypeAlias];
-
         final int device = getDeviceForStream(streamTypeAlias);
-
         int aliasIndex = streamState.getIndex(device);
         boolean adjustVolume = true;
         int step;
-
         // skip a2dp absolute volume control request when the device
         // is not an a2dp device
         if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 &&
             (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
             return;
         }
-
         // If we are being called by the system (e.g. hardware keys) check for current user
         // so we handle user restrictions correctly.
         if (uid == android.os.Process.SYSTEM_UID) {
@@ -1145,17 +1104,14 @@ public class AudioService extends IAudioService.Stub {
                 != AppOpsManager.MODE_ALLOWED) {
             return;
         }
-
         // reset any pending volume command
         synchronized (mSafeMediaVolumeState) {
             mPendingVolumeCommand = null;
         }
-
         flags &= ~AudioManager.FLAG_FIXED_VOLUME;
         if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) &&
                ((device & mFixedVolumeDevices) != 0)) {
             flags |= AudioManager.FLAG_FIXED_VOLUME;
-
             // Always toggle between max safe volume and 0 for fixed volume devices where safe
             // volume is enforced, and max and 0 for the others.
             // This is simulated by stepping by the full allowed volume range
@@ -1172,7 +1128,6 @@ public class AudioService extends IAudioService.Stub {
             // convert one UI step (+/-1) into a number of internal units on the stream alias
             step = rescaleIndex(10, streamType, streamTypeAlias);
         }
-
         // If either the client forces allowing ringer modes for this adjustment,
         // or the stream type is one that is affected by ringer modes
         if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) ||
@@ -1201,12 +1156,9 @@ public class AudioService extends IAudioService.Stub {
                 && (mRingerModeMutedStreams & (1 << AudioSystem.STREAM_MUSIC)) != 0) {
             adjustVolume = false;
         }
-
         int oldIndex = mStreamStates[streamType].getIndex(device);
-
         if (adjustVolume && (direction != AudioManager.ADJUST_SAME)) {
             mAudioHandler.removeMessages(MSG_UNMUTE_STREAM);
-
             // Check if volume update should be send to AVRCP
             if (streamTypeAlias == AudioSystem.STREAM_MUSIC &&
                 (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 &&
@@ -1217,7 +1169,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
             }
-
             if (isMuteAdjust) {
                 boolean state;
                 if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {
@@ -1265,7 +1216,6 @@ public class AudioService extends IAudioService.Stub {
                         streamState,
                         0);
             }
-
             // Check if volume update should be sent to Hdmi system audio.
             int newIndex = mStreamStates[streamType].getIndex(device);
             if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
@@ -1290,23 +1240,19 @@ public class AudioService extends IAudioService.Stub {
         int index = mStreamStates[streamType].getIndex(device);
         sendVolumeUpdate(streamType, oldIndex, index, flags);
     }
-
     // Called after a delay when volume down is pressed while muted
     private void onUnmuteStream(int stream, int flags) {
         VolumeStreamState streamState = mStreamStates[stream];
         streamState.mute(false);
-
         final int device = getDeviceForStream(stream);
         final int index = mStreamStates[stream].getIndex(device);
         sendVolumeUpdate(stream, index, index, flags);
     }
-
     private void setSystemAudioVolume(int oldVolume, int newVolume, int maxVolume, int flags) {
         if (mHdmiManager == null
                 || mHdmiTvClient == null
                 || oldVolume == newVolume
                 || (flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) != 0) return;
-
         // Sets the audio volume of AVR when we are in system audio mode. The new volume info
         // is tranformed to HDMI-CEC commands and passed through CEC bus.
         synchronized (mHdmiManager) {
@@ -1321,7 +1267,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     // StreamVolumeCommand contains the information needed to defer the process of
     // setStreamVolume() in case the user has to acknowledge the safe volume warning message.
     class StreamVolumeCommand {
@@ -1329,14 +1274,12 @@ public class AudioService extends IAudioService.Stub {
         public final int mIndex;
         public final int mFlags;
         public final int mDevice;
-
         StreamVolumeCommand(int streamType, int index, int flags, int device) {
             mStreamType = streamType;
             mIndex = index;
             mFlags = flags;
             mDevice = device;
         }
-
         @Override
         public String toString() {
             return new StringBuilder().append("{streamType=").append(mStreamType).append(",index=")
@@ -1344,7 +1287,6 @@ public class AudioService extends IAudioService.Stub {
                     .append(mDevice).append('}').toString();
         }
     };
-
     private void onSetStreamVolume(int streamType, int index, int flags, int device,
             String caller) {
         final int stream = mStreamVolumeAlias[streamType];
@@ -1365,26 +1307,21 @@ public class AudioService extends IAudioService.Stub {
         // setting non-zero volume for a muted stream unmutes the stream and vice versa
         mStreamStates[stream].mute(index == 0);
     }
-
     /** @see AudioManager#setStreamVolume(int, int, int) */
     public void setStreamVolume(int streamType, int index, int flags, String callingPackage) {
         setStreamVolume(streamType, index, flags, callingPackage, callingPackage,
                 Binder.getCallingUid());
     }
-
     private void setStreamVolume(int streamType, int index, int flags, String callingPackage,
             String caller, int uid) {
         if (mUseFixedVolume) {
             return;
         }
-
         ensureValidStreamType(streamType);
         int streamTypeAlias = mStreamVolumeAlias[streamType];
         VolumeStreamState streamState = mStreamStates[streamTypeAlias];
-
         final int device = getDeviceForStream(streamType);
         int oldIndex;
-
         // skip a2dp absolute volume control request when the device
         // is not an a2dp device
         if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 &&
@@ -1400,15 +1337,11 @@ public class AudioService extends IAudioService.Stub {
                 != AppOpsManager.MODE_ALLOWED) {
             return;
         }
-
         synchronized (mSafeMediaVolumeState) {
             // reset any pending volume command
             mPendingVolumeCommand = null;
-
             oldIndex = streamState.getIndex(device);
-
             index = rescaleIndex(index * 10, streamType, streamTypeAlias);
-
             if (streamTypeAlias == AudioSystem.STREAM_MUSIC &&
                 (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 &&
                 (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
@@ -1418,16 +1351,13 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
             }
-
             if (streamTypeAlias == AudioSystem.STREAM_MUSIC) {
                 setSystemAudioVolume(oldIndex, index, getStreamMaxVolume(streamType), flags);
             }
-
             flags &= ~AudioManager.FLAG_FIXED_VOLUME;
             if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) &&
                     ((device & mFixedVolumeDevices) != 0)) {
                 flags |= AudioManager.FLAG_FIXED_VOLUME;
-
                 // volume is either 0 or max allowed for fixed volume devices
                 if (index != 0) {
                     if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE &&
@@ -1438,7 +1368,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
             }
-
             if (!checkSafeMediaVolume(streamTypeAlias, index, device)) {
                 mVolumeController.postDisplaySafeVolumeWarning(flags);
                 mPendingVolumeCommand = new StreamVolumeCommand(
@@ -1450,7 +1379,6 @@ public class AudioService extends IAudioService.Stub {
         }
         sendVolumeUpdate(streamType, oldIndex, index, flags);
     }
-
     /** @see AudioManager#forceVolumeControlStream(int) */
     public void forceVolumeControlStream(int streamType, IBinder cb) {
         synchronized(mForceControlStreamLock) {
@@ -1465,10 +1393,8 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private class ForceControlStreamClient implements IBinder.DeathRecipient {
         private IBinder mCb; // To be notified of client's death
-
         ForceControlStreamClient(IBinder cb) {
             if (cb != null) {
                 try {
@@ -1481,7 +1407,6 @@ public class AudioService extends IAudioService.Stub {
             }
             mCb = cb;
         }
-
         public void binderDied() {
             synchronized(mForceControlStreamLock) {
                 Log.w(TAG, "SCO client died");
@@ -1493,7 +1418,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public void release() {
             if (mCb != null) {
                 mCb.unlinkToDeath(this, 0);
@@ -1501,18 +1425,19 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void sendBroadcastToAll(Intent intent) {
+        sendBroadcastToAll(intent, null);
+    }
+    private void sendBroadcastToAll(Intent intent, String receiverPermission) {
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         final long ident = Binder.clearCallingIdentity();
         try {
-            mContext.sendBroadcastAsUser(intent, UserHandle.ALL);
+            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, receiverPermission);
         } finally {
             Binder.restoreCallingIdentity(ident);
         }
     }
-
     private void sendStickyBroadcastToAll(Intent intent) {
         intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         final long ident = Binder.clearCallingIdentity();
@@ -1522,7 +1447,6 @@ public class AudioService extends IAudioService.Stub {
             Binder.restoreCallingIdentity(ident);
         }
     }
-
     private int getCurrentUserId() {
         final long ident = Binder.clearCallingIdentity();
         try {
@@ -1535,17 +1459,14 @@ public class AudioService extends IAudioService.Stub {
         }
         return UserHandle.USER_OWNER;
     }
-
     // UI update and Broadcast Intent
     private void sendVolumeUpdate(int streamType, int oldIndex, int index, int flags) {
         streamType = mStreamVolumeAlias[streamType];
-
         if (streamType == AudioSystem.STREAM_MUSIC) {
             flags = updateFlagsForSystemAudio(flags);
         }
         mVolumeController.postVolumeChanged(streamType, flags);
     }
-
     // If Hdmi-CEC system audio mode is on, we show volume bar only when TV
     // receives volume notification from Audio Receiver.
     private int updateFlagsForSystemAudio(int flags) {
@@ -1559,13 +1480,11 @@ public class AudioService extends IAudioService.Stub {
         }
         return flags;
     }
-
     // UI update and Broadcast Intent
     private void sendMasterMuteUpdate(boolean muted, int flags) {
         mVolumeController.postMasterMuteChanged(updateFlagsForSystemAudio(flags));
         broadcastMasterMuteStatus(muted);
     }
-
     private void broadcastMasterMuteStatus(boolean muted) {
         Intent intent = new Intent(AudioManager.MASTER_MUTE_CHANGED_ACTION);
         intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_MUTED, muted);
@@ -1573,7 +1492,6 @@ public class AudioService extends IAudioService.Stub {
                 | Intent.FLAG_RECEIVER_REPLACE_PENDING);
         sendStickyBroadcastToAll(intent);
     }
-
     /**
      * Sets the stream state's index, and posts a message to set system volume.
      * This will not call out to the UI. Assumes a valid stream type.
@@ -1590,7 +1508,6 @@ public class AudioService extends IAudioService.Stub {
                                     boolean force,
                                     String caller) {
         VolumeStreamState streamState = mStreamStates[streamType];
-
         if (streamState.setIndex(index, device, caller) || force) {
             // Post message to set system volume (it in turn will post a message
             // to persist).
@@ -1603,7 +1520,6 @@ public class AudioService extends IAudioService.Stub {
                     0);
         }
     }
-
     private void setSystemAudioMute(boolean state) {
         if (mHdmiManager == null || mHdmiTvClient == null) return;
         synchronized (mHdmiManager) {
@@ -1618,7 +1534,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /** get stream mute state. */
     public boolean isStreamMute(int streamType) {
         if (streamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
@@ -1628,10 +1543,8 @@ public class AudioService extends IAudioService.Stub {
             return mStreamStates[streamType].mIsMuted;
         }
     }
-
     private class RmtSbmxFullVolDeathHandler implements IBinder.DeathRecipient {
         private IBinder mICallback; // To be notified of client's death
-
         RmtSbmxFullVolDeathHandler(IBinder cb) {
             mICallback = cb;
             try {
@@ -1640,11 +1553,9 @@ public class AudioService extends IAudioService.Stub {
                 Log.e(TAG, "can't link to death", e);
             }
         }
-
         boolean isHandlerFor(IBinder cb) {
             return mICallback.equals(cb);
         }
-
         void forget() {
             try {
                 mICallback.unlinkToDeath(this, 0/*flags*/);
@@ -1652,13 +1563,11 @@ public class AudioService extends IAudioService.Stub {
                 Log.e(TAG, "error unlinking to death", e);
             }
         }
-
         public void binderDied() {
             Log.w(TAG, "Recorder with remote submix at full volume died " + mICallback);
             forceRemoteSubmixFullVolume(false, mICallback);
         }
     }
-
     /**
      * call must be synchronized on mRmtSbmxFullVolDeathHandlers
      * @return true if there is a registered death handler, false otherwise */
@@ -1674,7 +1583,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return false;
     }
-
     /** call synchronized on mRmtSbmxFullVolDeathHandlers */
     private boolean hasRmtSbmxFullVolDeathHandlerFor(IBinder cb) {
         Iterator<RmtSbmxFullVolDeathHandler> it = mRmtSbmxFullVolDeathHandlers.iterator();
@@ -1685,11 +1593,9 @@ public class AudioService extends IAudioService.Stub {
         }
         return false;
     }
-
     private int mRmtSbmxFullVolRefCount = 0;
     private ArrayList<RmtSbmxFullVolDeathHandler> mRmtSbmxFullVolDeathHandlers =
             new ArrayList<RmtSbmxFullVolDeathHandler>();
-
     public void forceRemoteSubmixFullVolume(boolean startForcing, IBinder cb) {
         if (cb == null) {
             return;
@@ -1728,7 +1634,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void setMasterMuteInternal(boolean mute, int flags, String callingPackage, int uid,
             int userId) {
         // If we are being called by the system check for user we are going to change
@@ -1754,7 +1659,6 @@ public class AudioService extends IAudioService.Stub {
                 sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, mute ? 1
                         : 0, userId, null, PERSIST_DELAY);
                 sendMasterMuteUpdate(mute, flags);
-
                 Intent intent = new Intent(AudioManager.MASTER_MUTE_CHANGED_ACTION);
                 intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_MUTED, mute);
                 sendBroadcastToAll(intent);
@@ -1766,24 +1670,20 @@ public class AudioService extends IAudioService.Stub {
                     : 0, userId, null, PERSIST_DELAY);
         }
     }
-
     /** get master mute state. */
     public boolean isMasterMute() {
         return AudioSystem.getMasterMute();
     }
-
     public void setMasterMute(boolean mute, int flags, String callingPackage, int userId) {
         setMasterMuteInternal(mute, flags, callingPackage, Binder.getCallingUid(),
                 userId);
     }
-
     /** @see AudioManager#getStreamVolume(int) */
     public int getStreamVolume(int streamType) {
         ensureValidStreamType(streamType);
         int device = getDeviceForStream(streamType);
         synchronized (VolumeStreamState.class) {
             int index = mStreamStates[streamType].getIndex(device);
-
             // by convention getStreamVolume() returns 0 when a stream is muted.
             if (mStreamStates[streamType].mIsMuted) {
                 index = 0;
@@ -1795,31 +1695,26 @@ public class AudioService extends IAudioService.Stub {
             return (index + 5) / 10;
         }
     }
-
     /** @see AudioManager#getStreamMaxVolume(int) */
     public int getStreamMaxVolume(int streamType) {
         ensureValidStreamType(streamType);
         return (mStreamStates[streamType].getMaxIndex() + 5) / 10;
     }
-
     /** @see AudioManager#getStreamMinVolume(int) */
     public int getStreamMinVolume(int streamType) {
         ensureValidStreamType(streamType);
         return (mStreamStates[streamType].getMinIndex() + 5) / 10;
     }
-
     /** Get last audible volume before stream was muted. */
     public int getLastAudibleStreamVolume(int streamType) {
         ensureValidStreamType(streamType);
         int device = getDeviceForStream(streamType);
         return (mStreamStates[streamType].getIndex(device) + 5) / 10;
     }
-
     /** @see AudioManager#getUiSoundsStreamType()  */
     public int getUiSoundsStreamType() {
         return mStreamVolumeAlias[AudioSystem.STREAM_SYSTEM];
     }
-
     /** @see AudioManager#setMicrophoneMute(boolean, int) */
     public void setMicrophoneMute(boolean on, String callingPackage, int userId) {
         // If we are being called by the system check for user we are going to change
@@ -1841,7 +1736,6 @@ public class AudioService extends IAudioService.Stub {
                 != PackageManager.PERMISSION_GRANTED) {
             return;
         }
-
         // If mute is for current user actually mute, else just persist the setting
         // which will be loaded on user switch.
         if (getCurrentUserId() == userId) {
@@ -1851,41 +1745,34 @@ public class AudioService extends IAudioService.Stub {
         sendMsg(mAudioHandler, MSG_PERSIST_MICROPHONE_MUTE, SENDMSG_REPLACE, on ? 1
                 : 0, userId, null, PERSIST_DELAY);
     }
-
     @Override
     public int getRingerModeExternal() {
         synchronized(mSettingsLock) {
             return mRingerModeExternal;
         }
     }
-
     @Override
     public int getRingerModeInternal() {
         synchronized(mSettingsLock) {
             return mRingerMode;
         }
     }
-
     private void ensureValidRingerMode(int ringerMode) {
         if (!isValidRingerMode(ringerMode)) {
             throw new IllegalArgumentException("Bad ringer mode " + ringerMode);
         }
     }
-
     /** @see AudioManager#isValidRingerMode(int) */
     public boolean isValidRingerMode(int ringerMode) {
         return ringerMode >= 0 && ringerMode <= AudioManager.RINGER_MODE_MAX;
     }
-
     public void setRingerModeExternal(int ringerMode, String caller) {
         setRingerMode(ringerMode, caller, true /*external*/);
     }
-
     public void setRingerModeInternal(int ringerMode, String caller) {
         enforceVolumeController("setRingerModeInternal");
         setRingerMode(ringerMode, caller, false /*external*/);
     }
-
     private void setRingerMode(int ringerMode, String caller, boolean external) {
         if (mUseFixedVolume || isPlatformTelevision()) {
             return;
@@ -1926,7 +1813,6 @@ public class AudioService extends IAudioService.Stub {
             Binder.restoreCallingIdentity(identity);
         }
     }
-
     private void setRingerModeExt(int ringerMode) {
         synchronized(mSettingsLock) {
             if (ringerMode == mRingerModeExternal) return;
@@ -1935,7 +1821,6 @@ public class AudioService extends IAudioService.Stub {
         // Send sticky broadcast
         broadcastRingerMode(AudioManager.RINGER_MODE_CHANGED_ACTION, ringerMode);
     }
-
     private void muteRingerModeStreams() {
         // Mute stream if not previously muted by ringer mode and ringer mode
         // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
@@ -1981,16 +1866,13 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void setRingerModeInt(int ringerMode, boolean persist) {
         final boolean change;
         synchronized(mSettingsLock) {
             change = mRingerMode != ringerMode;
             mRingerMode = ringerMode;
         }
-
         muteRingerModeStreams();
-
         // Post a persist ringer mode msg
         if (persist) {
             sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE,
@@ -2001,57 +1883,42 @@ public class AudioService extends IAudioService.Stub {
             broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, ringerMode);
         }
     }
-
     /** @see AudioManager#shouldVibrate(int) */
     public boolean shouldVibrate(int vibrateType) {
         if (!mHasVibrator) return false;
-
         switch (getVibrateSetting(vibrateType)) {
-
             case AudioManager.VIBRATE_SETTING_ON:
                 return getRingerModeExternal() != AudioManager.RINGER_MODE_SILENT;
-
             case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
                 return getRingerModeExternal() == AudioManager.RINGER_MODE_VIBRATE;
-
             case AudioManager.VIBRATE_SETTING_OFF:
                 // return false, even for incoming calls
                 return false;
-
             default:
                 return false;
         }
     }
-
     /** @see AudioManager#getVibrateSetting(int) */
     public int getVibrateSetting(int vibrateType) {
         if (!mHasVibrator) return AudioManager.VIBRATE_SETTING_OFF;
         return (mVibrateSetting >> (vibrateType * 2)) & 3;
     }
-
     /** @see AudioManager#setVibrateSetting(int, int) */
     public void setVibrateSetting(int vibrateType, int vibrateSetting) {
-
         if (!mHasVibrator) return;
-
         mVibrateSetting = AudioSystem.getValueForVibrateSetting(mVibrateSetting, vibrateType,
                 vibrateSetting);
-
         // Broadcast change
         broadcastVibrateSetting(vibrateType);
-
     }
-
     private class SetModeDeathHandler implements IBinder.DeathRecipient {
         private IBinder mCb; // To be notified of client's death
         private int mPid;
         private int mMode = AudioSystem.MODE_NORMAL; // Current mode set by this client
-
         SetModeDeathHandler(IBinder cb, int pid) {
             mCb = cb;
             mPid = pid;
         }
-
         public void binderDied() {
             int newModeOwnerPid = 0;
             synchronized(mSetModeDeathHandlers) {
@@ -2071,31 +1938,25 @@ public class AudioService extends IAudioService.Stub {
                 Binder.restoreCallingIdentity(ident);
             }
         }
-
         public int getPid() {
             return mPid;
         }
-
         public void setMode(int mode) {
             mMode = mode;
         }
-
         public int getMode() {
             return mMode;
         }
-
         public IBinder getBinder() {
             return mCb;
         }
     }
-
     /** @see AudioManager#setMode(int) */
     public void setMode(int mode, IBinder cb, String callingPackage) {
         if (DEBUG_MODE) { Log.v(TAG, "setMode(mode=" + mode + ", callingPackage=" + callingPackage + ")"); }
         if (!checkAudioSettingsPermission("setMode()")) {
             return;
         }
-
         if ( (mode == AudioSystem.MODE_IN_CALL) &&
                 (mContext.checkCallingOrSelfPermission(
                         android.Manifest.permission.MODIFY_PHONE_STATE)
@@ -2104,11 +1965,9 @@ public class AudioService extends IAudioService.Stub {
                     + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
             return;
         }
-
         if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
             return;
         }
-
         int newModeOwnerPid = 0;
         synchronized(mSetModeDeathHandlers) {
             if (mode == AudioSystem.MODE_CURRENT) {
@@ -2122,7 +1981,6 @@ public class AudioService extends IAudioService.Stub {
              disconnectBluetoothSco(newModeOwnerPid);
         }
     }
-
     // must be called synchronized on mSetModeDeathHandlers
     // setModeInt() returns a valid PID if the audio mode was successfully set to
     // any mode other than NORMAL.
@@ -2134,7 +1992,6 @@ public class AudioService extends IAudioService.Stub {
             Log.e(TAG, "setModeInt() called with null binder");
             return newModeOwnerPid;
         }
-
         SetModeDeathHandler hdlr = null;
         Iterator iter = mSetModeDeathHandlers.iterator();
         while (iter.hasNext()) {
@@ -2171,13 +2028,11 @@ public class AudioService extends IAudioService.Stub {
                     // Client has died!
                     Log.w(TAG, "setMode() could not link to "+cb+" binder death");
                 }
-
                 // Last client to call setMode() is always at top of client list
                 // as required by SetModeDeathHandler.binderDied()
                 mSetModeDeathHandlers.add(0, hdlr);
                 hdlr.setMode(mode);
             }
-
             if (mode != mMode) {
                 status = AudioSystem.setPhoneState(mode);
                 if (status == AudioSystem.AUDIO_STATUS_OK) {
@@ -2196,7 +2051,6 @@ public class AudioService extends IAudioService.Stub {
                 status = AudioSystem.AUDIO_STATUS_OK;
             }
         } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
-
         if (status == AudioSystem.AUDIO_STATUS_OK) {
             if (mode != AudioSystem.MODE_NORMAL) {
                 if (mSetModeDeathHandlers.isEmpty()) {
@@ -2209,21 +2063,17 @@ public class AudioService extends IAudioService.Stub {
             int device = getDeviceForStream(streamType);
             int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
             setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true, caller);
-
             updateStreamVolumeAlias(true /*updateVolumes*/, caller);
         }
         return newModeOwnerPid;
     }
-
     /** @see AudioManager#getMode() */
     public int getMode() {
         return mMode;
     }
-
     //==========================================================================================
     // Sound Effects
     //==========================================================================================
-
     private static final String TAG_AUDIO_ASSETS = "audio_assets";
     private static final String ATTR_VERSION = "version";
     private static final String TAG_GROUP = "group";
@@ -2231,16 +2081,12 @@ public class AudioService extends IAudioService.Stub {
     private static final String TAG_ASSET = "asset";
     private static final String ATTR_ASSET_ID = "id";
     private static final String ATTR_ASSET_FILE = "file";
-
     private static final String ASSET_FILE_VERSION = "1.0";
     private static final String GROUP_TOUCH_SOUNDS = "touch_sounds";
-
     private static final int SOUND_EFFECTS_LOAD_TIMEOUT_MS = 5000;
-
     class LoadSoundEffectReply {
         public int mStatus = 1;
     };
-
     private void loadTouchSoundAssetDefaults() {
         SOUND_EFFECT_FILES.add("Effect_Tick.ogg");
         for (int i = 0; i < AudioManager.NUM_SOUND_EFFECTS; i++) {
@@ -2248,24 +2094,18 @@ public class AudioService extends IAudioService.Stub {
             SOUND_EFFECT_FILES_MAP[i][1] = -1;
         }
     }
-
     private void loadTouchSoundAssets() {
         XmlResourceParser parser = null;
-
         // only load assets once.
         if (!SOUND_EFFECT_FILES.isEmpty()) {
             return;
         }
-
         loadTouchSoundAssetDefaults();
-
         try {
             parser = mContext.getResources().getXml(com.android.internal.R.xml.audio_assets);
-
             XmlUtils.beginDocument(parser, TAG_AUDIO_ASSETS);
             String version = parser.getAttributeValue(null, ATTR_VERSION);
             boolean inTouchSoundsGroup = false;
-
             if (ASSET_FILE_VERSION.equals(version)) {
                 while (true) {
                     XmlUtils.nextElement(parser);
@@ -2291,7 +2131,6 @@ public class AudioService extends IAudioService.Stub {
                         String id = parser.getAttributeValue(null, ATTR_ASSET_ID);
                         String file = parser.getAttributeValue(null, ATTR_ASSET_FILE);
                         int fx;
-
                         try {
                             Field field = AudioManager.class.getField(id);
                             fx = field.getInt(null);
@@ -2299,7 +2138,6 @@ public class AudioService extends IAudioService.Stub {
                             Log.w(TAG, "Invalid touch sound ID: "+id);
                             continue;
                         }
-
                         int i = SOUND_EFFECT_FILES.indexOf(file);
                         if (i == -1) {
                             i = SOUND_EFFECT_FILES.size();
@@ -2323,23 +2161,19 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /** @see AudioManager#playSoundEffect(int) */
     public void playSoundEffect(int effectType) {
         playSoundEffectVolume(effectType, -1.0f);
     }
-
     /** @see AudioManager#playSoundEffect(int, float) */
     public void playSoundEffectVolume(int effectType, float volume) {
         if (effectType >= AudioManager.NUM_SOUND_EFFECTS || effectType < 0) {
             Log.w(TAG, "AudioService effectType value " + effectType + " out of range");
             return;
         }
-
         sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE,
                 effectType, (int) (volume * 1000), null, 0);
     }
-
     /**
      * Loads samples into the soundpool.
      * This method must be called at first when sound effects are enabled
@@ -2347,7 +2181,6 @@ public class AudioService extends IAudioService.Stub {
     public boolean loadSoundEffects() {
         int attempts = 3;
         LoadSoundEffectReply reply = new LoadSoundEffectReply();
-
         synchronized (reply) {
             sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
             while ((reply.mStatus == 1) && (attempts-- > 0)) {
@@ -2360,7 +2193,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return (reply.mStatus == 0);
     }
-
     /**
      *  Unloads samples from the sound pool.
      *  This method can be called to free some memory when
@@ -2369,18 +2201,14 @@ public class AudioService extends IAudioService.Stub {
     public void unloadSoundEffects() {
         sendMsg(mAudioHandler, MSG_UNLOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
     }
-
     class SoundPoolListenerThread extends Thread {
         public SoundPoolListenerThread() {
             super("SoundPoolListenerThread");
         }
-
         @Override
         public void run() {
-
             Looper.prepare();
             mSoundPoolLooper = Looper.myLooper();
-
             synchronized (mSoundEffectsLock) {
                 if (mSoundPool != null) {
                     mSoundPoolCallBack = new SoundPoolCallback();
@@ -2391,17 +2219,13 @@ public class AudioService extends IAudioService.Stub {
             Looper.loop();
         }
     }
-
     private final class SoundPoolCallback implements
             android.media.SoundPool.OnLoadCompleteListener {
-
         int mStatus = 1; // 1 means neither error nor last sample loaded yet
         List<Integer> mSamples = new ArrayList<Integer>();
-
         public int status() {
             return mStatus;
         }
-
         public void setSamples(int[] samples) {
             for (int i = 0; i < samples.length; i++) {
                 // do not wait ack for samples rejected upfront by SoundPool
@@ -2410,7 +2234,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
             synchronized (mSoundEffectsLock) {
                 int i = mSamples.indexOf(sampleId);
@@ -2424,25 +2247,20 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /** @see AudioManager#reloadAudioSettings() */
     public void reloadAudioSettings() {
         readAudioSettings(false /*userSwitch*/);
     }
-
     private void readAudioSettings(boolean userSwitch) {
         // restore ringer mode, ringer mode affected streams, mute affected streams and vibrate settings
         readPersistedSettings();
-
         // restore volume settings
         int numStreamTypes = AudioSystem.getNumStreamTypes();
         for (int streamType = 0; streamType < numStreamTypes; streamType++) {
             VolumeStreamState streamState = mStreamStates[streamType];
-
             if (userSwitch && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) {
                 continue;
             }
-
             streamState.readSettings();
             synchronized (VolumeStreamState.class) {
                 // unmute stream that was muted but is not affect by mute anymore
@@ -2452,15 +2270,12 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         // apply new ringer mode before checking volume for alias streams so that streams
         // muted by ringer mode have the correct volume
         setRingerModeInt(getRingerModeInternal(), false);
-
         checkAllFixedVolumeDevices();
         checkAllAliasStreamVolumes();
         checkMuteAffectedStreams();
-
         synchronized (mSafeMediaVolumeState) {
             mMusicActiveMs = MathUtils.constrain(Settings.Secure.getIntForUser(mContentResolver,
                     Settings.Secure.UNSAFE_VOLUME_MUSIC_ACTIVE_MS, 0, UserHandle.USER_CURRENT),
@@ -2470,13 +2285,11 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /** @see AudioManager#setSpeakerphoneOn(boolean) */
     public void setSpeakerphoneOn(boolean on){
         if (!checkAudioSettingsPermission("setSpeakerphoneOn()")) {
             return;
         }
-
         if (on) {
             if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
                     sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
@@ -2486,16 +2299,13 @@ public class AudioService extends IAudioService.Stub {
         } else if (mForcedUseForComm == AudioSystem.FORCE_SPEAKER){
             mForcedUseForComm = AudioSystem.FORCE_NONE;
         }
-
         sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                 AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
     }
-
     /** @see AudioManager#isSpeakerphoneOn() */
     public boolean isSpeakerphoneOn() {
         return (mForcedUseForComm == AudioSystem.FORCE_SPEAKER);
     }
-
     /** @see AudioManager#setBluetoothScoOn(boolean) */
     public void setBluetoothScoOn(boolean on) {
         if (!checkAudioSettingsPermission("setBluetoothScoOn()")) {
@@ -2503,25 +2313,21 @@ public class AudioService extends IAudioService.Stub {
         }
         setBluetoothScoOnInt(on);
     }
-
     public void setBluetoothScoOnInt(boolean on) {
         if (on) {
             mForcedUseForComm = AudioSystem.FORCE_BT_SCO;
         } else if (mForcedUseForComm == AudioSystem.FORCE_BT_SCO) {
             mForcedUseForComm = AudioSystem.FORCE_NONE;
         }
-
         sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                 AudioSystem.FOR_COMMUNICATION, mForcedUseForComm, null, 0);
         sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE,
                 AudioSystem.FOR_RECORD, mForcedUseForComm, null, 0);
     }
-
     /** @see AudioManager#isBluetoothScoOn() */
     public boolean isBluetoothScoOn() {
         return (mForcedUseForComm == AudioSystem.FORCE_BT_SCO);
     }
-
     /** @see AudioManager#setBluetoothA2dpOn(boolean) */
     public void setBluetoothA2dpOn(boolean on) {
         synchronized (mBluetoothA2dpEnabledLock) {
@@ -2532,14 +2338,12 @@ public class AudioService extends IAudioService.Stub {
                     null, 0);
         }
     }
-
     /** @see AudioManager#isBluetoothA2dpOn() */
     public boolean isBluetoothA2dpOn() {
         synchronized (mBluetoothA2dpEnabledLock) {
             return mBluetoothA2dpEnabled;
         }
     }
-
     /** @see AudioManager#startBluetoothSco() */
     public void startBluetoothSco(IBinder cb, int targetSdkVersion) {
         int scoAudioMode =
@@ -2547,12 +2351,10 @@ public class AudioService extends IAudioService.Stub {
                         SCO_MODE_VIRTUAL_CALL : SCO_MODE_UNDEFINED;
         startBluetoothScoInt(cb, scoAudioMode);
     }
-
     /** @see AudioManager#startBluetoothScoVirtualCall() */
     public void startBluetoothScoVirtualCall(IBinder cb) {
         startBluetoothScoInt(cb, SCO_MODE_VIRTUAL_CALL);
     }
-
     void startBluetoothScoInt(IBinder cb, int scoAudioMode){
         if (!checkAudioSettingsPermission("startBluetoothSco()") ||
                 !mSystemReady) {
@@ -2568,7 +2370,6 @@ public class AudioService extends IAudioService.Stub {
         client.incCount(scoAudioMode);
         Binder.restoreCallingIdentity(ident);
     }
-
     /** @see AudioManager#stopBluetoothSco() */
     public void stopBluetoothSco(IBinder cb){
         if (!checkAudioSettingsPermission("stopBluetoothSco()") ||
@@ -2585,19 +2386,15 @@ public class AudioService extends IAudioService.Stub {
         }
         Binder.restoreCallingIdentity(ident);
     }
-
-
     private class ScoClient implements IBinder.DeathRecipient {
         private IBinder mCb; // To be notified of client's death
         private int mCreatorPid;
         private int mStartcount; // number of SCO connections started by this client
-
         ScoClient(IBinder cb) {
             mCb = cb;
             mCreatorPid = Binder.getCallingPid();
             mStartcount = 0;
         }
-
         public void binderDied() {
             synchronized(mScoClients) {
                 Log.w(TAG, "SCO client died");
@@ -2610,7 +2407,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public void incCount(int scoAudioMode) {
             synchronized(mScoClients) {
                 requestScoState(BluetoothHeadset.STATE_AUDIO_CONNECTED, scoAudioMode);
@@ -2625,7 +2421,6 @@ public class AudioService extends IAudioService.Stub {
                 mStartcount++;
             }
         }
-
         public void decCount() {
             synchronized(mScoClients) {
                 if (mStartcount == 0) {
@@ -2643,7 +2438,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public void clearCount(boolean stopSco) {
             synchronized(mScoClients) {
                 if (mStartcount != 0) {
@@ -2659,19 +2453,15 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public int getCount() {
             return mStartcount;
         }
-
         public IBinder getBinder() {
             return mCb;
         }
-
         public int getPid() {
             return mCreatorPid;
         }
-
         public int totalCount() {
             synchronized(mScoClients) {
                 int count = 0;
@@ -2682,7 +2472,6 @@ public class AudioService extends IAudioService.Stub {
                 return count;
             }
         }
-
         private void requestScoState(int state, int scoAudioMode) {
             checkScoAudioState();
             if (totalCount() == 0) {
@@ -2724,7 +2513,6 @@ public class AudioService extends IAudioService.Stub {
                                         status = mBluetoothHeadset.startVoiceRecognition(
                                                                            mBluetoothHeadsetDevice);
                                     }
-
                                     if (status) {
                                         mScoAudioState = SCO_STATE_ACTIVE_INTERNAL;
                                     } else {
@@ -2757,7 +2545,6 @@ public class AudioService extends IAudioService.Stub {
                                         status = mBluetoothHeadset.stopVoiceRecognition(
                                                                       mBluetoothHeadsetDevice);
                             }
-
                             if (!status) {
                                 mScoAudioState = SCO_STATE_INACTIVE;
                                 broadcastScoConnectionState(
@@ -2774,7 +2561,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void checkScoAudioState() {
         if (mBluetoothHeadset != null && mBluetoothHeadsetDevice != null &&
                 mScoAudioState == SCO_STATE_INACTIVE &&
@@ -2783,7 +2569,6 @@ public class AudioService extends IAudioService.Stub {
             mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
         }
     }
-
     private ScoClient getScoClient(IBinder cb, boolean create) {
         synchronized(mScoClients) {
             ScoClient client = null;
@@ -2800,7 +2585,6 @@ public class AudioService extends IAudioService.Stub {
             return client;
         }
     }
-
     public void clearAllScoClients(int exceptPid, boolean stopSco) {
         synchronized(mScoClients) {
             ScoClient savedClient = null;
@@ -2819,7 +2603,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private boolean getBluetoothHeadset() {
         boolean result = false;
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
@@ -2835,7 +2618,6 @@ public class AudioService extends IAudioService.Stub {
                 SENDMSG_REPLACE, 0, 0, null, result ? BT_HEADSET_CNCT_TIMEOUT_MS : 0);
         return result;
     }
-
     private void disconnectBluetoothSco(int exceptPid) {
         synchronized(mScoClients) {
             checkScoAudioState();
@@ -2858,7 +2640,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void resetBluetoothSco() {
         synchronized(mScoClients) {
             clearAllScoClients(0, false);
@@ -2868,12 +2649,10 @@ public class AudioService extends IAudioService.Stub {
         AudioSystem.setParameters("A2dpSuspended=false");
         setBluetoothScoOnInt(false);
     }
-
     private void broadcastScoConnectionState(int state) {
         sendMsg(mAudioHandler, MSG_BROADCAST_BT_CONNECTION_STATE,
                 SENDMSG_QUEUE, state, 0, null, 0);
     }
-
     private void onBroadcastScoConnectionState(int state) {
         if (state != mScoConnectionState) {
             Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_UPDATED);
@@ -2884,12 +2663,10 @@ public class AudioService extends IAudioService.Stub {
             mScoConnectionState = state;
         }
     }
-
     void setBtScoDeviceConnectionState(BluetoothDevice btDevice, int state) {
         if (btDevice == null) {
             return;
         }
-
         String address = btDevice.getAddress();
         BluetoothClass btClass = btDevice.getBluetoothClass();
         int outDevice = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
@@ -2905,13 +2682,10 @@ public class AudioService extends IAudioService.Stub {
                 break;
             }
         }
-
         if (!BluetoothAdapter.checkBluetoothAddress(address)) {
             address = "";
         }
-
         boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
-
         String btDeviceName =  btDevice.getName();
         boolean success =
             handleDeviceConnection(connected, outDevice, address, btDeviceName) &&
@@ -2927,7 +2701,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private BluetoothProfile.ServiceListener mBluetoothProfileServiceListener =
         new BluetoothProfile.ServiceListener() {
         public void onServiceConnected(int profile, BluetoothProfile proxy) {
@@ -2938,9 +2711,19 @@ public class AudioService extends IAudioService.Stub {
                 synchronized (mConnectedDevices) {
                     synchronized (mA2dpAvrcpLock) {
                         mA2dp = (BluetoothA2dp) proxy;
+                        if (mConnectedBTDevicesList.size() > 0) {
+                            Log.d(TAG,"A2dp connection list not empty, purge it, size " +
+                                    mConnectedBTDevicesList.size());
+                            mConnectedBTDevicesList.clear();
+                        }
+                        //In Dual A2dp, we can have two devices connected
                         deviceList = mA2dp.getConnectedDevices();
-                        if (deviceList.size() > 0) {
-                            btDevice = deviceList.get(0);
+                        Log.d(TAG, "onServiceConnected: A2dp Service connected: " +
+                                deviceList.size());
+                        for (int i = 0; i < deviceList.size(); i++) {
+                            //Add the device in Connected list
+
+                            btDevice = deviceList.get(i);
                             int state = mA2dp.getConnectionState(btDevice);
                             int delay = checkSendBecomingNoisyIntent(
                                                 AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
@@ -2955,7 +2738,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 break;
-
             case BluetoothProfile.A2DP_SINK:
                 deviceList = proxy.getConnectedDevices();
                 if (deviceList.size() > 0) {
@@ -2971,7 +2753,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 break;
-
             case BluetoothProfile.HEADSET:
                 synchronized (mScoClients) {
                     // Discard timeout message
@@ -3027,7 +2808,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 break;
-
             default:
                 break;
             }
@@ -3038,6 +2818,10 @@ public class AudioService extends IAudioService.Stub {
             case BluetoothProfile.A2DP:
                 synchronized (mConnectedDevices) {
                     synchronized (mA2dpAvrcpLock) {
+                        Log.d(TAG,"mConnectedBTDevicesList size " + mConnectedBTDevicesList.size());
+                        if (mConnectedBTDevicesList.size() > 0) {
+                            mConnectedBTDevicesList.clear();
+                        }
                         // Disconnect ALL DEVICE_OUT_BLUETOOTH_A2DP devices
                         for (int i = 0; i < mConnectedDevices.size(); i++) {
                             DeviceListSpec deviceSpec = mConnectedDevices.valueAt(i);
@@ -3057,7 +2841,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 break;
-
             case BluetoothProfile.A2DP_SINK:
                 synchronized (mConnectedDevices) {
                     // Disconnect ALL DEVICE_IN_BLUETOOTH_A2DP devices
@@ -3075,7 +2858,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 break;
-
             case BluetoothProfile.HEADSET:
                 synchronized (mScoClients) {
                     if (mBluetoothHeadsetDevice != null) {
@@ -3085,18 +2867,15 @@ public class AudioService extends IAudioService.Stub {
                     mBluetoothHeadset = null;
                 }
                 break;
-
             default:
                 break;
             }
         }
     };
-
     private void onCheckMusicActive(String caller) {
         synchronized (mSafeMediaVolumeState) {
             if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_INACTIVE) {
                 int device = getDeviceForStream(AudioSystem.STREAM_MUSIC);
-
                 if ((device & mSafeMediaVolumeDevices) != 0) {
                     sendMsg(mAudioHandler,
                             MSG_CHECK_MUSIC_ACTIVE,
@@ -3120,11 +2899,9 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void saveMusicActiveMs() {
         mAudioHandler.obtainMessage(MSG_PERSIST_MUSIC_ACTIVE_MS, mMusicActiveMs, 0).sendToTarget();
     }
-
     private void onConfigureSafeVolume(boolean force, String caller) {
         synchronized (mSafeMediaVolumeState) {
             int mcc = mContext.getResources().getConfiguration().mcc;
@@ -3135,10 +2912,8 @@ public class AudioService extends IAudioService.Stub {
                         SystemProperties.getBoolean("audio.safemedia.force", false)
                         || mContext.getResources().getBoolean(
                                 com.android.internal.R.bool.config_safe_media_volume_enabled);
-
                 boolean safeMediaVolumeBypass =
                         SystemProperties.getBoolean("audio.safemedia.bypass", false);
-
                 // The persisted state is either "disabled" or "active": this is the state applied
                 // next time we boot and cannot be "inactive"
                 int persistedState;
@@ -3171,11 +2946,9 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     ///////////////////////////////////////////////////////////////////////////
     // Internal methods
     ///////////////////////////////////////////////////////////////////////////
-
     /**
      * Checks if the adjustment should change ringer mode instead of just
      * adjusting volume. If so, this will set the proper ringer mode and volume
@@ -3185,7 +2958,6 @@ public class AudioService extends IAudioService.Stub {
         final boolean isTv = mPlatformType == AudioSystem.PLATFORM_TELEVISION;
         int result = FLAG_ADJUST_VOLUME;
         int ringerMode = getRingerModeInternal();
-
         switch (ringerMode) {
         case RINGER_MODE_NORMAL:
             if (direction == AudioManager.ADJUST_LOWER) {
@@ -3269,30 +3041,23 @@ public class AudioService extends IAudioService.Stub {
             Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: "+ringerMode);
             break;
         }
-
         setRingerMode(ringerMode, TAG + ".checkForRingerModeChange", false /*external*/);
-
         mPrevVolDirection = direction;
-
         return result;
     }
-
     @Override
     public boolean isStreamAffectedByRingerMode(int streamType) {
         return (mRingerModeAffectedStreams & (1 << streamType)) != 0;
     }
-
     private boolean isStreamMutedByRingerMode(int streamType) {
         return (mRingerModeMutedStreams & (1 << streamType)) != 0;
     }
-
     private boolean updateRingerModeAffectedStreams() {
         int ringerModeAffectedStreams = Settings.System.getIntForUser(mContentResolver,
                 Settings.System.MODE_RINGER_STREAMS_AFFECTED,
                 ((1 << AudioSystem.STREAM_RING)|(1 << AudioSystem.STREAM_NOTIFICATION)|
                  (1 << AudioSystem.STREAM_SYSTEM)|(1 << AudioSystem.STREAM_SYSTEM_ENFORCED)),
                  UserHandle.USER_CURRENT);
-
         if (mPlatformType == AudioSystem.PLATFORM_TELEVISION) {
             ringerModeAffectedStreams = 0;
         } else if (mRingerModeDelegate != null) {
@@ -3311,7 +3076,6 @@ public class AudioService extends IAudioService.Stub {
         } else {
             ringerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_DTMF);
         }
-
         if (ringerModeAffectedStreams != mRingerModeAffectedStreams) {
             Settings.System.putIntForUser(mContentResolver,
                     Settings.System.MODE_RINGER_STREAMS_AFFECTED,
@@ -3322,12 +3086,10 @@ public class AudioService extends IAudioService.Stub {
         }
         return false;
     }
-
     @Override
     public boolean isStreamAffectedByMute(int streamType) {
         return (mMuteAffectedStreams & (1 << streamType)) != 0;
     }
-
     private void ensureValidDirection(int direction) {
         switch (direction) {
             case AudioManager.ADJUST_LOWER:
@@ -3341,31 +3103,24 @@ public class AudioService extends IAudioService.Stub {
                 throw new IllegalArgumentException("Bad direction " + direction);
         }
     }
-
     private void ensureValidStreamType(int streamType) {
         if (streamType < 0 || streamType >= mStreamStates.length) {
             throw new IllegalArgumentException("Bad stream type " + streamType);
         }
     }
-
     private boolean isMuteAdjust(int adjust) {
         return adjust == AudioManager.ADJUST_MUTE || adjust == AudioManager.ADJUST_UNMUTE
                 || adjust == AudioManager.ADJUST_TOGGLE_MUTE;
     }
-
     private boolean isInCommunication() {
         boolean IsInCall = false;
-
         TelecomManager telecomManager =
                 (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
-
         final long ident = Binder.clearCallingIdentity();
         IsInCall = telecomManager.isInCall();
         Binder.restoreCallingIdentity(ident);
-
         return (IsInCall || getMode() == AudioManager.MODE_IN_COMMUNICATION);
     }
-
     /**
      * For code clarity for getActiveStreamType(int)
      * @param delay_ms max time since last STREAM_MUSIC activity to consider
@@ -3376,7 +3131,6 @@ public class AudioService extends IAudioService.Stub {
         return AudioSystem.isStreamActive(AudioSystem.STREAM_MUSIC, delay_ms)
                 || AudioSystem.isStreamActiveRemotely(AudioSystem.STREAM_MUSIC, delay_ms);
     }
-
     private int getActiveStreamType(int suggestedStreamType) {
         switch (mPlatformType) {
         case AudioSystem.PLATFORM_VOICE:
@@ -3393,7 +3147,7 @@ public class AudioService extends IAudioService.Stub {
                 if (isAfMusicActiveRecently(StreamOverride.sDelayMs)) {
                     if (DEBUG_VOL)
                         Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
-                    return AudioSystem.STREAM_MUSIC;
+                   return AudioSystem.STREAM_MUSIC;
                     } else {
                         if (DEBUG_VOL)
                             Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
@@ -3443,7 +3197,6 @@ public class AudioService extends IAudioService.Stub {
                 + suggestedStreamType);
         return suggestedStreamType;
     }
-
     private void broadcastRingerMode(String action, int ringerMode) {
         // Send sticky broadcast
         Intent broadcast = new Intent(action);
@@ -3452,7 +3205,6 @@ public class AudioService extends IAudioService.Stub {
                 | Intent.FLAG_RECEIVER_REPLACE_PENDING);
         sendStickyBroadcastToAll(broadcast);
     }
-
     private void broadcastVibrateSetting(int vibrateType) {
         // Send broadcast
         if (ActivityManagerNative.isSystemReady()) {
@@ -3462,7 +3214,6 @@ public class AudioService extends IAudioService.Stub {
             sendBroadcastToAll(broadcast);
         }
     }
-
     // Message helper methods
     /**
      * Queue a message on the given handler's message queue, after acquiring the service wake lock.
@@ -3477,10 +3228,8 @@ public class AudioService extends IAudioService.Stub {
         Binder.restoreCallingIdentity(ident);
         sendMsg(handler, msg, SENDMSG_QUEUE, arg1, arg2, obj, delay);
     }
-
     private static void sendMsg(Handler handler, int msg,
             int existingMsgPolicy, int arg1, int arg2, Object obj, int delay) {
-
         if (existingMsgPolicy == SENDMSG_REPLACE) {
             handler.removeMessages(msg);
         } else if (existingMsgPolicy == SENDMSG_NOOP && handler.hasMessages(msg)) {
@@ -3496,7 +3245,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     boolean checkAudioSettingsPermission(String method) {
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_AUDIO_SETTINGS)
                 == PackageManager.PERMISSION_GRANTED) {
@@ -3508,7 +3256,6 @@ public class AudioService extends IAudioService.Stub {
         Log.w(TAG, msg);
         return false;
     }
-
     private int getDeviceForStream(int stream) {
         int device = getDevicesForStream(stream);
         if ((device & (device - 1)) != 0) {
@@ -3532,18 +3279,15 @@ public class AudioService extends IAudioService.Stub {
         }
         return device;
     }
-
     private int getDevicesForStream(int stream) {
         return getDevicesForStream(stream, true /*checkOthers*/);
     }
-
     private int getDevicesForStream(int stream, boolean checkOthers) {
         ensureValidStreamType(stream);
         synchronized (VolumeStreamState.class) {
             return mStreamStates[stream].observeDevicesForStream_syncVSS(checkOthers);
         }
     }
-
     private void observeDevicesForStreams(int skipStream) {
         synchronized (VolumeStreamState.class) {
             for (int stream = 0; stream < mStreamStates.length; stream++) {
@@ -3553,7 +3297,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /*
      * A class just for packaging up a set of connection parameters.
      */
@@ -3563,7 +3306,6 @@ public class AudioService extends IAudioService.Stub {
         public final String mAddress;
         public final String mName;
         public final String mCaller;
-
         public WiredDeviceConnectionState(int type, int state, String address, String name,
                 String caller) {
             mType = type;
@@ -3573,7 +3315,6 @@ public class AudioService extends IAudioService.Stub {
             mCaller = caller;
         }
     }
-
     public void setWiredDeviceConnectionState(int type, int state, String address, String name,
             String caller) {
         synchronized (mConnectedDevices) {
@@ -3590,13 +3331,43 @@ public class AudioService extends IAudioService.Stub {
                     delay);
         }
     }
-
     public int setBluetoothA2dpDeviceConnectionState(BluetoothDevice device, int state, int profile)
     {
-        int delay;
+        int delay = 0;
         if (profile != BluetoothProfile.A2DP && profile != BluetoothProfile.A2DP_SINK) {
             throw new IllegalArgumentException("invalid profile " + profile);
         }
+        /*check the state of the currnt device*/
+        if (state == BluetoothA2dp.STATE_CONNECTING) {
+            Log.d(TAG, "Device is still connecting ");
+            return delay;
+        }
+        if ((mConnectedBTDevicesList.contains(device) &&
+            (state == BluetoothA2dp.STATE_CONNECTED))) {
+            Log.d(TAG, "Device conn is updated again, ignore ");
+            return delay;
+        }
+        if (!mConnectedBTDevicesList.contains(device) &&
+            (state == BluetoothA2dp.STATE_CONNECTED)) {
+            /*add the device in the list*/
+            Log.d(TAG, "Add new connected device in the list: " + device);
+            mConnectedBTDevicesList.add(device);
+            if (mConnectedBTDevicesList.size() > 1) {
+                Log.d(TAG, "Second device connected, add new device ");
+                return delay;
+            }
+        } else if ((state == BluetoothA2dp.STATE_DISCONNECTED) ||
+            (state == BluetoothA2dp.STATE_DISCONNECTING)) {
+            Log.d(TAG, "Device is getting disconnected: " + device);
+            if (mConnectedBTDevicesList.contains(device)) {
+                Log.d(TAG, "Remove the BT device ");
+                mConnectedBTDevicesList.remove(device);
+            }
+            if (mConnectedBTDevicesList.size() > 0) {
+                Log.d(TAG, "Not all are disconnected ");
+                return delay;
+            }
+        }
         synchronized (mConnectedDevices) {
             if (profile == BluetoothProfile.A2DP) {
                 delay = checkSendBecomingNoisyIntent(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
@@ -3614,11 +3385,9 @@ public class AudioService extends IAudioService.Stub {
         }
         return delay;
     }
-
     ///////////////////////////////////////////////////////////////////////////
     // Inner classes
     ///////////////////////////////////////////////////////////////////////////
-
     // NOTE: Locking order for synchronized objects related to volume or ringer mode management:
     //  1 mScoclient OR mSafeMediaVolumeState
     //  2   mSetModeDeathHandlers
@@ -3629,31 +3398,24 @@ public class AudioService extends IAudioService.Stub {
         private final int mStreamType;
         private final int mIndexMin;
         private final int mIndexMax;
-
         private boolean mIsMuted;
         private String mVolumeIndexSettingName;
         private int mObservedDevices;
-
         private final SparseIntArray mIndexMap = new SparseIntArray(8);
         private final Intent mVolumeChanged;
         private final Intent mStreamDevicesChanged;
-
         private VolumeStreamState(String settingName, int streamType) {
-
             mVolumeIndexSettingName = settingName;
-
             mStreamType = streamType;
             mIndexMin = MIN_STREAM_VOLUME[streamType] * 10;
             mIndexMax = MAX_STREAM_VOLUME[streamType] * 10;
             AudioSystem.initStreamVolume(streamType, mIndexMin / 10, mIndexMax / 10);
-
             readSettings();
             mVolumeChanged = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
             mVolumeChanged.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, mStreamType);
             mStreamDevicesChanged = new Intent(AudioManager.STREAM_DEVICES_CHANGED_ACTION);
             mStreamDevicesChanged.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, mStreamType);
         }
-
         public int observeDevicesForStream_syncVSS(boolean checkOthers) {
             final int devices = AudioSystem.getDevicesForStream(mStreamType);
             if (devices == mObservedDevices) {
@@ -3674,7 +3436,6 @@ public class AudioService extends IAudioService.Stub {
                     .putExtra(AudioManager.EXTRA_VOLUME_STREAM_DEVICES, devices));
             return devices;
         }
-
         public String getSettingNameForDevice(int device) {
             String name = mVolumeIndexSettingName;
             String suffix = AudioSystem.getOutputDeviceName(device);
@@ -3683,7 +3444,6 @@ public class AudioService extends IAudioService.Stub {
             }
             return name + "_" + suffix;
         }
-
         public void readSettings() {
             synchronized (VolumeStreamState.class) {
                 // force maximum volume on all streams if fixed volume property is set
@@ -3705,16 +3465,13 @@ public class AudioService extends IAudioService.Stub {
                     mIndexMap.put(AudioSystem.DEVICE_OUT_DEFAULT, index);
                     return;
                 }
-
                 int remainingDevices = AudioSystem.DEVICE_OUT_ALL;
-
                 for (int i = 0; remainingDevices != 0; i++) {
                     int device = (1 << i);
                     if ((device & remainingDevices) == 0) {
                         continue;
                     }
                     remainingDevices &= ~device;
-
                     // retrieve current volume for device
                     String name = getSettingNameForDevice(device);
                     // if no volume stored for current stream and device, use default volume if default
@@ -3726,12 +3483,10 @@ public class AudioService extends IAudioService.Stub {
                     if (index == -1) {
                         continue;
                     }
-
                     mIndexMap.put(device, getValidIndex(10 * index));
                 }
             }
         }
-
         // must be called while synchronized VolumeStreamState.class
         public void applyDeviceVolume_syncVSS(int device) {
             int index;
@@ -3766,7 +3521,6 @@ public class AudioService extends IAudioService.Stub {
             }
             AudioSystem.setStreamVolumeIndex(mStreamType, index, device);
         }
-
         public void applyAllVolumes() {
             synchronized (VolumeStreamState.class) {
                 // apply default volume first: by convention this will reset all
@@ -3797,11 +3551,9 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public boolean adjustIndex(int deltaIndex, int device, String caller) {
             return setIndex(getIndex(device) + deltaIndex, device, caller);
         }
-
         public boolean setIndex(int index, int device, String caller) {
             boolean changed = false;
             int oldIndex;
@@ -3814,7 +3566,6 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
                 mIndexMap.put(device, index);
-
                 changed = oldIndex != index;
                 if (changed) {
                     // Apply change to all streams using this one as alias
@@ -3855,7 +3606,6 @@ public class AudioService extends IAudioService.Stub {
             }
             return changed;
         }
-
         public int getIndex(int device) {
             synchronized (VolumeStreamState.class) {
                 int index = mIndexMap.get(device, -1);
@@ -3866,15 +3616,12 @@ public class AudioService extends IAudioService.Stub {
                 return index;
             }
         }
-
         public int getMaxIndex() {
             return mIndexMax;
         }
-
         public int getMinIndex() {
             return mIndexMin;
         }
-
         public void setAllIndexes(VolumeStreamState srcStream, String caller) {
             synchronized (VolumeStreamState.class) {
                 int srcStreamType = srcStream.getStreamType();
@@ -3891,12 +3638,10 @@ public class AudioService extends IAudioService.Stub {
                     int device = srcMap.keyAt(i);
                     index = srcMap.valueAt(i);
                     index = rescaleIndex(index, srcStreamType, mStreamType);
-
                     setIndex(index, device, caller);
                 }
             }
         }
-
         public void setAllIndexesToMax() {
             synchronized (VolumeStreamState.class) {
                 for (int i = 0; i < mIndexMap.size(); i++) {
@@ -3904,14 +3649,12 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         public void mute(boolean state) {
             boolean changed = false;
             synchronized (VolumeStreamState.class) {
                 if (state != mIsMuted) {
                     changed = true;
                     mIsMuted = state;
-
                     // Set the new mute volume. This propagates the values to
                     // the audio system, otherwise the volume won't be changed
                     // at the lower level.
@@ -3931,11 +3674,9 @@ public class AudioService extends IAudioService.Stub {
                 sendBroadcastToAll(intent);
             }
         }
-
         public int getStreamType() {
             return mStreamType;
         }
-
         public void checkFixedVolumeDevices() {
             synchronized (VolumeStreamState.class) {
                 // ignore settings for fixed volume devices: volume should always be at max or 0
@@ -3952,17 +3693,14 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         private int getValidIndex(int index) {
             if (index < mIndexMin) {
                 return mIndexMin;
             } else if (mUseFixedVolume || index > mIndexMax) {
                 return mIndexMax;
             }
-
             return index;
         }
-
         private void dump(PrintWriter pw) {
             pw.print("   Muted: ");
             pw.println(mIsMuted);
@@ -4005,39 +3743,30 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /** Thread that handles native AudioSystem control. */
     private class AudioSystemThread extends Thread {
         AudioSystemThread() {
             super("AudioService");
         }
-
         @Override
         public void run() {
             // Set this thread up so the handler will work on it
             Looper.prepare();
-
             synchronized(AudioService.this) {
                 mAudioHandler = new AudioHandler();
-
                 // Notify that the handler has been created
                 AudioService.this.notify();
             }
-
             // Listen for volume change requests that are set by VolumePanel
             Looper.loop();
         }
     }
-
     /** Handles internal volume messages in separate volume thread. */
     private class AudioHandler extends Handler {
-
         private void setDeviceVolume(VolumeStreamState streamState, int device) {
-
             synchronized (VolumeStreamState.class) {
                 // Apply volume
                 streamState.applyDeviceVolume_syncVSS(device);
-
                 // Apply change to all streams using this one as alias
                 int numStreamTypes = AudioSystem.getNumStreamTypes();
                 for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
@@ -4062,14 +3791,10 @@ public class AudioService extends IAudioService.Stub {
                     0,
                     streamState,
                     PERSIST_DELAY);
-
         }
-
         private void setAllVolumes(VolumeStreamState streamState) {
-
             // Apply volume
             streamState.applyAllVolumes();
-
             // Apply change to all streams using this one as alias
             int numStreamTypes = AudioSystem.getNumStreamTypes();
             for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
@@ -4079,7 +3804,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         private void persistVolume(VolumeStreamState streamState, int device) {
             if (mUseFixedVolume) {
                 return;
@@ -4092,29 +3816,23 @@ public class AudioService extends IAudioService.Stub {
                       (streamState.getIndex(device) + 5)/ 10,
                       UserHandle.USER_CURRENT);
         }
-
         private void persistRingerMode(int ringerMode) {
             if (mUseFixedVolume) {
                 return;
             }
             Settings.Global.putInt(mContentResolver, Settings.Global.MODE_RINGER, ringerMode);
         }
-
         private boolean onLoadSoundEffects() {
             int status;
-
             synchronized (mSoundEffectsLock) {
                 if (!mSystemReady) {
                     Log.w(TAG, "onLoadSoundEffects() called before boot complete");
                     return false;
                 }
-
                 if (mSoundPool != null) {
                     return true;
                 }
-
                 loadTouchSoundAssets();
-
                 mSoundPool = new SoundPool.Builder()
                         .setMaxStreams(NUM_SOUNDPOOL_CHANNELS)
                         .setAudioAttributes(new AudioAttributes.Builder()
@@ -4134,7 +3852,6 @@ public class AudioService extends IAudioService.Stub {
                         Log.w(TAG, "Interrupted while waiting sound pool listener thread.");
                     }
                 }
-
                 if (mSoundPoolCallBack == null) {
                     Log.w(TAG, "onLoadSoundEffects() SoundPool listener or thread creation error");
                     if (mSoundPoolLooper != null) {
@@ -4161,7 +3878,6 @@ public class AudioService extends IAudioService.Stub {
                  * If load succeeds, value in SOUND_EFFECT_FILES_MAP[effect][1] is > 0:
                  * this indicates we have a valid sample loaded for this effect.
                  */
-
                 int numSamples = 0;
                 for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
                     // Do not load sample if this effect uses the MediaPlayer
@@ -4188,7 +3904,6 @@ public class AudioService extends IAudioService.Stub {
                 // wait for all samples to be loaded
                 if (numSamples > 0) {
                     mSoundPoolCallBack.setSamples(poolId);
-
                     attempts = 3;
                     status = 1;
                     while ((status == 1) && (attempts-- > 0)) {
@@ -4202,7 +3917,6 @@ public class AudioService extends IAudioService.Stub {
                 } else {
                     status = -1;
                 }
-
                 if (mSoundPoolLooper != null) {
                     mSoundPoolLooper.quit();
                     mSoundPoolLooper = null;
@@ -4216,14 +3930,12 @@ public class AudioService extends IAudioService.Stub {
                             SOUND_EFFECT_FILES_MAP[effect][1] = -1;
                         }
                     }
-
                     mSoundPool.release();
                     mSoundPool = null;
                 }
             }
             return (status == 0);
         }
-
         /**
          *  Unloads samples from the sound pool.
          *  This method can be called to free some memory when
@@ -4234,12 +3946,10 @@ public class AudioService extends IAudioService.Stub {
                 if (mSoundPool == null) {
                     return;
                 }
-
                 int[] poolId = new int[SOUND_EFFECT_FILES.size()];
                 for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.size(); fileIdx++) {
                     poolId[fileIdx] = 0;
                 }
-
                 for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
                     if (SOUND_EFFECT_FILES_MAP[effect][1] <= 0) {
                         continue;
@@ -4254,12 +3964,9 @@ public class AudioService extends IAudioService.Stub {
                 mSoundPool = null;
             }
         }
-
         private void onPlaySoundEffect(int effectType, int volume) {
             synchronized (mSoundEffectsLock) {
-
                 onLoadSoundEffects();
-
                 if (mSoundPool == null) {
                     return;
                 }
@@ -4270,7 +3977,6 @@ public class AudioService extends IAudioService.Stub {
                 } else {
                     volFloat = volume / 1000.0f;
                 }
-
                 if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
                     mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1],
                                         volFloat, volFloat, 0, 0, 1.0f);
@@ -4305,7 +4011,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         private void cleanupPlayer(MediaPlayer mp) {
             if (mp != null) {
                 try {
@@ -4316,35 +4021,28 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         private void setForceUse(int usage, int config) {
             synchronized (mConnectedDevices) {
                 setForceUseInt_SyncDevices(usage, config);
             }
         }
-
         private void onPersistSafeVolumeState(int state) {
             Settings.Global.putInt(mContentResolver,
                     Settings.Global.AUDIO_SAFE_VOLUME_STATE,
                     state);
         }
-
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
-
                 case MSG_SET_DEVICE_VOLUME:
                     setDeviceVolume((VolumeStreamState) msg.obj, msg.arg1);
                     break;
-
                 case MSG_SET_ALL_VOLUMES:
                     setAllVolumes((VolumeStreamState) msg.obj);
                     break;
-
                 case MSG_PERSIST_VOLUME:
                     persistVolume((VolumeStreamState) msg.obj, msg.arg1);
                     break;
-
                 case MSG_PERSIST_MASTER_VOLUME_MUTE:
                     if (mUseFixedVolume) {
                         return;
@@ -4354,21 +4052,17 @@ public class AudioService extends IAudioService.Stub {
                                                  msg.arg1,
                                                  msg.arg2);
                     break;
-
                 case MSG_PERSIST_RINGER_MODE:
                     // note that the value persisted is the current ringer mode, not the
                     // value of ringer mode as of the time the request was made to persist
                     persistRingerMode(getRingerModeInternal());
                     break;
-
                 case MSG_MEDIA_SERVER_DIED:
                     onMediaServerDied();
                     break;
-
                 case MSG_UNLOAD_SOUND_EFFECTS:
                     onUnloadSoundEffects();
                     break;
-
                 case MSG_LOAD_SOUND_EFFECTS:
                     //FIXME: onLoadSoundEffects() should be executed in a separate thread as it
                     // can take several dozens of milliseconds to complete
@@ -4381,27 +4075,26 @@ public class AudioService extends IAudioService.Stub {
                         }
                     }
                     break;
-
                 case MSG_PLAY_SOUND_EFFECT:
-                    onPlaySoundEffect(msg.arg1, msg.arg2);
+                    if (isStreamMute(AudioSystem.STREAM_SYSTEM)) {
+                        Log.d(TAG, "Stream muted, skip playback");
+                    } else {
+                       onPlaySoundEffect(msg.arg1, msg.arg2);
+                    }
                     break;
-
                 case MSG_BTA2DP_DOCK_TIMEOUT:
                     // msg.obj  == address of BTA2DP device
                     synchronized (mConnectedDevices) {
                         makeA2dpDeviceUnavailableNow( (String) msg.obj );
                     }
                     break;
-
                 case MSG_SET_FORCE_USE:
                 case MSG_SET_FORCE_BT_A2DP_USE:
                     setForceUse(msg.arg1, msg.arg2);
                     break;
-
                 case MSG_BT_HEADSET_CNCT_FAILED:
                     resetBluetoothSco();
                     break;
-
                 case MSG_SET_WIRED_DEVICE_CONNECTION_STATE:
                     {   WiredDeviceConnectionState connectState =
                             (WiredDeviceConnectionState)msg.obj;
@@ -4410,17 +4103,14 @@ public class AudioService extends IAudioService.Stub {
                         mAudioEventWakeLock.release();
                     }
                     break;
-
                 case MSG_SET_A2DP_SRC_CONNECTION_STATE:
                     onSetA2dpSourceConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                     mAudioEventWakeLock.release();
                     break;
-
                 case MSG_SET_A2DP_SINK_CONNECTION_STATE:
                     onSetA2dpSinkConnectionState((BluetoothDevice)msg.obj, msg.arg1);
                     mAudioEventWakeLock.release();
                     break;
-
                 case MSG_REPORT_NEW_ROUTES: {
                     int N = mRoutesObservers.beginBroadcast();
                     if (N > 0) {
@@ -4441,15 +4131,12 @@ public class AudioService extends IAudioService.Stub {
                     observeDevicesForStreams(-1);
                     break;
                 }
-
                 case MSG_CHECK_MUSIC_ACTIVE:
                     onCheckMusicActive((String) msg.obj);
                     break;
-
                 case MSG_BROADCAST_AUDIO_BECOMING_NOISY:
                     onSendBecomingNoisyIntent();
                     break;
-
                 case MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED:
                 case MSG_CONFIGURE_SAFE_MEDIA_VOLUME:
                     onConfigureSafeVolume((msg.what == MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED),
@@ -4458,19 +4145,15 @@ public class AudioService extends IAudioService.Stub {
                 case MSG_PERSIST_SAFE_VOLUME_STATE:
                     onPersistSafeVolumeState(msg.arg1);
                     break;
-
                 case MSG_BROADCAST_BT_CONNECTION_STATE:
                     onBroadcastScoConnectionState(msg.arg1);
                     break;
-
                 case MSG_SYSTEM_READY:
                     onSystemReady();
                     break;
-
                 case MSG_INDICATE_SYSTEM_READY:
                     onIndicateSystemReady();
                     break;
-
                 case MSG_PERSIST_MUSIC_ACTIVE_MS:
                     final int musicActiveMs = msg.arg1;
                     Settings.Secure.putIntForUser(mContentResolver,
@@ -4492,9 +4175,7 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private class SettingsObserver extends ContentObserver {
-
         SettingsObserver() {
             super(new Handler());
             mContentResolver.registerContentObserver(Settings.System.getUriFor(
@@ -4502,7 +4183,6 @@ public class AudioService extends IAudioService.Stub {
             mContentResolver.registerContentObserver(Settings.Global.getUriFor(
                 Settings.Global.DOCK_AUDIO_MEDIA_ENABLED), false, this);
         }
-
         @Override
         public void onChange(boolean selfChange) {
             super.onChange(selfChange);
@@ -4522,7 +4202,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     // must be called synchronized on mConnectedDevices
     private void makeA2dpDeviceAvailable(String address, String name) {
         // enable A2DP before notifying A2DP connection to avoid unecessary processing in
@@ -4540,11 +4219,9 @@ public class AudioService extends IAudioService.Stub {
                 new DeviceListSpec(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, name,
                                    address));
     }
-
     private void onSendBecomingNoisyIntent() {
         sendBroadcastToAll(new Intent(AudioManager.ACTION_AUDIO_BECOMING_NOISY));
     }
-
     // must be called synchronized on mConnectedDevices
     private void makeA2dpDeviceUnavailableNow(String address) {
         synchronized (mA2dpAvrcpLock) {
@@ -4563,7 +4240,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     // must be called synchronized on mConnectedDevices
     private void makeA2dpDeviceUnavailableLater(String address, int delayMs) {
         // prevent any activity on the A2DP audio output to avoid unwanted
@@ -4575,9 +4251,7 @@ public class AudioService extends IAudioService.Stub {
         // send the delayed message to make the device unavailable later
         Message msg = mAudioHandler.obtainMessage(MSG_BTA2DP_DOCK_TIMEOUT, address);
         mAudioHandler.sendMessageDelayed(msg, delayMs);
-
     }
-
     // must be called synchronized on mConnectedDevices
     private void makeA2dpSrcAvailable(String address) {
         AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_BLUETOOTH_A2DP,
@@ -4587,7 +4261,6 @@ public class AudioService extends IAudioService.Stub {
                 new DeviceListSpec(AudioSystem.DEVICE_IN_BLUETOOTH_A2DP, "",
                                    address));
     }
-
     // must be called synchronized on mConnectedDevices
     private void makeA2dpSrcUnavailable(String address) {
         AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_IN_BLUETOOTH_A2DP,
@@ -4595,17 +4268,14 @@ public class AudioService extends IAudioService.Stub {
         mConnectedDevices.remove(
                 makeDeviceListKey(AudioSystem.DEVICE_IN_BLUETOOTH_A2DP, address));
     }
-
     // must be called synchronized on mConnectedDevices
     private void cancelA2dpDeviceTimeout() {
         mAudioHandler.removeMessages(MSG_BTA2DP_DOCK_TIMEOUT);
     }
-
     // must be called synchronized on mConnectedDevices
     private boolean hasScheduledA2dpDockTimeout() {
         return mAudioHandler.hasMessages(MSG_BTA2DP_DOCK_TIMEOUT);
     }
-
     private void onSetA2dpSinkConnectionState(BluetoothDevice btDevice, int state)
     {
         if (DEBUG_VOL) {
@@ -4618,24 +4288,23 @@ public class AudioService extends IAudioService.Stub {
         if (!BluetoothAdapter.checkBluetoothAddress(address)) {
             address = "";
         }
-
         synchronized (mConnectedDevices) {
             String key = makeDeviceListKey(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP,
                                            btDevice.getAddress());
             DeviceListSpec deviceSpec = mConnectedDevices.get(key);
             boolean isConnected = deviceSpec != null;
-
             if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
                 if (btDevice.isBluetoothDock()) {
                     if (state == BluetoothProfile.STATE_DISCONNECTED) {
                         // introduction of a delay for transient disconnections of docks when
                         // power is rapidly turned off/on, this message will be canceled if
                         // we reconnect the dock under a preset delay
-                        makeA2dpDeviceUnavailableLater(address, BTA2DP_DOCK_TIMEOUT_MILLIS);
+                        makeA2dpDeviceUnavailableLater(btDevice.getAddress(), BTA2DP_DOCK_TIMEOUT_MILLIS);
                         // the next time isConnected is evaluated, it will be false for the dock
                     }
                 } else {
-                    makeA2dpDeviceUnavailableNow(address);
+                    Log.d(TAG, "All devices are disconneted, update Policymanager ");
+                    makeA2dpDeviceUnavailableNow(btDevice.getAddress());
                 }
                 synchronized (mCurAudioRoutes) {
                     if (mCurAudioRoutes.bluetoothName != null) {
@@ -4645,21 +4314,26 @@ public class AudioService extends IAudioService.Stub {
                     }
                 }
             } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
+                //This function is not implemented
+                mA2dpConnectedDevice = "BluetoothA2dp"; // Add this String
                 if (btDevice.isBluetoothDock()) {
                     // this could be a reconnection after a transient disconnection
                     cancelA2dpDeviceTimeout();
-                    mDockAddress = address;
+                    mDockAddress =  mA2dpConnectedDevice;
+
                 } else {
                     // this could be a connection of another A2DP device before the timeout of
                     // a dock: cancel the dock timeout, and make the dock unavailable now
                     if(hasScheduledA2dpDockTimeout()) {
                         cancelA2dpDeviceTimeout();
-                        makeA2dpDeviceUnavailableNow(mDockAddress);
+                        makeA2dpDeviceUnavailableNow(btDevice.getAddress());
                     }
                 }
-                makeA2dpDeviceAvailable(address, btDevice.getName());
+                makeA2dpDeviceAvailable(btDevice.getAddress(), btDevice.getName());
+                //Updated the Router for a2dp device
                 synchronized (mCurAudioRoutes) {
-                    String name = btDevice.getAliasName();
+                    String name = mA2dpConnectedDevice;
+
                     if (!TextUtils.equals(mCurAudioRoutes.bluetoothName, name)) {
                         mCurAudioRoutes.bluetoothName = name;
                         sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES,
@@ -4669,25 +4343,23 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void onSetA2dpSourceConnectionState(BluetoothDevice btDevice, int state)
     {
         if (DEBUG_VOL) {
             Log.d(TAG, "onSetA2dpSourceConnectionState btDevice="+btDevice+" state="+state);
         }
         if (btDevice == null) {
+            Log.d(TAG, "onSetA2dpSourceConnectionState device is null"); //gasati
             return;
         }
         String address = btDevice.getAddress();
         if (!BluetoothAdapter.checkBluetoothAddress(address)) {
             address = "";
         }
-
         synchronized (mConnectedDevices) {
             String key = makeDeviceListKey(AudioSystem.DEVICE_IN_BLUETOOTH_A2DP, address);
             DeviceListSpec deviceSpec = mConnectedDevices.get(key);
             boolean isConnected = deviceSpec != null;
-
             if (isConnected && state != BluetoothProfile.STATE_CONNECTED) {
                 makeA2dpSrcUnavailable(address);
             } else if (!isConnected && state == BluetoothProfile.STATE_CONNECTED) {
@@ -4695,7 +4367,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     public void avrcpSupportsAbsoluteVolume(String address, boolean support) {
         // address is not used for now, but may be used when multiple a2dp devices are supported
         synchronized (mA2dpAvrcpLock) {
@@ -4708,7 +4379,6 @@ public class AudioService extends IAudioService.Stub {
                     mStreamStates[AudioSystem.STREAM_RING], 0);
         }
     }
-
     private boolean handleDeviceConnection(boolean connect, int device, String address,
             String deviceName) {
         if (DEBUG_DEVICES) {
@@ -4745,7 +4415,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return false;
     }
-
     // Devices which removal triggers intent ACTION_AUDIO_BECOMING_NOISY. The intent is only
     // sent if none of these devices is connected.
     // Access synchronized on mConnectedDevices
@@ -4754,13 +4423,17 @@ public class AudioService extends IAudioService.Stub {
             AudioSystem.DEVICE_OUT_ALL_A2DP | AudioSystem.DEVICE_OUT_HDMI |
             AudioSystem.DEVICE_OUT_ANLG_DOCK_HEADSET | AudioSystem.DEVICE_OUT_DGTL_DOCK_HEADSET |
             AudioSystem.DEVICE_OUT_ALL_USB | AudioSystem.DEVICE_OUT_LINE;
-
     // must be called before removing the device from mConnectedDevices
     // Called synchronized on mConnectedDevices
     private int checkSendBecomingNoisyIntent(int device, int state) {
         int delay = 0;
+        if (mConnectedBTDevicesList.size() > 1) {
+            Log.d(TAG, "checkSendBecomingNoisyIntent on state: " + state);
+            return delay;
+        }
         if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
             int devices = 0;
+            Log.d(TAG, "checkSendBecomingNoisyIntent update the noise");
             for (int i = 0; i < mConnectedDevices.size(); i++) {
                 int dev = mConnectedDevices.valueAt(i).mDeviceType;
                 if (((dev & AudioSystem.DEVICE_BIT_IN) == 0)
@@ -4779,7 +4452,6 @@ public class AudioService extends IAudioService.Stub {
                 delay = 1000;
             }
         }
-
         if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) ||
                 mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) ||
                 mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
@@ -4792,7 +4464,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return delay;
     }
-
     private void sendDeviceConnectionIntent(int device, int state, String address,
             String deviceName) {
         if (DEBUG_DEVICES) {
@@ -4801,15 +4472,11 @@ public class AudioService extends IAudioService.Stub {
                     " name:" + deviceName + ");");
         }
         Intent intent = new Intent();
-
         intent.putExtra(CONNECT_INTENT_KEY_STATE, state);
         intent.putExtra(CONNECT_INTENT_KEY_ADDRESS, address);
         intent.putExtra(CONNECT_INTENT_KEY_PORT_NAME, deviceName);
-
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
-
         int connType = 0;
-
         if (device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
             connType = AudioRoutesInfo.MAIN_HEADSET;
             intent.setAction(Intent.ACTION_HEADSET_PLUG);
@@ -4827,7 +4494,6 @@ public class AudioService extends IAudioService.Stub {
         } else if (device == AudioSystem.DEVICE_OUT_USB_DEVICE) {
             connType = AudioRoutesInfo.MAIN_USB;
         }
-
         synchronized (mCurAudioRoutes) {
             if (connType != 0) {
                 int newConn = mCurAudioRoutes.mainType;
@@ -4843,7 +4509,6 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         final long ident = Binder.clearCallingIdentity();
         try {
             ActivityManagerNative.broadcastStickyIntent(intent, null, UserHandle.USER_ALL);
@@ -4851,7 +4516,6 @@ public class AudioService extends IAudioService.Stub {
             Binder.restoreCallingIdentity(ident);
         }
     }
-
     private void onSetWiredDeviceConnectionState(int device, int state, String address,
             String deviceName, String caller) {
         if (DEBUG_DEVICES) {
@@ -4861,7 +4525,6 @@ public class AudioService extends IAudioService.Stub {
                     + " deviceName:" + deviceName
                     + " caller: " + caller + ");");
         }
-
         synchronized (mConnectedDevices) {
             if ((state == 0) && ((device == AudioSystem.DEVICE_OUT_WIRED_HEADSET) ||
                     (device == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE) ||
@@ -4917,7 +4580,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void configureHdmiPlugIntent(Intent intent, int state) {
         intent.setAction(AudioManager.ACTION_HDMI_AUDIO_PLUG);
         intent.putExtra(AudioManager.EXTRA_AUDIO_PLUG_STATE, state);
@@ -4962,10 +4624,8 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /* cache of the address of the last dock the device was connected to */
     private String mDockAddress;
-
     /**
      * Receiver for misc intent broadcasts the Phone app cares about.
      */
@@ -4976,7 +4636,6 @@ public class AudioService extends IAudioService.Stub {
             int outDevice;
             int inDevice;
             int state;
-
             if (action.equals(Intent.ACTION_DOCK_EVENT)) {
                 int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE,
                         Intent.EXTRA_DOCK_STATE_UNDOCKED);
@@ -5010,7 +4669,6 @@ public class AudioService extends IAudioService.Stub {
                 state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE,
                                                BluetoothProfile.STATE_DISCONNECTED);
                 BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-
                 setBtScoDeviceConnectionState(btDevice, state);
             } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
                 boolean broadcast = false;
@@ -5082,7 +4740,6 @@ public class AudioService extends IAudioService.Stub {
                         0);
                 // the current audio focus owner is no longer valid
                 mMediaFocusControl.discardAudioFocusOwner();
-
                 // load volume settings for new user
                 readAudioSettings(true /*userSwitch*/);
                 // preserve STREAM_MUSIC volume from one user to the next.
@@ -5107,10 +4764,11 @@ public class AudioService extends IAudioService.Stub {
                 int userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -1);
                 UserManagerService.getInstance().setSystemControlledUserRestriction(
                         UserManager.DISALLOW_RECORD_AUDIO, false, userId);
+            } else if (action.equals(Intent.ACTION_SHUTDOWN)) {
+                AudioSystem.setParameters("dev_shutdown=true");
             }
         }
     } // end class AudioServiceBroadcastReceiver
-
     private void killBackgroundUserProcessesWithRecordAudioPermission(UserInfo oldUser) {
         PackageManager pm = mContext.getPackageManager();
         // Find the home activity of the user. It should not be killed to avoid expensive restart,
@@ -5154,7 +4812,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     //==========================================================================================
     // RemoteControlDisplay / RemoteControlClient / Remote info
     //==========================================================================================
@@ -5162,30 +4819,33 @@ public class AudioService extends IAudioService.Stub {
             ComponentName listenerComp) {
         return mMediaFocusControl.registerRemoteController(rcd, w, h, listenerComp);
     }
-
     public boolean registerRemoteControlDisplay(IRemoteControlDisplay rcd, int w, int h) {
         return mMediaFocusControl.registerRemoteControlDisplay(rcd, w, h);
     }
-
     public void unregisterRemoteControlDisplay(IRemoteControlDisplay rcd) {
         mMediaFocusControl.unregisterRemoteControlDisplay(rcd);
     }
-
     public void remoteControlDisplayUsesBitmapSize(IRemoteControlDisplay rcd, int w, int h) {
         mMediaFocusControl.remoteControlDisplayUsesBitmapSize(rcd, w, h);
     }
-
     public void remoteControlDisplayWantsPlaybackPositionSync(IRemoteControlDisplay rcd,
             boolean wantsSync) {
         mMediaFocusControl.remoteControlDisplayWantsPlaybackPositionSync(rcd, wantsSync);
     }
-
+    public void setRemoteControlClientPlayItem(long uid, int scope) {
+        mMediaFocusControl.setRemoteControlClientPlayItem(uid, scope);
+    }
+    public void getRemoteControlClientNowPlayingEntries() {
+        mMediaFocusControl.getRemoteControlClientNowPlayingEntries();
+    }
+    public void setRemoteControlClientBrowsedPlayer() {
+        mMediaFocusControl.setRemoteControlClientBrowsedPlayer();
+    }
     @Override
     public void setRemoteStreamVolume(int index) {
         enforceVolumeController("set the remote stream volume");
         mMediaFocusControl.setRemoteStreamVolume(index);
     }
-
     //==========================================================================================
     // Audio Focus
     //==========================================================================================
@@ -5210,29 +4870,23 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
         return mMediaFocusControl.requestAudioFocus(aa, durationHint, cb, fd,
                 clientId, callingPackageName, flags);
     }
-
     public int abandonAudioFocus(IAudioFocusDispatcher fd, String clientId, AudioAttributes aa) {
         return mMediaFocusControl.abandonAudioFocus(fd, clientId, aa);
     }
-
     public void unregisterAudioFocusClient(String clientId) {
         mMediaFocusControl.unregisterAudioFocusClient(clientId);
     }
-
     public int getCurrentAudioFocus() {
         return mMediaFocusControl.getCurrentAudioFocus();
     }
-
     private boolean readCameraSoundForced() {
         return SystemProperties.getBoolean("audio.camerasound.force", false) ||
                 mContext.getResources().getBoolean(
                         com.android.internal.R.bool.config_camera_sound_forced);
     }
-
     //==========================================================================================
     // Device orientation
     //==========================================================================================
@@ -5262,7 +4916,6 @@ public class AudioService extends IAudioService.Stub {
                     0,
                     TAG,
                     0);
-
             boolean cameraSoundForced = readCameraSoundForced();
             synchronized (mSettingsLock) {
                 boolean cameraSoundForcedChanged = false;
@@ -5287,7 +4940,6 @@ public class AudioService extends IAudioService.Stub {
                         // take new state into account for streams muted by ringer mode
                         setRingerModeInt(getRingerModeInternal(), false);
                     }
-
                     sendMsg(mAudioHandler,
                             MSG_SET_FORCE_USE,
                             SENDMSG_QUEUE,
@@ -5296,7 +4948,6 @@ public class AudioService extends IAudioService.Stub {
                                     AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE,
                             null,
                             0);
-
                     sendMsg(mAudioHandler,
                             MSG_SET_ALL_VOLUMES,
                             SENDMSG_QUEUE,
@@ -5310,7 +4961,6 @@ public class AudioService extends IAudioService.Stub {
             Log.e(TAG, "Error handling configuration change: ", e);
         }
     }
-
     //TODO move to an external "orientation helper" class
     private void setOrientationForAudioSystem() {
         switch (mDeviceOrientation) {
@@ -5334,7 +4984,6 @@ public class AudioService extends IAudioService.Stub {
                 Log.e(TAG, "Unknown orientation");
         }
     }
-
     // Handles request to override default use of A2DP for media.
     // Must be called synchronized on mConnectedDevices
     public void setBluetoothA2dpOnInt(boolean on) {
@@ -5345,7 +4994,6 @@ public class AudioService extends IAudioService.Stub {
                     mBluetoothA2dpEnabled ? AudioSystem.FORCE_NONE : AudioSystem.FORCE_NO_BT_A2DP);
         }
     }
-
     // Must be called synchronized on mConnectedDevices
     private void setForceUseInt_SyncDevices(int usage, int config) {
         switch (usage) {
@@ -5368,18 +5016,15 @@ public class AudioService extends IAudioService.Stub {
         }
         AudioSystem.setForceUse(usage, config);
     }
-
     @Override
     public void setRingtonePlayer(IRingtonePlayer player) {
         mContext.enforceCallingOrSelfPermission(REMOTE_AUDIO_PLAYBACK, null);
         mRingtonePlayer = player;
     }
-
     @Override
     public IRingtonePlayer getRingtonePlayer() {
         return mRingtonePlayer;
     }
-
     @Override
     public AudioRoutesInfo startWatchingRoutes(IAudioRoutesObserver observer) {
         synchronized (mCurAudioRoutes) {
@@ -5388,8 +5033,6 @@ public class AudioService extends IAudioService.Stub {
             return routes;
         }
     }
-
-
     //==========================================================================================
     // Safe media volume management.
     // MUSIC stream volume level is limited when headphones are connected according to safety
@@ -5399,7 +5042,6 @@ public class AudioService extends IAudioService.Stub {
     // property. Platforms with a different limit must set this property accordingly in their
     // overlay.
     //==========================================================================================
-
     // mSafeMediaVolumeState indicates whether the media volume is limited over headphones.
     // It is SAFE_MEDIA_VOLUME_NOT_CONFIGURED at boot time until a network service is connected
     // or the configure time is elapsed. It is then set to SAFE_MEDIA_VOLUME_ACTIVE or
@@ -5411,7 +5053,6 @@ public class AudioService extends IAudioService.Stub {
     private static final int SAFE_MEDIA_VOLUME_INACTIVE = 2;  // confirmed
     private static final int SAFE_MEDIA_VOLUME_ACTIVE = 3;  // unconfirmed
     private Integer mSafeMediaVolumeState;
-
     private int mMcc = 0;
     // mSafeMediaVolumeIndex is the cached value of config_safe_media_volume_index property
     private int mSafeMediaVolumeIndex;
@@ -5425,7 +5066,6 @@ public class AudioService extends IAudioService.Stub {
     private static final int UNSAFE_VOLUME_MUSIC_ACTIVE_MS_MAX = (20 * 3600 * 1000); // 20 hours
     private static final int MUSIC_ACTIVE_POLL_PERIOD_MS = 60000;  // 1 minute polling interval
     private static final int SAFE_VOLUME_CONFIGURE_TIMEOUT_MS = 30000;  // 30s after boot completed
-
     private void setSafeMediaVolumeEnabled(boolean on, String caller) {
         synchronized (mSafeMediaVolumeState) {
             if ((mSafeMediaVolumeState != SAFE_MEDIA_VOLUME_NOT_CONFIGURED) &&
@@ -5448,12 +5088,10 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     private void enforceSafeMediaVolume(String caller) {
         VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
         int devices = mSafeMediaVolumeDevices;
         int i = 0;
-
         while (devices != 0) {
             int device = 1 << i++;
             if ((device & devices) == 0) {
@@ -5473,7 +5111,6 @@ public class AudioService extends IAudioService.Stub {
             devices &= ~device;
         }
     }
-
     private boolean checkSafeMediaVolume(int streamType, int index, int device) {
         synchronized (mSafeMediaVolumeState) {
             if ((mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) &&
@@ -5485,7 +5122,6 @@ public class AudioService extends IAudioService.Stub {
             return true;
         }
     }
-
     @Override
     public void disableSafeMediaVolume(String callingPackage) {
         enforceVolumeController("disable the safe media volume");
@@ -5501,13 +5137,11 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     //==========================================================================================
     // Hdmi Cec system audio mode.
     // If Hdmi Cec's system audio mode is on, audio service should send the volume change
     // to HdmiControlService so that the audio receiver can handle it.
     //==========================================================================================
-
     private class MyDisplayStatusCallback implements HdmiPlaybackClient.DisplayStatusCallback {
         public void onComplete(int status) {
             if (mHdmiManager != null) {
@@ -5522,7 +5156,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     };
-
     // If HDMI-CEC system audio is supported
     private boolean mHdmiSystemAudioSupported = false;
     // Set only when device is tv.
@@ -5534,9 +5167,7 @@ public class AudioService extends IAudioService.Stub {
     private HdmiPlaybackClient mHdmiPlaybackClient;
     // true if we are a set-top box, an HDMI sink is connected and it supports CEC.
     private boolean mHdmiCecSink;
-
     private MyDisplayStatusCallback mHdmiDisplayStatusCallback = new MyDisplayStatusCallback();
-
     @Override
     public int setHdmiSystemAudioSupported(boolean on) {
         int device = AudioSystem.DEVICE_NONE;
@@ -5546,7 +5177,6 @@ public class AudioService extends IAudioService.Stub {
                     Log.w(TAG, "Only Hdmi-Cec enabled TV device supports system audio mode.");
                     return device;
                 }
-
                 synchronized (mHdmiTvClient) {
                     if (mHdmiSystemAudioSupported != on) {
                         mHdmiSystemAudioSupported = on;
@@ -5560,28 +5190,23 @@ public class AudioService extends IAudioService.Stub {
         }
         return device;
     }
-
     @Override
     public boolean isHdmiSystemAudioSupported() {
         return mHdmiSystemAudioSupported;
     }
-
     //==========================================================================================
     // Accessibility: taking touch exploration into account for selecting the default
     //   stream override timeout when adjusting volume
     //==========================================================================================
     private static class StreamOverride
             implements AccessibilityManager.TouchExplorationStateChangeListener {
-
         // AudioService.getActiveStreamType() will return:
         // - STREAM_NOTIFICATION on tablets during this period after a notification stopped
         // - STREAM_MUSIC on phones during this period after music or talkback/voice search prompt
         // stopped
         private static final int DEFAULT_STREAM_TYPE_OVERRIDE_DELAY_MS = 0;
         private static final int TOUCH_EXPLORE_STREAM_TYPE_OVERRIDE_DELAY_MS = 1000;
-
         static int sDelayMs;
-
         static void init(Context ctxt) {
             AccessibilityManager accessibilityManager =
                     (AccessibilityManager) ctxt.getSystemService(Context.ACCESSIBILITY_SERVICE);
@@ -5590,12 +5215,10 @@ public class AudioService extends IAudioService.Stub {
             accessibilityManager.addTouchExplorationStateChangeListener(
                     new StreamOverride());
         }
-
         @Override
         public void onTouchExplorationStateChanged(boolean enabled) {
             updateDefaultStreamOverrideDelay(enabled);
         }
-
         private static void updateDefaultStreamOverrideDelay(boolean touchExploreEnabled) {
             if (touchExploreEnabled) {
                 sDelayMs = TOUCH_EXPLORE_STREAM_TYPE_OVERRIDE_DELAY_MS;
@@ -5606,30 +5229,25 @@ public class AudioService extends IAudioService.Stub {
                     + " stream override delay is now " + sDelayMs + " ms");
         }
     }
-
     //==========================================================================================
     // Camera shutter sound policy.
     // config_camera_sound_forced configuration option in config.xml defines if the camera shutter
     // sound is forced (sound even if the device is in silent mode) or not. This option is false by
     // default and can be overridden by country specific overlay in values-mccXXX/config.xml.
     //==========================================================================================
-
     // cached value of com.android.internal.R.bool.config_camera_sound_forced
     private Boolean mCameraSoundForced;
-
     // called by android.hardware.Camera to populate CameraInfo.canDisableShutterSound
     public boolean isCameraSoundForced() {
         synchronized (mCameraSoundForced) {
             return mCameraSoundForced;
         }
     }
-
     private static final String[] RINGER_MODE_NAMES = new String[] {
             "SILENT",
             "VIBRATE",
             "NORMAL"
     };
-
     private void dumpRingerMode(PrintWriter pw) {
         pw.println("\nRinger mode: ");
         pw.println("- mode (internal) = " + RINGER_MODE_NAMES[mRingerMode]);
@@ -5638,7 +5256,6 @@ public class AudioService extends IAudioService.Stub {
         dumpRingerModeStreams(pw, "muted", mRingerModeMutedStreams);
         pw.print("- delegate = "); pw.println(mRingerModeDelegate);
     }
-
     private void dumpRingerModeStreams(PrintWriter pw, String type, int streams) {
         pw.print("- ringer mode "); pw.print(type); pw.print(" streams = 0x");
         pw.print(Integer.toHexString(streams));
@@ -5662,18 +5279,15 @@ public class AudioService extends IAudioService.Stub {
         }
         pw.println();
     }
-
     @Override
     protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DUMP, TAG);
-
         mMediaFocusControl.dump(pw);
         dumpStreamStates(pw);
         dumpRingerMode(pw);
         pw.println("\nAudio routes:");
         pw.print("  mMainType=0x"); pw.println(Integer.toHexString(mCurAudioRoutes.mainType));
         pw.print("  mBluetoothName="); pw.println(mCurAudioRoutes.bluetoothName);
-
         pw.println("\nOther state:");
         pw.print("  mVolumeController="); pw.println(mVolumeController);
         pw.print("  mSafeMediaVolumeState=");
@@ -5686,10 +5300,8 @@ public class AudioService extends IAudioService.Stub {
         pw.print("  mHasVibrator="); pw.println(mHasVibrator);
         pw.print("  mControllerService="); pw.println(mControllerService);
         pw.print("  mVolumePolicy="); pw.println(mVolumePolicy);
-
         dumpAudioPolicies(pw);
     }
-
     private static String safeMediaVolumeStateToString(Integer state) {
         switch(state) {
             case SAFE_MEDIA_VOLUME_NOT_CONFIGURED: return "SAFE_MEDIA_VOLUME_NOT_CONFIGURED";
@@ -5699,7 +5311,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return null;
     }
-
     // Inform AudioFlinger of our device's low RAM attribute
     private static void readAndSetLowRamDevice()
     {
@@ -5708,7 +5319,6 @@ public class AudioService extends IAudioService.Stub {
             Log.w(TAG, "AudioFlinger informed of device's low RAM attribute; status " + status);
         }
     }
-
     private void enforceVolumeController(String action) {
         if (mControllerService.mUid != 0 && Binder.getCallingUid() == mControllerService.mUid) {
             return;
@@ -5716,16 +5326,13 @@ public class AudioService extends IAudioService.Stub {
         mContext.enforceCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR_SERVICE,
                 "Only SystemUI can " + action);
     }
-
     @Override
     public void setVolumeController(final IVolumeController controller) {
         enforceVolumeController("set the volume controller");
-
         // return early if things are not actually changing
         if (mVolumeController.isSameBinder(controller)) {
             return;
         }
-
         // dismiss the old volume controller
         mVolumeController.postDismiss();
         if (controller != null) {
@@ -5747,20 +5354,16 @@ public class AudioService extends IAudioService.Stub {
         mVolumeController.setController(controller);
         if (DEBUG_VOL) Log.d(TAG, "Volume controller: " + mVolumeController);
     }
-
     @Override
     public void notifyVolumeControllerVisible(final IVolumeController controller, boolean visible) {
         enforceVolumeController("notify about volume controller visibility");
-
         // return early if the controller is not current
         if (!mVolumeController.isSameBinder(controller)) {
             return;
         }
-
         mVolumeController.setVisible(visible);
         if (DEBUG_VOL) Log.d(TAG, "Volume controller visible: " + visible);
     }
-
     @Override
     public void setVolumePolicy(VolumePolicy policy) {
         enforceVolumeController("set volume policy");
@@ -5769,25 +5372,20 @@ public class AudioService extends IAudioService.Stub {
             if (DEBUG_VOL) Log.d(TAG, "Volume policy changed: " + mVolumePolicy);
         }
     }
-
     public static class VolumeController {
         private static final String TAG = "VolumeController";
-
         private IVolumeController mController;
         private boolean mVisible;
         private long mNextLongPress;
         private int mLongPressTimeout;
-
         public void setController(IVolumeController controller) {
             mController = controller;
             mVisible = false;
         }
-
         public void loadSettings(ContentResolver cr) {
             mLongPressTimeout = Settings.Secure.getIntForUser(cr,
                     Settings.Secure.LONG_PRESS_TIMEOUT, 500, UserHandle.USER_CURRENT);
         }
-
         public boolean suppressAdjustment(int resolvedStream, int flags, boolean isMute) {
             if (isMute) {
                 return false;
@@ -5813,28 +5411,22 @@ public class AudioService extends IAudioService.Stub {
             }
             return suppress;
         }
-
         public void setVisible(boolean visible) {
             mVisible = visible;
         }
-
         public boolean isSameBinder(IVolumeController controller) {
             return Objects.equals(asBinder(), binder(controller));
         }
-
         public IBinder asBinder() {
             return binder(mController);
         }
-
         private static IBinder binder(IVolumeController controller) {
             return controller == null ? null : controller.asBinder();
         }
-
         @Override
         public String toString() {
             return "VolumeController(" + asBinder() + ",mVisible=" + mVisible + ")";
         }
-
         public void postDisplaySafeVolumeWarning(int flags) {
             if (mController == null)
                 return;
@@ -5844,7 +5436,6 @@ public class AudioService extends IAudioService.Stub {
                 Log.w(TAG, "Error calling displaySafeVolumeWarning", e);
             }
         }
-
         public void postVolumeChanged(int streamType, int flags) {
             if (mController == null)
                 return;
@@ -5854,7 +5445,6 @@ public class AudioService extends IAudioService.Stub {
                 Log.w(TAG, "Error calling volumeChanged", e);
             }
         }
-
         public void postMasterMuteChanged(int flags) {
             if (mController == null)
                 return;
@@ -5864,7 +5454,6 @@ public class AudioService extends IAudioService.Stub {
                 Log.w(TAG, "Error calling masterMuteChanged", e);
             }
         }
-
         public void setLayoutDirection(int layoutDirection) {
             if (mController == null)
                 return;
@@ -5874,7 +5463,6 @@ public class AudioService extends IAudioService.Stub {
                 Log.w(TAG, "Error calling setLayoutDirection", e);
             }
         }
-
         public void postDismiss() {
             if (mController == null)
                 return;
@@ -5885,7 +5473,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     /**
      * Interface for system components to get some extra functionality through
      * LocalServices.
@@ -5899,7 +5486,6 @@ public class AudioService extends IAudioService.Stub {
                 setRingerModeInternal(getRingerModeInternal(), TAG + ".setRingerModeDelegate");
             }
         }
-
         @Override
         public void adjustSuggestedStreamVolumeForUid(int streamType, int direction, int flags,
                 String callingPackage, int uid) {
@@ -5908,35 +5494,29 @@ public class AudioService extends IAudioService.Stub {
             adjustSuggestedStreamVolume(direction, streamType, flags, callingPackage,
                     callingPackage, uid);
         }
-
         @Override
         public void adjustStreamVolumeForUid(int streamType, int direction, int flags,
                 String callingPackage, int uid) {
             adjustStreamVolume(streamType, direction, flags, callingPackage,
                     callingPackage, uid);
         }
-
         @Override
         public void setStreamVolumeForUid(int streamType, int direction, int flags,
                 String callingPackage, int uid) {
             setStreamVolume(streamType, direction, flags, callingPackage, callingPackage, uid);
         }
-
         @Override
         public int getRingerModeInternal() {
             return AudioService.this.getRingerModeInternal();
         }
-
         @Override
         public void setRingerModeInternal(int ringerMode, String caller) {
             AudioService.this.setRingerModeInternal(ringerMode, caller);
         }
-
         @Override
         public int getVolumeControllerUid() {
             return mControllerService.mUid;
         }
-
         @Override
         public void updateRingerModeAffectedStreamsInternal() {
             synchronized (mSettingsLock) {
@@ -5946,14 +5526,12 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     //==========================================================================================
     // Audio policy management
     //==========================================================================================
     public String registerAudioPolicy(AudioPolicyConfig policyConfig, IAudioPolicyCallback pcb,
             boolean hasFocusListener) {
         AudioSystem.setDynamicPolicyCallback(mDynPolicyCallback);
-
         if (DEBUG_AP) Log.d(TAG, "registerAudioPolicy for " + pcb.asBinder()
                 + " with config:" + policyConfig);
         String regId = null;
@@ -5966,7 +5544,6 @@ public class AudioService extends IAudioService.Stub {
                     + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
             return null;
         }
-
         synchronized (mAudioPolicies) {
             try {
                 if (mAudioPolicies.containsKey(pcb.asBinder())) {
@@ -5986,7 +5563,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return regId;
     }
-
     public void unregisterAudioPolicyAsync(IAudioPolicyCallback pcb) {
         if (DEBUG_AP) Log.d(TAG, "unregisterAudioPolicyAsync for " + pcb.asBinder());
         synchronized (mAudioPolicies) {
@@ -6002,7 +5578,6 @@ public class AudioService extends IAudioService.Stub {
         }
         // TODO implement clearing mix attribute matching info in native audio policy
     }
-
     public int setFocusPropertiesForPolicy(int duckingBehavior, IAudioPolicyCallback pcb) {
         if (DEBUG_AP) Log.d(TAG, "setFocusPropertiesForPolicy() duck behavior=" + duckingBehavior
                 + " policy " +  pcb.asBinder());
@@ -6016,7 +5591,6 @@ public class AudioService extends IAudioService.Stub {
                     + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
             return AudioManager.ERROR;
         }
-
         synchronized (mAudioPolicies) {
             if (!mAudioPolicies.containsKey(pcb.asBinder())) {
                 Slog.e(TAG, "Cannot change audio policy focus properties, unregistered policy");
@@ -6038,7 +5612,6 @@ public class AudioService extends IAudioService.Stub {
         }
         return AudioManager.SUCCESS;
     }
-
     private void dumpAudioPolicies(PrintWriter pw) {
         pw.println("\nAudio policies:");
         synchronized (mAudioPolicies) {
@@ -6047,7 +5620,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     }
-
     //======================
     // Audio policy callback from AudioSystem
     //======================
@@ -6060,7 +5632,6 @@ public class AudioService extends IAudioService.Stub {
             }
         }
     };
-
     private void onDynPolicyMixStateUpdate(String regId, int state) {
         if (DEBUG_AP) Log.d(TAG, "onDynamicPolicyMixStateUpdate("+ regId + ", " + state +")");
         synchronized (mAudioPolicies) {
@@ -6078,9 +5649,7 @@ public class AudioService extends IAudioService.Stub {
                 }
             }
         }
-
     }
-
     //======================
     // Audio policy proxy
     //======================
@@ -6100,7 +5669,6 @@ public class AudioService extends IAudioService.Stub {
          * is handling ducking for audio focus.
          */
         int mFocusDuckBehavior = AudioPolicy.FOCUS_POLICY_DUCKING_DEFAULT;
-
         AudioPolicyProxy(AudioPolicyConfig config, IAudioPolicyCallback token,
                 boolean hasFocusListener) {
             super(config);
@@ -6112,7 +5680,6 @@ public class AudioService extends IAudioService.Stub {
             }
             connectMixes();
         }
-
         public void binderDied() {
             synchronized (mAudioPolicies) {
                 Log.i(TAG, "audio policy " + mPolicyCallback + " died");
@@ -6120,11 +5687,9 @@ public class AudioService extends IAudioService.Stub {
                 mAudioPolicies.remove(mPolicyCallback.asBinder());
             }
         }
-
         String getRegistrationId() {
             return getRegistration();
         }
-
         void release() {
             if (mFocusDuckBehavior == AudioPolicy.FOCUS_POLICY_DUCKING_IN_POLICY) {
                 mMediaFocusControl.setDuckingInExtPolicyAvailable(false);
@@ -6134,35 +5699,28 @@ public class AudioService extends IAudioService.Stub {
             }
             AudioSystem.registerPolicyMixes(mMixes, false);
         }
-
         void connectMixes() {
             AudioSystem.registerPolicyMixes(mMixes, true);
         }
     };
-
     private HashMap<IBinder, AudioPolicyProxy> mAudioPolicies =
             new HashMap<IBinder, AudioPolicyProxy>();
     private int mAudioPolicyCounter = 0; // always accessed synchronized on mAudioPolicies
-
     private class ControllerService extends ContentObserver {
         private int mUid;
         private ComponentName mComponent;
-
         public ControllerService() {
             super(null);
         }
-
         @Override
         public String toString() {
             return String.format("{mUid=%d,mComponent=%s}", mUid, mComponent);
         }
-
         public void init() {
             onChange(true);
             mContentResolver.registerContentObserver(Settings.Secure.getUriFor(
                     Settings.Secure.VOLUME_CONTROLLER_SERVICE_COMPONENT), false, this);
         }
-
         @Override
         public void onChange(boolean selfChange) {
             mUid = 0;
diff --git a/services/core/java/com/android/server/audio/MediaFocusControl.java b/services/core/java/com/android/server/audio/MediaFocusControl.java
index f72b598..af880bd 100644
--- a/services/core/java/com/android/server/audio/MediaFocusControl.java
+++ b/services/core/java/com/android/server/audio/MediaFocusControl.java
@@ -335,6 +335,9 @@ public class MediaFocusControl implements OnFinished {
     private static final int MSG_RCDISPLAY_INIT_INFO = 9;
     private static final int MSG_REEVALUATE_RCD = 10;
     private static final int MSG_UNREGISTER_MEDIABUTTONINTENT = 11;
+    private static final int MSG_RCC_SET_BROWSED_PLAYER = 12;
+    private static final int MSG_RCC_SET_PLAY_ITEM = 13;
+    private static final int MSG_RCC_GET_NOW_PLAYING_ENTRIES = 14;
 
     // sendMsg() flags
     /** If the msg is already queued, replace it with this one. */
@@ -382,6 +385,22 @@ public class MediaFocusControl implements OnFinished {
                             (IRemoteVolumeObserver)msg.obj /* rvo */);
                     break;
 
+                case MSG_RCC_SET_PLAY_ITEM:
+                    Log.d(TAG, "MSG_RCC_SET_PLAY_ITEM: "+ ((Long)msg.obj).longValue());
+                    onSetRemoteControlClientPlayItem(msg.arg2 /* scope */,
+                                    ((Long)msg.obj).longValue() /* uid */);
+                    break;
+
+                case MSG_RCC_GET_NOW_PLAYING_ENTRIES:
+                    Log.d(TAG, "MSG_RCC_GET_NOW_PLAYING_ENTRIES: ");
+                    onGetRemoteControlClientNowPlayingEntries();
+                    break;
+
+                case MSG_RCC_SET_BROWSED_PLAYER:
+                    Log.d(TAG, "MSG_RCC_SET_BROWSED_PLAYER: ");
+                    onSetRemoteControlClientBrowsedPlayer();
+                    break;
+
                 case MSG_RCDISPLAY_INIT_INFO:
                     // msg.obj is guaranteed to be non null
                     onRcDisplayInitInfo((IRemoteControlDisplay)msg.obj /*newRcd*/,
@@ -2052,6 +2071,66 @@ public class MediaFocusControl implements OnFinished {
         }
     }
 
+    public void setRemoteControlClientPlayItem(long uid, int scope) {
+        sendMsg(mEventHandler, MSG_RCC_SET_PLAY_ITEM, SENDMSG_REPLACE, 0 /* arg1 */,
+                scope /* arg2*/, new Long(uid) /* obj */, 0 /* delay */);
+    }
+
+    private void onSetRemoteControlClientPlayItem(int scope, Long uid) {
+        Log.d(TAG, "onSetRemoteControlClientPlayItem: "+ uid);
+        synchronized(mCurrentRcLock) {
+            if (mCurrentRcClient != null) {
+                try {
+                    mCurrentRcClient.setPlayItem(scope, uid);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Current valid remote client is dead: "+e);
+                    mCurrentRcClient = null;
+                }
+            }
+        }
+    }
+
+    public void getRemoteControlClientNowPlayingEntries() {
+        sendMsg(mEventHandler, MSG_RCC_GET_NOW_PLAYING_ENTRIES, SENDMSG_REPLACE,
+                0 /* arg1 */, 0 /* arg2 ignored*/, 0 /* obj */, 0 /* delay */);
+    }
+
+    private void onGetRemoteControlClientNowPlayingEntries() {
+        Log.d(TAG, "onGetRemoteControlClientNowPlayingEntries: ");
+        synchronized(mCurrentRcLock) {
+            if (mCurrentRcClient != null) {
+                try {
+                    mCurrentRcClient.getNowPlayingEntries();
+                } catch (RemoteException e) {
+                    Log.e(TAG, "Current valid remote client is dead: "+e);
+                    mCurrentRcClient = null;
+                }
+            }
+        }
+    }
+
+    public void setRemoteControlClientBrowsedPlayer() {
+        Log.d(TAG, "setRemoteControlClientBrowsedPlayer: ");
+        sendMsg(mEventHandler, MSG_RCC_SET_BROWSED_PLAYER, SENDMSG_REPLACE, 0/* arg1 */,
+                0 /* arg2 ignored*/, 0 /* obj */, 0 /* delay */);
+    }
+
+    private void onSetRemoteControlClientBrowsedPlayer() {
+        Log.d(TAG, "onSetRemoteControlClientBrowsedPlayer: ");
+        PlayerRecord prse = mPRStack.peek();
+        if (prse.getRcc() == null) {
+            Log.d(TAG, "can not proceed with setBrowsedPlayer");
+        } else {
+            Log.d(TAG, "proceed with setBrowsedPlayer");
+            try {
+                Log.d(TAG, "Calling setBrowsedPlayer");
+                prse.getRcc().setBrowsedPlayer();
+            } catch (RemoteException e) {
+                Log.e(TAG, "Current valid remote client is dead: "+ e);
+            }
+        }
+    }
+
     // handler for MSG_RCC_NEW_VOLUME_OBS
     private void onRegisterVolumeObserverForRcc(int rccId, IRemoteVolumeObserver rvo) {
         synchronized(mPRStack) {
diff --git a/services/core/java/com/android/server/media/MediaSessionRecord.java b/services/core/java/com/android/server/media/MediaSessionRecord.java
index f92f631..bc830f0 100644
--- a/services/core/java/com/android/server/media/MediaSessionRecord.java
+++ b/services/core/java/com/android/server/media/MediaSessionRecord.java
@@ -106,6 +106,9 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
     private CharSequence mQueueTitle;
     private int mRatingType;
     private long mLastActiveTime;
+    private String mBrowsedPlayerURI;
+    private boolean mPlayItemStatus;
+    private long[] mNowPlayingList;
     // End TransportPerformer fields
 
     // Volume handling fields
@@ -518,6 +521,86 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
         }
     }
 
+    private void pushBrowsePlayerInfo() {
+        synchronized (mLock) {
+            if (mDestroyed) {
+                return;
+            }
+            for (int i = mControllerCallbacks.size() - 1; i >= 0; i--) {
+                ISessionControllerCallback cb = mControllerCallbacks.get(i);
+                try {
+                    Log.d(TAG, "pushBrowsePlayerInfo");
+                    cb.onUpdateFolderInfoBrowsedPlayer(mBrowsedPlayerURI);
+                } catch (DeadObjectException e) {
+                    Log.w(TAG, "Removing dead callback in pushBrowsePlayerInfo. ", e);
+                    mControllerCallbacks.remove(i);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "unexpected exception in pushBrowsePlayerInfo. ", e);
+                }
+            }
+        }
+    }
+
+    private void pushNowPlayingEntries() {
+        synchronized (mLock) {
+            if (mDestroyed) {
+                return;
+            }
+            for (int i = mControllerCallbacks.size() - 1; i >= 0; i--) {
+                ISessionControllerCallback cb = mControllerCallbacks.get(i);
+                try {
+                    Log.d(TAG, "pushNowPlayingEntries");
+                    cb.onUpdateNowPlayingEntries(mNowPlayingList);
+                } catch (DeadObjectException e) {
+                    Log.w(TAG, "Removing dead callback in pushNowPlayingEntries. ", e);
+                    mControllerCallbacks.remove(i);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "unexpected exception in pushNowPlayingEntries. ", e);
+                }
+            }
+        }
+    }
+
+    private void pushNowPlayingContentChange() {
+        synchronized (mLock) {
+            if (mDestroyed) {
+                return;
+            }
+            for (int i = mControllerCallbacks.size() - 1; i >= 0; i--) {
+                ISessionControllerCallback cb = mControllerCallbacks.get(i);
+                try {
+                    Log.d(TAG, "pushNowPlayingContentChange");
+                    cb.onUpdateNowPlayingContentChange();
+                } catch (DeadObjectException e) {
+                    Log.w(TAG, "Removing dead callback in pushNowPlayingContentChange. ", e);
+                    mControllerCallbacks.remove(i);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "unexpected exception in pushNowPlayingContentChange. ", e);
+                }
+            }
+        }
+    }
+
+    private void pushPlayItemResponse() {
+        synchronized (mLock) {
+            if (mDestroyed) {
+                return;
+            }
+            for (int i = mControllerCallbacks.size() - 1; i >= 0; i--) {
+                ISessionControllerCallback cb = mControllerCallbacks.get(i);
+                try {
+                    Log.d(TAG, "pushPlayItemResponse");
+                    cb.onPlayItemResponse(mPlayItemStatus);
+                } catch (DeadObjectException e) {
+                    Log.w(TAG, "Removing dead callback in pushPlayItemResponse. ", e);
+                    mControllerCallbacks.remove(i);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "unexpected exception in pushPlayItemResponse. ", e);
+                }
+            }
+        }
+    }
+
     private void pushQueueUpdate() {
         synchronized (mLock) {
             if (mDestroyed) {
@@ -775,6 +858,33 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
         }
 
         @Override
+        public void updateFolderInfoBrowsedPlayer(String stringUri) {
+            Log.d(TAG, "SessionStub: updateFolderInfoBrowsedPlayer");
+            mBrowsedPlayerURI = stringUri;
+            mHandler.post(MessageHandler.MSG_FOLDER_INFO_BROWSED_PLAYER);
+        }
+
+        @Override
+        public void updateNowPlayingEntries(long[] playList) {
+            Log.d(TAG, "SessionStub: updateNowPlayingEntries");
+            mNowPlayingList = playList;
+            mHandler.post(MessageHandler.MSG_UPDATE_NOWPLAYING_ENTRIES);
+        }
+
+        @Override
+        public void updateNowPlayingContentChange() {
+            Log.d(TAG, "SessionStub: updateNowPlayingContentChange");
+            mHandler.post(MessageHandler.MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE);
+        }
+
+        @Override
+        public void playItemResponse(boolean success) {
+            Log.d(TAG, "SessionStub: playItemResponse");
+            mPlayItemStatus = success;
+            mHandler.post(MessageHandler.MSG_PLAY_ITEM_RESPONSE);
+        }
+
+        @Override
         public void setQueueTitle(CharSequence title) {
             mQueueTitle = title;
             mHandler.post(MessageHandler.MSG_UPDATE_QUEUE_TITLE);
@@ -957,6 +1067,7 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
         }
 
         public void seekTo(long pos) {
+            Slog.d(TAG, "seekTo in SessionCb");
             try {
                 mCb.onSeekTo(pos);
             } catch (RemoteException e) {
@@ -964,6 +1075,42 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
             }
         }
 
+        /**
+         * @hide
+         */
+        public void setRemoteControlClientBrowsedPlayer() {
+            Slog.d(TAG, "setRemoteControlClientBrowsedPlayer in SessionCb");
+            try {
+                mCb.setRemoteControlClientBrowsedPlayer();
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Remote failure in setRemoteControlClientBrowsedPlayer.", e);
+            }
+        }
+
+        /**
+         * @hide
+         */
+        public void setRemoteControlClientPlayItem(long uid, int scope) throws RemoteException {
+            Slog.d(TAG, "setRemoteControlClientPlayItem in SessionCb");
+            try {
+                mCb.setRemoteControlClientPlayItem(uid, scope);
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Remote failure in setRemoteControlClientPlayItem.", e);
+            }
+        }
+
+        /**
+         * @hide
+         */
+        public void getRemoteControlClientNowPlayingEntries() throws RemoteException {
+            Slog.d(TAG, "getRemoteControlClientNowPlayingEntries in SessionCb");
+            try {
+                mCb.getRemoteControlClientNowPlayingEntries();
+            } catch (RemoteException e) {
+                Slog.e(TAG, "Remote failure in getRemoteControlClientNowPlayingEntries.", e);
+            }
+        }
+
         public void rate(Rating rating) {
             try {
                 mCb.onRate(rating);
@@ -1157,10 +1304,29 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
 
         @Override
         public void seekTo(long pos) throws RemoteException {
+            Log.d(TAG, "seekTo in ControllerStub");
             mSessionCb.seekTo(pos);
         }
 
         @Override
+        public void setRemoteControlClientBrowsedPlayer() throws RemoteException {
+            Log.d(TAG, "setRemoteControlClientBrowsedPlayer in ControllerStub");
+            mSessionCb.setRemoteControlClientBrowsedPlayer();
+        }
+
+        @Override
+        public void setRemoteControlClientPlayItem(long uid, int scope) throws RemoteException {
+            Log.d(TAG, "setRemoteControlClientPlayItem in ControllerStub");
+            mSessionCb.setRemoteControlClientPlayItem(uid, scope);
+        }
+
+        @Override
+        public void getRemoteControlClientNowPlayingEntries() throws RemoteException {
+            Log.d(TAG, "getRemoteControlClientNowPlayingEntries in ControllerStub");
+            mSessionCb.getRemoteControlClientNowPlayingEntries();
+        }
+
+        @Override
         public void rate(Rating rating) throws RemoteException {
             mSessionCb.rate(rating);
         }
@@ -1224,6 +1390,10 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
         private static final int MSG_UPDATE_SESSION_STATE = 7;
         private static final int MSG_UPDATE_VOLUME = 8;
         private static final int MSG_DESTROYED = 9;
+        private static final int MSG_FOLDER_INFO_BROWSED_PLAYER = 10;
+        private static final int MSG_UPDATE_NOWPLAYING_ENTRIES = 11;
+        private static final int MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE = 12;
+        private static final int MSG_PLAY_ITEM_RESPONSE = 13;
 
         public MessageHandler(Looper looper) {
             super(looper);
@@ -1257,6 +1427,18 @@ public class MediaSessionRecord implements IBinder.DeathRecipient {
                     break;
                 case MSG_DESTROYED:
                     pushSessionDestroyed();
+                case MSG_FOLDER_INFO_BROWSED_PLAYER:
+                    pushBrowsePlayerInfo();
+                    break;
+                case MSG_UPDATE_NOWPLAYING_ENTRIES:
+                    pushNowPlayingEntries();
+                    break;
+                case MSG_UPDATE_NOWPLAYING_CONTENT_CHANGE:
+                    pushNowPlayingContentChange();
+                    break;
+                case MSG_PLAY_ITEM_RESPONSE:
+                    pushPlayItemResponse();
+                    break;
             }
         }
 
-- 
1.9.1

