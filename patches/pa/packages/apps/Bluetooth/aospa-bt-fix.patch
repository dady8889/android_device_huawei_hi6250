From 36fd39c246efe20fcd1b36682cb6e8b135faf6c7 Mon Sep 17 00:00:00 2001
From: Daniel <dady8889@gmail.com>
Date: Sun, 27 Nov 2016 02:08:18 +0100
Subject: [PATCH] Fix Bluetooth

Change-Id: I5b956068d589a8511b93c8cbb412f73ef1fa5fa3
---
 AndroidManifest.xml                                |   26 +-
 jni/com_android_bluetooth_a2dp.cpp                 |  153 +-
 jni/com_android_bluetooth_a2dp_sink.cpp            |   49 +-
 jni/com_android_bluetooth_avrcp.cpp                | 1973 +++++++-
 ..._android_bluetooth_btservice_AdapterService.cpp |  220 +-
 res/values-sk/cm_strings.xml                       |   34 +
 res/values/cm_strings.xml                          |   34 +
 src/com/android/bluetooth/OolConnManager.java      |   96 +
 src/com/android/bluetooth/a2dp/A2dpService.java    |   75 +-
 .../android/bluetooth/a2dp/A2dpSinkService.java    |   51 +-
 .../bluetooth/a2dp/A2dpSinkStateMachine.java       | 1340 +++++-
 .../android/bluetooth/a2dp/A2dpStateMachine.java   |  616 ++-
 src/com/android/bluetooth/avrcp/Avrcp.java         | 4944 ++++++++++++++++++--
 .../bluetooth/avrcp/AvrcpControllerService.java    | 1956 +++++++-
 .../avrcp/BluetoothAvrcpDataProvider.java          |  382 ++
 .../bluetooth/btservice/AdapterProperties.java     |   64 +-
 .../bluetooth/btservice/AdapterService.java        |  554 ++-
 .../android/bluetooth/btservice/AdapterState.java  |    5 +
 .../bluetooth/btservice/BondStateMachine.java      |   51 +-
 .../bluetooth/btservice/ProfileService.java        |   19 +-
 src/com/android/bluetooth/sdp/SdpManager.java      |   32 +-
 21 files changed, 11789 insertions(+), 885 deletions(-)
 create mode 100644 res/values-sk/cm_strings.xml
 create mode 100644 res/values/cm_strings.xml
 create mode 100644 src/com/android/bluetooth/OolConnManager.java
 create mode 100644 src/com/android/bluetooth/avrcp/BluetoothAvrcpDataProvider.java

diff --git a/AndroidManifest.xml b/AndroidManifest.xml
index 3652fd3..9834073 100644
--- a/AndroidManifest.xml
+++ b/AndroidManifest.xml
@@ -11,6 +11,11 @@
         android:description="@string/permdesc_bluetoothShareManager"
         android:protectionLevel="signature" />
 
+        <permission android:name="android.permission.ACCESS_BLUETOOTH_AVRCP_CT_DATA"
+        android:label="@string/permlab_bluetoothAvrcpDataManager"
+        android:description="@string/permdesc_bluetoothAvrcpDataManager"
+        android:protectionLevel="signature" />
+
     <!--  Allows temporarily whitelisting Bluetooth addresses for sharing -->
     <permission android:name="com.android.permission.WHITELIST_BLUETOOTH_DEVICE"
         android:label="@string/permlab_bluetoothWhitelist"
@@ -20,6 +25,7 @@
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <uses-permission android:name="android.permission.ACCESS_BLUETOOTH_SHARE" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
+    <uses-permission android:name="android.permission.ACCESS_BLUETOOTH_AVRCP_CT_DATA" />
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.BLUETOOTH" />
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
@@ -55,13 +61,15 @@
     <uses-permission android:name="android.permission.SEND_SMS" />
     <uses-permission android:name="android.permission.READ_SMS" />
     <uses-permission android:name="android.permission.WRITE_SMS" />
-    <uses-permission android:name="android.permission.READ_CONTACTS" />
     <uses-permission android:name="android.permission.MEDIA_CONTENT_CONTROL" />
     <uses-permission android:name="android.permission.MANAGE_DOCUMENTS" />
     <uses-permission android:name="android.permission.UPDATE_APP_OPS_STATS" />
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.DEVICE_POWER" />
     <uses-permission android:name="android.permission.REAL_GET_TASKS" />
+    <uses-permission android:name="android.permission.MODIFY_AUDIO_ROUTING" />
+    <uses-permission android:name="com.android.email.permission.ACCESS_PROVIDER"/>
+    <uses-permission android:name="com.android.email.permission.READ_ATTACHMENT"/>
 
     <!-- For PBAP Owner Vcard Info -->
     <uses-permission android:name="android.permission.READ_PROFILE"/>
@@ -81,6 +89,14 @@
                     android:pathPrefix="/btopp"
                     android:permission="android.permission.ACCESS_BLUETOOTH_SHARE" />
         </provider>
+        <provider android:name=".avrcp.BluetoothAvrcpDataProvider"
+            android:authorities="com.android.bluetooth.avrcp"
+            android:exported="true"
+            android:process="@string/process">
+            <path-permission
+                    android:pathPrefix="/btavrcp_ct"
+                    android:permission="android.permission.ACCESS_BLUETOOTH_AVRCP_CT_DATA" />
+        </provider>
         <provider android:name="android.support.v4.content.FileProvider"
             android:authorities="com.google.android.bluetooth.fileprovider"
             android:grantUriPermissions="true"
@@ -149,8 +165,10 @@
                 <data android:mimeType="application/zip" />
                 <data android:mimeType="application/vnd.ms-excel" />
                 <data android:mimeType="application/msword" />
+                <data android:mimeType="application/vnd.android.package-archive" />
                 <data android:mimeType="application/vnd.ms-powerpoint" />
                 <data android:mimeType="application/pdf" />
+                <data android:mimeType="application/epub+zip" />
                 <data android:mimeType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
                 <data android:mimeType="application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
                 <data android:mimeType="application/vnd.openxmlformats-officedocument.presentationml.presentation" />
@@ -161,6 +179,7 @@
                 <category android:name="android.intent.category.DEFAULT" />
                 <data android:mimeType="image/*" />
                 <data android:mimeType="video/*" />
+                <data android:mimeType="audio/*" />
                 <data android:mimeType="x-mixmedia/*" />
                 <data android:mimeType="text/x-vcard" />
             </intent-filter>
@@ -203,7 +222,7 @@
                   android:process="@string/process"
                   android:label=""
                   android:excludeFromRecents="true"
-                  android:configChanges="orientation|keyboardHidden"
+                  android:configChanges="orientation|keyboardHidden|screenSize"
                   android:enabled="@bool/profile_supported_opp">
         </activity>
         <activity android:name=".pbap.BluetoothPbapActivity"
@@ -301,6 +320,7 @@
         <service
             android:process="@string/process"
             android:name = ".avrcp.AvrcpControllerService"
+            android:permission="android.permission.ACCESS_BLUETOOTH_AVRCP_CT_DATA"
             android:enabled="@bool/profile_supported_avrcp_controller">
             <intent-filter>
                 <action android:name="android.bluetooth.IBluetoothAvrcpController" />
@@ -330,7 +350,7 @@
                 <action android:name="android.bluetooth.IBluetoothPan" />
             </intent-filter>
         </service>
-    <service
+        <service
             android:process="@string/process"
             android:name = ".hfpclient.HeadsetClientService"
             android:enabled="@bool/profile_supported_hfpclient">
diff --git a/jni/com_android_bluetooth_a2dp.cpp b/jni/com_android_bluetooth_a2dp.cpp
index 415f6fe..565cd99 100644
--- a/jni/com_android_bluetooth_a2dp.cpp
+++ b/jni/com_android_bluetooth_a2dp.cpp
@@ -1,4 +1,7 @@
 /*
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -24,15 +27,21 @@
 #include "android_runtime/AndroidRuntime.h"
 
 #include <string.h>
+#include <pthread.h>
 
 namespace android {
 static jmethodID method_onConnectionStateChanged;
 static jmethodID method_onAudioStateChanged;
+static jmethodID method_onCheckConnectionPriority;
+static jmethodID method_onMulticastStateChanged;
+
 
 static const btav_interface_t *sBluetoothA2dpInterface = NULL;
 static jobject mCallbacksObj = NULL;
 static JNIEnv *sCallbackEnv = NULL;
 
+static pthread_mutex_t mMutex = PTHREAD_MUTEX_INITIALIZER;
+
 static bool checkCallbackThread() {
     // Always fetch the latest callbackEnv from AdapterService.
     // Caching this could cause this sCallbackEnv to go out-of-sync
@@ -56,6 +65,7 @@ static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_b
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__); \
         return;                                                         \
     }
+
     addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
     if (!addr) {
         ALOGE("Fail to new jbyteArray bd addr for connection state");
@@ -64,8 +74,16 @@ static void bta2dp_connection_state_callback(btav_connection_state_t state, bt_b
     }
 
     sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
-    sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onConnectionStateChanged, (jint) state,
-                                 addr);
+
+    pthread_mutex_lock(&mMutex);
+    if (mCallbacksObj != NULL) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onConnectionStateChanged,
+                        (jint) state, addr);
+    } else {
+        ALOGE("Callbacks Obj is no more valid: '%s", __FUNCTION__);
+    }
+    pthread_mutex_unlock(&mMutex);
+
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
     sCallbackEnv->DeleteLocalRef(addr);
 }
@@ -87,16 +105,80 @@ static void bta2dp_audio_state_callback(btav_audio_state_t state, bt_bdaddr_t* b
     }
 
     sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
-    sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onAudioStateChanged, (jint) state,
-                                 addr);
+
+    pthread_mutex_lock(&mMutex);
+    if (mCallbacksObj != NULL) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onAudioStateChanged,
+                        (jint) state, addr);
+    } else {
+        ALOGE("Callbacks Obj is no more valid: '%s", __FUNCTION__);
+    }
+    pthread_mutex_unlock(&mMutex);
+
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
     sCallbackEnv->DeleteLocalRef(addr);
 }
 
+static void bta2dp_connection_priority_callback(bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+
+    ALOGI("%s", __FUNCTION__);
+
+    if (!checkCallbackThread()) {                                       \
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__); \
+        return;                                                         \
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for connection state");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+
+    pthread_mutex_lock(&mMutex);
+    if (mCallbacksObj != NULL) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onCheckConnectionPriority,
+                        addr);
+    } else {
+        ALOGE("Callbacks Obj is no more valid: '%s", __FUNCTION__);
+    }
+    pthread_mutex_unlock(&mMutex);
+
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void bta2dp_multicast_enabled_callback(int state) {
+
+    ALOGI("%s", __FUNCTION__);
+
+    if (!checkCallbackThread()) {                                       \
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__); \
+        return;                                                         \
+    }
+
+    pthread_mutex_lock(&mMutex);
+    if (mCallbacksObj != NULL) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onMulticastStateChanged,
+                        state);
+    } else {
+        ALOGE("Callbacks Obj is no more valid: '%s", __FUNCTION__);
+    }
+    pthread_mutex_unlock(&mMutex);
+
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+}
+
 static btav_callbacks_t sBluetoothA2dpCallbacks = {
     sizeof(sBluetoothA2dpCallbacks),
     bta2dp_connection_state_callback,
-    bta2dp_audio_state_callback
+    bta2dp_audio_state_callback,
+    NULL,
+    bta2dp_connection_priority_callback,
+    bta2dp_multicast_enabled_callback,
+    NULL
 };
 
 static void classInitNative(JNIEnv* env, jclass clazz) {
@@ -109,6 +191,12 @@ static void classInitNative(JNIEnv* env, jclass clazz) {
 
     method_onAudioStateChanged =
         env->GetMethodID(clazz, "onAudioStateChanged", "(I[B)V");
+
+    method_onCheckConnectionPriority =
+        env->GetMethodID(clazz, "onCheckConnectionPriority", "([B)V");
+
+    method_onMulticastStateChanged =
+        env->GetMethodID(clazz, "onMulticastStateChanged", "(I)V");
     /*
     if ( (btInf = getBluetoothInterface()) == NULL) {
         ALOGE("Bluetooth module is not loaded");
@@ -134,7 +222,8 @@ static void classInitNative(JNIEnv* env, jclass clazz) {
     ALOGI("%s: succeeds", __FUNCTION__);
 }
 
-static void initNative(JNIEnv *env, jobject object) {
+static void initNative(JNIEnv *env, jobject object, jint maxA2dpConnections,
+        jint multiCastState) {
     const bt_interface_t* btInf;
     bt_status_t status;
 
@@ -149,25 +238,35 @@ static void initNative(JNIEnv *env, jobject object) {
          sBluetoothA2dpInterface = NULL;
     }
 
-    if (mCallbacksObj != NULL) {
-         ALOGW("Cleaning up A2DP callback object");
-         env->DeleteGlobalRef(mCallbacksObj);
-         mCallbacksObj = NULL;
-    }
-
     if ( (sBluetoothA2dpInterface = (btav_interface_t *)
           btInf->get_profile_interface(BT_PROFILE_ADVANCED_AUDIO_ID)) == NULL) {
         ALOGE("Failed to get Bluetooth A2DP Interface");
         return;
     }
 
-    if ( (status = sBluetoothA2dpInterface->init(&sBluetoothA2dpCallbacks)) != BT_STATUS_SUCCESS) {
+    pthread_mutex_lock(&mMutex);
+    if (mCallbacksObj != NULL) {
+         ALOGW("Cleaning up A2DP callback object");
+         env->DeleteGlobalRef(mCallbacksObj);
+         mCallbacksObj = NULL;
+    }
+    mCallbacksObj = env->NewGlobalRef(object);
+    pthread_mutex_unlock(&mMutex);
+
+    if ( (status = sBluetoothA2dpInterface->init(&sBluetoothA2dpCallbacks,
+            maxA2dpConnections, multiCastState)) != BT_STATUS_SUCCESS) {
         ALOGE("Failed to initialize Bluetooth A2DP, status: %d", status);
         sBluetoothA2dpInterface = NULL;
+        pthread_mutex_lock(&mMutex);
+        if (mCallbacksObj != NULL) {
+             ALOGW("Clean up A2DP callback object");
+             env->DeleteGlobalRef(mCallbacksObj);
+             mCallbacksObj = NULL;
+        }
+        pthread_mutex_unlock(&mMutex);
         return;
     }
 
-    mCallbacksObj = env->NewGlobalRef(object);
 }
 
 static void cleanupNative(JNIEnv *env, jobject object) {
@@ -184,10 +283,12 @@ static void cleanupNative(JNIEnv *env, jobject object) {
         sBluetoothA2dpInterface = NULL;
     }
 
+    pthread_mutex_lock(&mMutex);
     if (mCallbacksObj != NULL) {
         env->DeleteGlobalRef(mCallbacksObj);
         mCallbacksObj = NULL;
     }
+    pthread_mutex_unlock(&mMutex);
 }
 
 static jboolean connectA2dpNative(JNIEnv *env, jobject object, jbyteArray address) {
@@ -225,18 +326,38 @@ static jboolean disconnectA2dpNative(JNIEnv *env, jobject object, jbyteArray add
     }
 
     if ( (status = sBluetoothA2dpInterface->disconnect((bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed HF disconnection, status: %d", status);
+        ALOGE("Failed A2DP disconnection, status: %d", status);
     }
     env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+static void allowConnectionNative(JNIEnv *env, jobject object, int is_valid, jbyteArray address) {
+
+    jbyte *addr;
+    if (!sBluetoothA2dpInterface) {
+        ALOGE("sBluetoothA2dpInterface is NULL ");
+        return;
+    }
+
+    addr = env->GetByteArrayElements(address, NULL);
+
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return ;
+    }
+
+    sBluetoothA2dpInterface->allow_connection(is_valid, (bt_bdaddr_t *)addr);
+    env->ReleaseByteArrayElements(address, addr, 0);
+}
+
 static JNINativeMethod sMethods[] = {
     {"classInitNative", "()V", (void *) classInitNative},
-    {"initNative", "()V", (void *) initNative},
+    {"initNative", "(II)V", (void *) initNative},
     {"cleanupNative", "()V", (void *) cleanupNative},
     {"connectA2dpNative", "([B)Z", (void *) connectA2dpNative},
     {"disconnectA2dpNative", "([B)Z", (void *) disconnectA2dpNative},
+    {"allowConnectionNative", "(I[B)V", (void *) allowConnectionNative},
 };
 
 int register_com_android_bluetooth_a2dp(JNIEnv* env)
diff --git a/jni/com_android_bluetooth_a2dp_sink.cpp b/jni/com_android_bluetooth_a2dp_sink.cpp
index f2bbb1b..a178204 100644
--- a/jni/com_android_bluetooth_a2dp_sink.cpp
+++ b/jni/com_android_bluetooth_a2dp_sink.cpp
@@ -1,4 +1,7 @@
 /*
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -29,6 +32,7 @@ namespace android {
 static jmethodID method_onConnectionStateChanged;
 static jmethodID method_onAudioStateChanged;
 static jmethodID method_onAudioConfigChanged;
+static jmethodID method_onAudioFocusRequested;
 
 static const btav_interface_t *sBluetoothA2dpInterface = NULL;
 static jobject mCallbacksObj = NULL;
@@ -116,11 +120,36 @@ static void bta2dp_audio_config_callback(bt_bdaddr_t *bd_addr, uint32_t sample_r
     sCallbackEnv->DeleteLocalRef(addr);
 }
 
+static void bta2dp_audio_focus_request_callback(bt_bdaddr_t *bd_addr) {
+    jbyteArray addr;
+
+    ALOGI("%s", __FUNCTION__);
+
+    if (!checkCallbackThread()) {                                       \
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__); \
+        return;                                                         \
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for connection state");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onAudioFocusRequested, addr);
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
 static btav_callbacks_t sBluetoothA2dpCallbacks = {
     sizeof(sBluetoothA2dpCallbacks),
     bta2dp_connection_state_callback,
     bta2dp_audio_state_callback,
-    bta2dp_audio_config_callback
+    bta2dp_audio_config_callback,
+    NULL,
+    NULL,
+    bta2dp_audio_focus_request_callback
 };
 
 static void classInitNative(JNIEnv* env, jclass clazz) {
@@ -137,10 +166,14 @@ static void classInitNative(JNIEnv* env, jclass clazz) {
     method_onAudioConfigChanged =
         env->GetMethodID(clazz, "onAudioConfigChanged", "([BII)V");
 
+    method_onAudioFocusRequested =
+        env->GetMethodID(clazz, "onAudioFocusRequested", "([B)V");
+
     ALOGI("%s: succeeds", __FUNCTION__);
 }
 
-static void initNative(JNIEnv *env, jobject object) {
+static void initNative(JNIEnv *env, jobject object, jint maxA2dpConnections,
+        jint multiCastState) {
     const bt_interface_t* btInf;
     bt_status_t status;
 
@@ -167,7 +200,8 @@ static void initNative(JNIEnv *env, jobject object) {
         return;
     }
 
-    if ( (status = sBluetoothA2dpInterface->init(&sBluetoothA2dpCallbacks)) != BT_STATUS_SUCCESS) {
+    if ( (status = sBluetoothA2dpInterface->init(&sBluetoothA2dpCallbacks,
+            maxA2dpConnections, multiCastState)) != BT_STATUS_SUCCESS) {
         ALOGE("Failed to initialize Bluetooth A2DP Sink, status: %d", status);
         sBluetoothA2dpInterface = NULL;
         return;
@@ -237,12 +271,19 @@ static jboolean disconnectA2dpNative(JNIEnv *env, jobject object, jbyteArray add
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+static void informAudioFocusStateNative(JNIEnv *env, jobject object, jint focus_state) {
+    if (!sBluetoothA2dpInterface) return;
+
+    sBluetoothA2dpInterface->audio_focus_state((uint8_t)focus_state);
+
+}
 static JNINativeMethod sMethods[] = {
     {"classInitNative", "()V", (void *) classInitNative},
-    {"initNative", "()V", (void *) initNative},
+    {"initNative", "(II)V", (void *) initNative},
     {"cleanupNative", "()V", (void *) cleanupNative},
     {"connectA2dpNative", "([B)Z", (void *) connectA2dpNative},
     {"disconnectA2dpNative", "([B)Z", (void *) disconnectA2dpNative},
+    {"informAudioFocusStateNative", "(I)V", (void *) informAudioFocusStateNative},
 };
 
 int register_com_android_bluetooth_a2dp_sink(JNIEnv* env)
diff --git a/jni/com_android_bluetooth_avrcp.cpp b/jni/com_android_bluetooth_avrcp.cpp
index ba1d78b..693847d 100644
--- a/jni/com_android_bluetooth_avrcp.cpp
+++ b/jni/com_android_bluetooth_avrcp.cpp
@@ -1,4 +1,7 @@
 /*
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -16,7 +19,7 @@
 
 #define LOG_TAG "BluetoothAvrcpServiceJni"
 
-#define LOG_NDEBUG 0
+//#define LOG_NDEBUG 0
 
 #include "com_android_bluetooth.h"
 #include "hardware/bt_rc.h"
@@ -28,12 +31,26 @@
 namespace android {
 static jmethodID method_getRcFeatures;
 static jmethodID method_getPlayStatus;
+static jmethodID method_onListPlayerAttributeRequest;
 static jmethodID method_getElementAttr;
 static jmethodID method_registerNotification;
 static jmethodID method_volumeChangeCallback;
 static jmethodID method_handlePassthroughCmd;
-
-static const btrc_interface_t *sBluetoothAvrcpInterface = NULL;
+static jmethodID method_handlePassthroughRsp;
+static jmethodID method_getFolderItems;
+static jmethodID method_setAddressedPlayer;
+static jmethodID method_setBrowsedPlayer;
+static jmethodID method_changePath;
+static jmethodID method_playItem;
+static jmethodID method_getItemAttr;
+static jmethodID method_onListPlayerAttributeValues;
+static jmethodID method_onGetPlayerAttributeValues;
+static jmethodID method_setPlayerAppSetting;
+static jmethodID method_getplayerattribute_text;
+static jmethodID method_getplayervalue_text;
+static jmethodID method_onConnectionStateChanged;
+
+static const btrc_interface_t *sBluetoothMultiAvrcpInterface = NULL;
 static jobject mCallbacksObj = NULL;
 static JNIEnv *sCallbackEnv = NULL;
 
@@ -50,7 +67,7 @@ static bool checkCallbackThread() {
 }
 
 static void btavrcp_remote_features_callback(bt_bdaddr_t* bd_addr, btrc_remote_features_t features) {
-    ALOGI("%s", __FUNCTION__);
+    ALOGV("%s", __FUNCTION__);
     jbyteArray addr;
 
     if (!checkCallbackThread()) {
@@ -59,47 +76,118 @@ static void btavrcp_remote_features_callback(bt_bdaddr_t* bd_addr, btrc_remote_f
     }
     addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
     if (!addr) {
-        ALOGE("Unable to allocate byte array for bd_addr");
+        ALOGE("Fail to new jbyteArray bd addr for remote features");
         checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
         return;
     }
 
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
     if (mCallbacksObj) {
-        sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getRcFeatures, addr, (jint)features);
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getRcFeatures, addr,
+                                                         (jint)features, addr);
     } else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+
+}
+
+static void btavrcp_get_play_status_callback(bt_bdaddr_t* bd_addr) {
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for get play status");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
 
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getPlayStatus, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
     sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void btavrcp_get_play_status_callback() {
-    ALOGI("%s", __FUNCTION__);
+static void btavrcp_get_player_seeting_value_callback(btrc_player_attr_t player_att,
+                                                     bt_bdaddr_t* bd_addr) {
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
 
     if (!checkCallbackThread()) {
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for player seeting");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
 
     if (mCallbacksObj) {
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getPlayStatus);
+        sCallbackEnv->CallVoidMethod(mCallbacksObj ,method_onListPlayerAttributeValues,
+                                    (jbyte)player_att, addr);
     } else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void btavrcp_get_element_attr_callback(uint8_t num_attr, btrc_media_attr_t *p_attrs) {
-    jintArray attrs;
+static void btavrcp_get_player_attribute_id_callback(bt_bdaddr_t* bd_addr) {
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
 
-    ALOGI("%s", __FUNCTION__);
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for player attribute");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj,method_onListPlayerAttributeRequest, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_getcurrent_player_app_setting_values( uint8_t num_attr,
+                                                          btrc_player_attr_t *p_attrs,
+                                                          bt_bdaddr_t* bd_addr) {
+    jintArray attrs;
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
 
     if (!checkCallbackThread()) {
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for player app setting");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
     attrs = (jintArray)sCallbackEnv->NewIntArray(num_attr);
     if (!attrs) {
         ALOGE("Fail to new jintArray for attrs");
@@ -107,189 +195,1605 @@ static void btavrcp_get_element_attr_callback(uint8_t num_attr, btrc_media_attr_
         return;
     }
     sCallbackEnv->SetIntArrayRegion(attrs, 0, num_attr, (jint *)p_attrs);
+
     if (mCallbacksObj) {
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getElementAttr, (jbyte)num_attr, attrs);
-    } else {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj,method_onGetPlayerAttributeValues,
+                                     (jbyte)num_attr,attrs, addr);
+    }
+    else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
     checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
     sCallbackEnv->DeleteLocalRef(attrs);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void btavrcp_register_notification_callback(btrc_event_id_t event_id, uint32_t param) {
+static void btavrcp_set_playerapp_setting_value_callback(btrc_player_settings_t *attr,
+                                                         bt_bdaddr_t* bd_addr)
+{
+    jbyteArray attrs_ids;
+    jbyteArray attrs_value;
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
+
     if (!checkCallbackThread()) {
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for set playerapp");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    attrs_ids   = (jbyteArray)sCallbackEnv->NewByteArray(attr->num_attr);
+    if (!attrs_ids) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(attrs_ids, 0, attr->num_attr, (jbyte *)attr->attr_ids);
+    attrs_value = (jbyteArray)sCallbackEnv->NewByteArray(attr->num_attr);
+    if (!attrs_value) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(attrs_value, 0, attr->num_attr, (jbyte *)attr->attr_values);
     if (mCallbacksObj) {
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_registerNotification,
-                                 (jint)event_id, (jint)param);
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_setPlayerAppSetting,
+                            (jbyte)attr->num_attr ,attrs_ids ,attrs_value, addr);
     } else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
-    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(attrs_ids);
+    sCallbackEnv->DeleteLocalRef(attrs_value);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void btavrcp_volume_change_callback(uint8_t volume, uint8_t ctype) {
-    ALOGI("%s", __FUNCTION__);
+static void btavrcp_getPlayer_app_attribute_text(uint8_t num , btrc_player_attr_t *att,
+                                                 bt_bdaddr_t* bd_addr)
+{
+    jbyteArray attrs;
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
 
     if (!checkCallbackThread()) {
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for getPlayer app");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    attrs   = (jbyteArray)sCallbackEnv->NewByteArray(num);
+    if (!attrs) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(attrs, 0, num, (jbyte *)att);
     if (mCallbacksObj) {
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_volumeChangeCallback, (jint)volume,
-                                                     (jint)ctype);
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getplayerattribute_text,
+                                     (jbyte) num ,attrs, addr);
     } else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
-
-    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(attrs);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void btavrcp_passthrough_command_callback(int id, int pressed) {
-    ALOGI("%s", __FUNCTION__);
+static void btavrcp_getPlayer_app_value_text(uint8_t attr_id , uint8_t num_val , uint8_t *value,
+                                             bt_bdaddr_t* bd_addr)
+{
+    jbyteArray Attr_Value ;
+    ALOGV("%s", __FUNCTION__);
+    jbyteArray addr;
 
     if (!checkCallbackThread()) {
         ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for getPlayer app");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    Attr_Value   = (jbyteArray)sCallbackEnv->NewByteArray(num_val);
+    if (!Attr_Value) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(Attr_Value, 0, num_val, (jbyte *)value);
     if (mCallbacksObj) {
-        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_handlePassthroughCmd,
-                      (jint)id, (jint)pressed);
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getplayervalue_text,(jbyte) attr_id,
+                                     (jbyte) num_val , Attr_Value, addr);
     } else {
         ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
-    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(Attr_Value);
 }
 
-static btrc_callbacks_t sBluetoothAvrcpCallbacks = {
-    sizeof(sBluetoothAvrcpCallbacks),
-    btavrcp_remote_features_callback,
-    btavrcp_get_play_status_callback,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    btavrcp_get_element_attr_callback,
-    btavrcp_register_notification_callback,
-    btavrcp_volume_change_callback,
-    btavrcp_passthrough_command_callback,
-};
-
-static void classInitNative(JNIEnv* env, jclass clazz) {
-    method_getRcFeatures =
-        env->GetMethodID(clazz, "getRcFeatures", "([BI)V");
-    method_getPlayStatus =
-        env->GetMethodID(clazz, "getPlayStatus", "()V");
-
-    method_getElementAttr =
-        env->GetMethodID(clazz, "getElementAttr", "(B[I)V");
-
-    method_registerNotification =
-        env->GetMethodID(clazz, "registerNotification", "(II)V");
-
-    method_volumeChangeCallback =
-        env->GetMethodID(clazz, "volumeChangeCallback", "(II)V");
+static void btavrcp_get_element_attr_callback(uint8_t num_attr, btrc_media_attr_t *p_attrs,
+                                              bt_bdaddr_t* bd_addr) {
+    jintArray attrs;
+    jbyteArray addr;
 
-    method_handlePassthroughCmd =
-        env->GetMethodID(clazz, "handlePassthroughCmd", "(II)V");
+    ALOGV("%s", __FUNCTION__);
 
-    ALOGI("%s: succeeds", __FUNCTION__);
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for element attr");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    attrs = (jintArray)sCallbackEnv->NewIntArray(num_attr);
+    if (!attrs) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetIntArrayRegion(attrs, 0, num_attr, (jint *)p_attrs);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getElementAttr, (jbyte)num_attr,
+                                    attrs, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(attrs);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void initNative(JNIEnv *env, jobject object) {
-    const bt_interface_t* btInf;
-    bt_status_t status;
+static void btavrcp_register_notification_callback(btrc_event_id_t event_id, uint32_t param,
+                                                   bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
 
-    if ( (btInf = getBluetoothInterface()) == NULL) {
-        ALOGE("Bluetooth module is not loaded");
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
-
-    if (sBluetoothAvrcpInterface !=NULL) {
-         ALOGW("Cleaning up Avrcp Interface before initializing...");
-         sBluetoothAvrcpInterface->cleanup();
-         sBluetoothAvrcpInterface = NULL;
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for register notification");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
     }
-
-    if (mCallbacksObj != NULL) {
-         ALOGW("Cleaning up Avrcp callback object");
-         env->DeleteGlobalRef(mCallbacksObj);
-         mCallbacksObj = NULL;
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_registerNotification,
+                                    (jint)event_id, (jint)param, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
 
-    if ( (sBluetoothAvrcpInterface = (btrc_interface_t *)
-          btInf->get_profile_interface(BT_PROFILE_AV_RC_ID)) == NULL) {
-        ALOGE("Failed to get Bluetooth Avrcp Interface");
+static void btavrcp_volume_change_callback(uint8_t volume, uint8_t ctype, bt_bdaddr_t* bd_addr) {
+
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
-
-    if ( (status = sBluetoothAvrcpInterface->init(&sBluetoothAvrcpCallbacks)) !=
-         BT_STATUS_SUCCESS) {
-        ALOGE("Failed to initialize Bluetooth Avrcp, status: %d", status);
-        sBluetoothAvrcpInterface = NULL;
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for volume change");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
         return;
     }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_volumeChangeCallback, (jint)volume,
+                                    (jint)ctype, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
 
-    mCallbacksObj = env->NewGlobalRef(object);
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-static void cleanupNative(JNIEnv *env, jobject object) {
-    const bt_interface_t* btInf;
+static void btavrcp_get_folder_items_callback(btrc_browse_folderitem_t scope ,
+                                                        btrc_getfolderitem_t *param,
+                                                        bt_bdaddr_t* bd_addr) {
+    jlong start = param->start_item;
+    jlong end = param->end_item;
+    jint size = param->size;
+    jint num_attr = param->attr_count;
+    jintArray attrs;
+    jbyteArray addr;
 
-    if ( (btInf = getBluetoothInterface()) == NULL) {
-        ALOGE("Bluetooth module is not loaded");
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
         return;
     }
-
-    if (sBluetoothAvrcpInterface !=NULL) {
-        sBluetoothAvrcpInterface->cleanup();
-        sBluetoothAvrcpInterface = NULL;
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for get folder items");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
     }
-
-    if (mCallbacksObj != NULL) {
-        env->DeleteGlobalRef(mCallbacksObj);
-        mCallbacksObj = NULL;
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (num_attr == 0xff) {
+        num_attr = 0; // 0xff signifies no attribute required in response
+    } else if (num_attr == 0) {
+        num_attr = 7; // 0x00 signifies all attributes required in response
     }
-}
 
-static jboolean getPlayStatusRspNative(JNIEnv *env, jobject object, jint playStatus,
-                                       jint songLen, jint songPos) {
-    bt_status_t status;
+    attrs = (jintArray)sCallbackEnv->NewIntArray(num_attr);
+    if (!attrs) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetIntArrayRegion(attrs, 0, num_attr, (jint *)param->attrs);
 
-    ALOGI("%s: sBluetoothAvrcpInterface: %p", __FUNCTION__, sBluetoothAvrcpInterface);
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+    ALOGV("%s", __FUNCTION__);
+    ALOGI("scope: %d", scope);
+    ALOGI("start entry: %d", start);
+    ALOGI("end entry: %d", end);
+    ALOGI("size: %d", size);
 
-    if ((status = sBluetoothAvrcpInterface->get_play_status_rsp((btrc_play_status_t)playStatus,
-                                            songLen, songPos)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed get_play_status_rsp, status: %d", status);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getFolderItems, (jbyte)scope,
+                                     start, end, size, num_attr, attrs, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
     }
 
-    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(attrs);
+    sCallbackEnv->DeleteLocalRef(addr);
 }
 
-  static jboolean getElementAttrRspNative(JNIEnv *env, jobject object, jbyte numAttr,
-                                          jintArray attrIds, jobjectArray textArray) {
-    jint *attr;
-    bt_status_t status;
-    jstring text;
-    int i;
-    btrc_element_attr_val_t *pAttrs = NULL;
-    const char* textStr;
-
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+static void btavrcp_passthrough_command_callback(int id, int pressed , bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
 
-    if (numAttr > BTRC_MAX_ELEM_ATTR_SIZE) {
-        ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
-        return JNI_FALSE;
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
     }
-
-    pAttrs = new btrc_element_attr_val_t[numAttr];
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for passthrough command");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_handlePassthroughCmd, (jint)id,
+                                     (jint)pressed, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_set_addressed_player_callback(uint32_t player_id, bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
+    ALOGV("player id: %d", player_id);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for set addressed player");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_setAddressedPlayer, (jint)player_id,
+                                     addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_set_browsed_player_callback(uint32_t player_id, bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
+    ALOGV("player id: %d", player_id);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for set browsed player");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_setBrowsedPlayer, (jint)player_id,
+                                     addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_change_path_callback(uint8_t direction, uint64_t uid, bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
+    ALOGV("direction: %d, uid: %lu", direction, uid);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for change path");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_changePath, (jbyte)direction,
+                                     (jlong)uid, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_play_item_callback(uint8_t scope, uint64_t uid, bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+    ALOGV("%s", __FUNCTION__);
+    ALOGV("scope: %d, uid: %lu", scope, uid);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for play item");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_playItem, (jbyte)scope, (jlong)uid,
+                                     addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_get_item_attr_callback(uint8_t scope, uint64_t uid,
+                                    uint8_t num_attr, btrc_media_attr_t *p_attrs,
+                                    bt_bdaddr_t* bd_addr) {
+    jintArray attrs;
+    jbyteArray addr;
+
+    if (num_attr == 0xff) {
+        num_attr = 0; // 0xff signifies no attribute required in response
+    } else if (num_attr == 0) {
+        num_attr = 7; // 0x00 signifies all attributes required in response
+    }
+
+    ALOGV("%s", __FUNCTION__);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for get item attr");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    attrs = (jintArray)sCallbackEnv->NewIntArray(num_attr);
+    if (!attrs) {
+        ALOGE("Fail to new jintArray for attrs");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+    sCallbackEnv->SetIntArrayRegion(attrs, 0, num_attr, (jint *)p_attrs);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_getItemAttr, (jbyte)scope, (jlong)uid,
+                                     (jbyte)num_attr, attrs, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(attrs);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+static void btavrcp_connection_state_callback(bool state, bt_bdaddr_t* bd_addr) {
+    jbyteArray addr;
+
+    ALOGI("%s", __FUNCTION__);
+    ALOGI("conn state: %d", state);
+
+    if (!checkCallbackThread()) {
+        ALOGE("Callback: '%s' is not called on the correct thread", __FUNCTION__);
+        return;
+    }
+
+    addr = sCallbackEnv->NewByteArray(sizeof(bt_bdaddr_t));
+    if (!addr) {
+        ALOGE("Fail to new jbyteArray bd addr for connection state");
+        checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+        return;
+    }
+
+    sCallbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte*) bd_addr);
+    if (mCallbacksObj) {
+        sCallbackEnv->CallVoidMethod(mCallbacksObj, method_onConnectionStateChanged,
+                                            (jboolean) state, addr);
+    } else {
+        ALOGE("%s: mCallbacksObj is null", __FUNCTION__);
+    }
+    checkAndClearExceptionFromCallback(sCallbackEnv, __FUNCTION__);
+    sCallbackEnv->DeleteLocalRef(addr);
+}
+
+
+static btrc_callbacks_t sBluetoothAvrcpCallbacks = {
+    sizeof(sBluetoothAvrcpCallbacks),
+    btavrcp_remote_features_callback,
+    btavrcp_get_play_status_callback,
+    btavrcp_get_player_attribute_id_callback,
+    btavrcp_get_player_seeting_value_callback,
+    btavrcp_getcurrent_player_app_setting_values,
+    btavrcp_getPlayer_app_attribute_text,
+    btavrcp_getPlayer_app_value_text,
+    btavrcp_set_playerapp_setting_value_callback,
+    btavrcp_get_element_attr_callback,
+    btavrcp_register_notification_callback,
+    btavrcp_volume_change_callback,
+    btavrcp_passthrough_command_callback,
+    btavrcp_get_folder_items_callback,
+    btavrcp_set_addressed_player_callback,
+    btavrcp_set_browsed_player_callback,
+    btavrcp_change_path_callback,
+    btavrcp_play_item_callback,
+    btavrcp_get_item_attr_callback,
+    btavrcp_connection_state_callback
+};
+
+static void classInitNative(JNIEnv* env, jclass clazz) {
+    method_getRcFeatures =
+        env->GetMethodID(clazz, "getRcFeatures", "([BI)V");
+    method_getPlayStatus =
+        env->GetMethodID(clazz, "getPlayStatus", "([B)V");
+    method_onListPlayerAttributeRequest =
+        env->GetMethodID(clazz , "onListPlayerAttributeRequest" , "([B)V");
+    method_onListPlayerAttributeValues =
+        env->GetMethodID(clazz , "onListPlayerAttributeValues" , "(B[B)V");
+    method_getElementAttr =
+        env->GetMethodID(clazz, "getElementAttr", "(B[I[B)V");
+    method_setPlayerAppSetting =
+        env->GetMethodID(clazz, "setPlayerAppSetting","(B[B[B[B)V");
+    method_getplayerattribute_text =
+        env->GetMethodID(clazz, "getplayerattribute_text" , "(B[B[B)V");
+    method_getplayervalue_text =
+        env->GetMethodID(clazz, "getplayervalue_text" , "(BB[B[B)V");
+    method_registerNotification =
+        env->GetMethodID(clazz, "registerNotification", "(II[B)V");
+    method_onGetPlayerAttributeValues =
+        env->GetMethodID(clazz, "onGetPlayerAttributeValues", "(B[I[B)V");
+    method_volumeChangeCallback =
+        env->GetMethodID(clazz, "volumeChangeCallback", "(II[B)V");
+    method_handlePassthroughCmd =
+        env->GetMethodID(clazz, "handlePassthroughCmd", "(II[B)V");
+    //setAddressedPlayer: attributes to pass: Player ID
+    method_setAddressedPlayer =
+        env->GetMethodID(clazz, "setAddressedPlayer", "(I[B)V");
+    //getFolderItems: attributes to pass: Scope, Start, End, Attr Cnt
+    method_getFolderItems =
+        env->GetMethodID(clazz, "getFolderItems", "(BJJII[I[B)V");
+    method_setBrowsedPlayer =
+        env->GetMethodID(clazz, "setBrowsedPlayer", "(I[B)V");
+    method_changePath =
+        env->GetMethodID(clazz, "changePath", "(BJ[B)V");
+    method_playItem =
+        env->GetMethodID(clazz, "playItem", "(BJ[B)V");
+    method_getItemAttr =
+        env->GetMethodID(clazz, "getItemAttr", "(BJB[I[B)V");
+    method_onConnectionStateChanged =
+        env->GetMethodID(clazz, "onConnectionStateChanged", "(Z[B)V");
+    ALOGV("%s: succeeds", __FUNCTION__);
+}
+
+static void initNative(JNIEnv *env, jobject object,
+        jint maxAvrcpConnections) {
+    const bt_interface_t* btInf;
+    bt_status_t status;
+
+    if ( (btInf = getBluetoothInterface()) == NULL) {
+        ALOGE("Bluetooth module is not loaded");
+        return;
+    }
+
+    if (sBluetoothMultiAvrcpInterface !=NULL) {
+         ALOGW("Cleaning up Avrcp Interface before initializing...");
+         sBluetoothMultiAvrcpInterface->cleanup();
+         sBluetoothMultiAvrcpInterface = NULL;
+    }
+
+    if (mCallbacksObj != NULL) {
+         ALOGW("Cleaning up Avrcp callback object");
+         env->DeleteGlobalRef(mCallbacksObj);
+         mCallbacksObj = NULL;
+    }
+
+    if ( (sBluetoothMultiAvrcpInterface = (btrc_interface_t *)
+          btInf->get_profile_interface(BT_PROFILE_AV_RC_ID)) == NULL) {
+        ALOGE("Failed to get Bluetooth Avrcp Interface");
+        return;
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->init(&sBluetoothAvrcpCallbacks,
+            maxAvrcpConnections)) !=
+         BT_STATUS_SUCCESS) {
+        ALOGE("Failed to initialize Bluetooth Avrcp, status: %d", status);
+        sBluetoothMultiAvrcpInterface = NULL;
+        return;
+    }
+
+    mCallbacksObj = env->NewGlobalRef(object);
+}
+
+static void cleanupNative(JNIEnv *env, jobject object) {
+    const bt_interface_t* btInf;
+
+    if ( (btInf = getBluetoothInterface()) == NULL) {
+        ALOGE("Bluetooth module is not loaded");
+        return;
+    }
+
+    if (sBluetoothMultiAvrcpInterface !=NULL) {
+        sBluetoothMultiAvrcpInterface->cleanup();
+        sBluetoothMultiAvrcpInterface = NULL;
+    }
+
+    if (mCallbacksObj != NULL) {
+        env->DeleteGlobalRef(mCallbacksObj);
+        mCallbacksObj = NULL;
+    }
+}
+
+static jboolean getPlayStatusRspNative(JNIEnv *env, jobject object, jint playStatus,
+                                       jint songLen, jint songPos, jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->get_play_status_rsp((btrc_play_status_t)playStatus,
+                                            songLen, songPos,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_play_status_rsp, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean getListPlayerappAttrRspNative(JNIEnv *env ,jobject object , jbyte numAttr,
+                                              jbyteArray attrIds , jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_player_attr_t *pAttrs = NULL;
+    int i;
+    jbyte *attr;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    if( numAttr > BTRC_MAX_APP_ATTR_SIZE) {
+        ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    ALOGI("getListPlayerappAttrRspNative");
+    pAttrs = new btrc_player_attr_t[numAttr];
+    if (!pAttrs) {
+        ALOGE("getListPlayerappAttrRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    attr = env->GetByteArrayElements(attrIds, NULL);
+    if( !attr) {
+        delete[] pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE ;
+    }
+    for (i = 0; i < numAttr; ++i) {
+        pAttrs[i] = (btrc_player_attr_t)attr[i];
+    }
+    if (i < numAttr) {
+        delete[] pAttrs;
+        env->ReleaseByteArrayElements(attrIds, attr, 0);
+        return JNI_FALSE;
+    }
+    //Call Stack Method
+    if ((status = sBluetoothMultiAvrcpInterface->list_player_app_attr_rsp(numAttr, pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed list_player_app_attr_rsp, status: %d", status);
+    }
+    delete[] pAttrs;
+    env->ReleaseByteArrayElements(attrIds, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+
+static jboolean getPlayerAppValueRspNative(JNIEnv *env ,jobject object , jbyte numvalue,
+                                           jbyteArray value ,jbyteArray address)
+{
+    bt_status_t status;
+    jbyte *addr;
+    uint8_t *pAttrs = NULL;
+    int i;
+    jbyte *attr;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    if( numvalue > BTRC_MAX_APP_ATTR_SIZE) {
+        ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    pAttrs = new uint8_t[numvalue];
+    if (!pAttrs) {
+        ALOGE("getPlayerAppValueRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    attr = env->GetByteArrayElements(value, NULL);
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    if (!attr) {
+        delete[] pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    for (i = 0; i < numvalue; ++i) {
+        pAttrs[i] = (uint8_t)attr[i];
+    }
+    if (i < numvalue) {
+        delete[] pAttrs;
+        env->ReleaseByteArrayElements(value, attr, 0);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->list_player_app_value_rsp(numvalue, pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed list_player_app_value_rsp, status: %d", status);
+    }
+    delete[] pAttrs;
+    env->ReleaseByteArrayElements(value, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean SendCurrentPlayerValueRspNative(JNIEnv *env, jobject object ,
+                                                jbyte numattr ,jbyteArray value ,jbyteArray address) {
+    btrc_player_settings_t *pAttrs = NULL ;
+    bt_status_t status;
+    jbyte *addr;
+    int i;
+    jbyte *attr;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if( numattr > BTRC_MAX_APP_ATTR_SIZE || numattr == 0) {
+        ALOGE("SendCurrentPlayerValueRspNative: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    pAttrs = new btrc_player_settings_t;
+    if (!pAttrs) {
+        ALOGE("SendCurrentPlayerValueRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    attr = env->GetByteArrayElements(value, NULL);
+    if (!attr) {
+        delete pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    pAttrs->num_attr = numattr/2 ;
+    for(i =0 ; i < numattr; i+=2)
+    {
+        pAttrs->attr_ids[i/2]    =  attr[i];
+        pAttrs->attr_values[i/2] =  attr[i+1];
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->get_player_app_value_rsp(pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_player_app_value_rsp, status: %d", status);
+    }
+    delete pAttrs;
+    env->ReleaseByteArrayElements(value, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+
+//JNI Method called to Respond to PDU 0x14
+static jboolean SendSetPlayerAppRspNative(JNIEnv *env, jobject object,
+                                        jint attr_status, jbyteArray address)
+{
+    bt_status_t status;
+    jbyte *addr;
+    btrc_status_t player_rsp = (btrc_status_t) attr_status;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->set_player_app_value_rsp(player_rsp,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed set_player_app_value_rsp, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+
+//JNI Method Called to Respond to PDU 0x15
+static jboolean sendSettingsTextRspNative(JNIEnv *env, jobject object, jint num_attr,
+                                jbyteArray attr,jint length , jobjectArray textArray,
+                                jbyteArray address) {
+    btrc_player_setting_text_t *pAttrs = NULL;
+    bt_status_t status;
+    jbyte *addr;
+    int i;
+    jstring text;
+    const char* textStr;
+    jbyte *arr ;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if (num_attr > BTRC_MAX_ELEM_ATTR_SIZE) {
+        ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    pAttrs = new btrc_player_setting_text_t[num_attr];
+    if (!pAttrs) {
+        ALOGE("sendSettingsTextRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    arr = env->GetByteArrayElements(attr, NULL);
+    if (!arr) {
+        delete[] pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    for (i = 0; i < num_attr ; ++i) {
+        text = (jstring) env->GetObjectArrayElement(textArray, i);
+        textStr = env->GetStringUTFChars(text, NULL);
+        if (!textStr) {
+            ALOGE("get_element_attr_rsp: GetStringUTFChars return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+        pAttrs[i].id = arr[i];
+        if (strlen(textStr) >= BTRC_MAX_ATTR_STR_LEN) {
+            ALOGE("sendSettingsTextRspNative: string length exceed maximum");
+        }
+        strlcpy((char *)pAttrs[i].text, textStr, BTRC_MAX_ATTR_STR_LEN);
+        //Check out if release need to be done in for loop
+        env->ReleaseStringUTFChars(text, textStr);
+        env->DeleteLocalRef(text);
+    }
+    //Call Stack Methos to Respond PDU 0x16
+    if ((status = sBluetoothMultiAvrcpInterface->get_player_app_attr_text_rsp(num_attr, pAttrs,
+                                            (bt_bdaddr_t *)addr)) !=  BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_player_app_attr_text_rsp, status: %d", status);
+    }
+    delete[] pAttrs;
+    env->ReleaseByteArrayElements(attr, arr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+//JNI Method Called to respond to PDU 0x16
+static jboolean sendValueTextRspNative(JNIEnv *env, jobject object, jint num_attr,
+                                       jbyteArray attr, jint length , jobjectArray textArray,
+                                       jbyteArray address) {
+    btrc_player_setting_text_t *pAttrs = NULL;
+    bt_status_t status;
+    jbyte *addr;
+    int i;
+    jstring text ;
+    const char* textStr;
+    jbyte *arr ;
+
+    //ALOGE("sendValueTextRspNative");
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if (num_attr > BTRC_MAX_ELEM_ATTR_SIZE) {
+        ALOGE("sendValueTextRspNative: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    pAttrs = new btrc_player_setting_text_t[num_attr];
+    if (!pAttrs) {
+        ALOGE("sendValueTextRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    arr = env->GetByteArrayElements(attr, NULL);
+    if (!arr) {
+        delete[] pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    for (i = 0; i < num_attr ; ++i) {
+        text = (jstring) env->GetObjectArrayElement(textArray, i);
+        textStr = env->GetStringUTFChars(text, NULL);
+        if (!textStr) {
+            ALOGE("sendValueTextRspNative: GetStringUTFChars return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+        pAttrs[i].id = arr[i];
+        if (strlen(textStr) >= BTRC_MAX_ATTR_STR_LEN) {
+           ALOGE("sendValueTextRspNative: string length exceed maximum");
+        }
+        strlcpy((char *)pAttrs[i].text, textStr, BTRC_MAX_ATTR_STR_LEN);
+        env->ReleaseStringUTFChars(text, textStr);
+        env->DeleteLocalRef(text);
+    }
+    //Call Stack Method to Respond to PDU 0x16
+    if ((status = sBluetoothMultiAvrcpInterface->get_player_app_value_text_rsp(num_attr, pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_player_app_value_text_rsp, status: %d", status);
+    }
+    delete[] pAttrs;
+    env->ReleaseByteArrayElements(attr, arr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+  static jboolean getElementAttrRspNative(JNIEnv *env, jobject object, jbyte numAttr,
+                                          jintArray attrIds, jobjectArray textArray,
+                                          jbyteArray address) {
+    jint *attr;
+    bt_status_t status;
+    jbyte *addr;
+    jstring text;
+    int i;
+    btrc_element_attr_val_t *pAttrs = NULL;
+    const char* textStr;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if (numAttr > BTRC_MAX_ELEM_ATTR_SIZE) {
+        ALOGE("get_element_attr_rsp: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+
+    pAttrs = new btrc_element_attr_val_t[numAttr];
+    if (!pAttrs) {
+        ALOGE("get_element_attr_rsp: not have enough memeory");
+        return JNI_FALSE;
+    }
+
+    attr = env->GetIntArrayElements(attrIds, NULL);
+    if (!attr) {
+        delete[] pAttrs;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    for (i = 0; i < numAttr; ++i) {
+        text = (jstring) env->GetObjectArrayElement(textArray, i);
+        textStr = env->GetStringUTFChars(text, NULL);
+        if (!textStr) {
+            ALOGE("get_element_attr_rsp: GetStringUTFChars return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+
+        pAttrs[i].attr_id = attr[i];
+        if (strlen(textStr) >= BTRC_MAX_ATTR_STR_LEN) {
+            ALOGE("get_element_attr_rsp: string length exceed maximum");
+        }
+        strlcpy((char *)pAttrs[i].text, textStr, BTRC_MAX_ATTR_STR_LEN);
+        env->ReleaseStringUTFChars(text, textStr);
+        env->DeleteLocalRef(text);
+    }
+
+    if (i < numAttr) {
+        delete[] pAttrs;
+        env->ReleaseIntArrayElements(attrIds, attr, 0);
+        return JNI_FALSE;
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->get_element_attr_rsp(numAttr, pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_element_attr_rsp, status: %d", status);
+    }
+
+    delete[] pAttrs;
+    env->ReleaseIntArrayElements(attrIds, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationPlayerAppRspNative(JNIEnv *env, jobject object ,jint type,
+                                                jbyte numattr ,jbyteArray value ,
+                                                jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    int i;
+    jbyte *attr;
+    btrc_register_notification_t *param= NULL;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if( numattr > BTRC_MAX_APP_ATTR_SIZE || numattr == 0) {
+        ALOGE("registerNotificationPlayerAppRspNative: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+    param = new btrc_register_notification_t;
+
+    if (!param) {
+        ALOGE("registerNotificationPlayerAppRspNative: not have enough memeory");
+        return JNI_FALSE;
+    }
+    attr = env->GetByteArrayElements(value, NULL);
+    if (!attr) {
+        delete param;
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    param->player_setting.num_attr  = numattr/2;
+    for(i =0 ; i < numattr; i+=2)
+    {
+        param->player_setting.attr_ids[i/2] = attr[i];
+        param->player_setting.attr_values[i/2] =  attr[i+1];
+    }
+    //Call Stack Method
+    if ((status =
+                sBluetoothMultiAvrcpInterface->register_notification_rsp(
+                BTRC_EVT_APP_SETTINGS_CHANGED,
+                (btrc_notification_type_t)type,param,
+                (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed register_notification_rsp, status: %d", status);
+    }
+    delete param;
+    env->ReleaseByteArrayElements(value, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationRspPlayStatusNative(JNIEnv *env, jobject object,
+                                                        jint type, jint playStatus,
+                                                        jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_register_notification_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    param.play_status = (btrc_play_status_t)playStatus;
+    if ((status =
+                sBluetoothMultiAvrcpInterface->register_notification_rsp(
+                BTRC_EVT_PLAY_STATUS_CHANGED,
+                (btrc_notification_type_t)type, &param, (bt_bdaddr_t *)addr)) !=
+                BT_STATUS_SUCCESS) {
+        ALOGE("Failed register_notification_rsp play status, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationRspTrackChangeNative(JNIEnv *env, jobject object,
+                                                         jint type, jbyteArray track,
+                                                         jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_register_notification_t param;
+    jbyte *trk;
+    int i;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    trk = env->GetByteArrayElements(track, NULL);
+    if (!trk) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    for (i = 0; i < BTRC_UID_SIZE; ++i) {
+      param.track[i] = trk[i];
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->register_notification_rsp(BTRC_EVT_TRACK_CHANGE,
+                  (btrc_notification_type_t)type, &param, (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed register_notification_rsp track change, status: %d", status);
+    }
+
+    env->ReleaseByteArrayElements(track, trk, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationRspPlayPosNative(JNIEnv *env, jobject object,
+                                                    jint type, jint playPos,
+                                                    jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+
+    btrc_register_notification_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    param.song_pos = (uint32_t)playPos;
+    if ((status = sBluetoothMultiAvrcpInterface->register_notification_rsp(
+                  BTRC_EVT_PLAY_POS_CHANGED,
+                  (btrc_notification_type_t)type, &param, (bt_bdaddr_t *)addr)) !=
+                  BT_STATUS_SUCCESS) {
+        ALOGE("Failed register_notification_rsp play position, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean setVolumeNative(JNIEnv *env, jobject object, jint volume,
+                                jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+
+    //TODO: delete test code
+    ALOGV("%s: jint: %d, uint8_t: %u", __FUNCTION__, volume, (uint8_t) volume);
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->set_volume((uint8_t)volume,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed set_volume, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationRspAddressedPlayerChangedNative (JNIEnv *env,
+                                                            jobject object, jint type,
+                                                            jint playerId,
+                                                            jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_register_notification_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    ALOGV("playerId: %d", playerId);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    param.player_id = (uint16_t)playerId;
+    if ((status = sBluetoothMultiAvrcpInterface->register_notification_rsp(
+                   BTRC_EVT_ADDRESSED_PLAYER_CHANGED, (btrc_notification_type_t)type,
+                   &param, (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed registerNotificationRspAddressedPlayerChangedNative, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+
+}
+
+static jboolean registerNotificationRspAvailablePlayersChangedNative (JNIEnv *env,
+                                                                      jobject object, jint type,
+                                                                      jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_register_notification_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->register_notification_rsp(
+                   BTRC_EVT_AVAILABLE_PLAYERS_CHANGED, (btrc_notification_type_t)type,
+                   &param, (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed registerNotificationRspAvailablePlayersChangedNative, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean registerNotificationRspNowPlayingContentChangedNative(JNIEnv *env,
+                                                                    jobject object, jint type,
+                                                                    jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    btrc_register_notification_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->register_notification_rsp(
+            BTRC_EVT_NOW_PLAYING_CONTENT_CHANGED, (btrc_notification_type_t)type, &param,
+            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed registerNotificationRspNowPlayingContentChangedNative, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean getFolderItemsRspNative(JNIEnv *env, jobject object, jbyte statusCode,
+                            jlong numItems, jintArray itemType, jlongArray uid, jintArray type,
+                            jbyteArray playable, jobjectArray displayName, jbyteArray numAtt,
+                            jobjectArray attValues, jintArray attIds , jbyteArray address) {
+    bt_status_t status = BT_STATUS_SUCCESS;
+    jbyte *addr;
+    btrc_folder_list_entries_t param;
+    int32_t *itemTypeElements;
+    int64_t *uidElements;
+    int32_t *typeElements;
+    int8_t *playableElements;
+    jstring *displayNameElements;
+    int8_t *numAttElements;
+    jstring *attValuesElements;
+    int32_t *attIdsElements;
+    jint count;
+    jstring text;
+    const char* textStr;
+    jsize utfStringLength = 0;
+    int num_attr;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    param.status = statusCode;
+    param.uid_counter = 0;
+    param.item_count = numItems;
+
+    if (numItems > 0) {
+        itemTypeElements = env->GetIntArrayElements(itemType, NULL);
+        if (!itemTypeElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+
+        uidElements = env->GetLongArrayElements(uid, NULL);
+        if (!uidElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+
+        typeElements = env->GetIntArrayElements(type, NULL);
+        if (!typeElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+
+        playableElements = env->GetByteArrayElements(playable, NULL);
+        if (!playableElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+
+        numAttElements = env->GetByteArrayElements(numAtt, NULL);
+        if (!numAttElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+
+        attIdsElements = env->GetIntArrayElements(attIds, NULL);
+        if (!attIdsElements) {
+            jniThrowIOException(env, EINVAL);
+            return JNI_FALSE;
+        }
+    }
+
+    param.p_item_list = new btrc_folder_list_item_t[numItems];
+
+    for (count = 0; count < numItems; count++) {
+        param.p_item_list[count].item_type = (uint8_t)itemTypeElements[count];
+        ALOGI("getFolderItemsRspNative: item_type: %d", param.p_item_list[count].item_type);
+        if (itemTypeElements[count] == BTRC_TYPE_FOLDER) {
+            param.p_item_list[count].u.folder.uid = uidElements[count];
+            ALOGI("getFolderItemsRspNative: uid: %lu", param.p_item_list[count].u.folder.uid);
+            param.p_item_list[count].u.folder.type = (uint8_t)typeElements[count];
+            ALOGI("getFolderItemsRspNative: type: %d", param.p_item_list[count].u.folder.type);
+            param.p_item_list[count].u.folder.playable = playableElements[count];
+
+            text = (jstring) env->GetObjectArrayElement(displayName, count);
+            if (text == NULL) {
+                ALOGE("getFolderItemsRspNative: App string is NULL, bail out");
+                break;
+            }
+            utfStringLength = env->GetStringUTFLength(text);
+            if (!utfStringLength) {
+                ALOGE("getFolderItemsRspNative: GetStringUTFLength return NULL");
+                env->DeleteLocalRef(text);
+                break;
+            }
+            ALOGI("getFolderItemsRspNative: Disp Elem Length: %d", utfStringLength);
+
+            textStr = env->GetStringUTFChars(text, NULL);
+            if (!textStr) {
+                ALOGE("getFolderItemsRspNative: GetStringUTFChars return NULL");
+                env->DeleteLocalRef(text);
+                break;
+            }
+            param.p_item_list[count].u.folder.name.charset_id = BTRC_CHARSET_UTF8;
+            param.p_item_list[count].u.folder.name.str_len = utfStringLength;
+            param.p_item_list[count].u.folder.name.p_str = new uint8_t[utfStringLength + 1];
+            strlcpy((char *)param.p_item_list[count].u.folder.name.p_str, textStr,
+                                                                    utfStringLength + 1);
+            env->ReleaseStringUTFChars(text, textStr);
+            env->DeleteLocalRef(text);
+        } else if (itemTypeElements[count] == BTRC_TYPE_MEDIA_ELEMENT) {
+            num_attr = 0;
+            param.p_item_list[count].u.media.uid = uidElements[count];
+            ALOGI("getFolderItemsRspNative: uid: %l", param.p_item_list[count].u.folder.uid);
+            param.p_item_list[count].u.media.type = (uint8_t)typeElements[count];
+            ALOGI("getFolderItemsRspNative: type: %d", param.p_item_list[count].u.folder.type);
+            text = (jstring) env->GetObjectArrayElement(displayName, count);
+            if (text == NULL) {
+                ALOGE("getFolderItemsRspNative: App string is NULL, bail out");
+                break;
+            }
+            utfStringLength = env->GetStringUTFLength(text);
+            if (!utfStringLength) {
+                ALOGE("getFolderItemsRspNative: GetStringUTFLength return NULL");
+                env->DeleteLocalRef(text);
+                break;
+            }
+            ALOGI("getFolderItemsRspNative: Disp Elem Length: %d", utfStringLength);
+
+            textStr = env->GetStringUTFChars(text, NULL);
+            if (!textStr) {
+                ALOGE("getFolderItemsRspNative: GetStringUTFChars return NULL");
+                env->DeleteLocalRef(text);
+                break;
+            }
+            param.p_item_list[count].u.media.name.charset_id = BTRC_CHARSET_UTF8;
+            param.p_item_list[count].u.media.name.str_len = utfStringLength;
+            param.p_item_list[count].u.media.name.p_str = new uint8_t[utfStringLength + 1];
+            strlcpy((char *)param.p_item_list[count].u.media.name.p_str, textStr,
+                                                                    utfStringLength + 1);
+            env->ReleaseStringUTFChars(text, textStr);
+            env->DeleteLocalRef(text);
+            ALOGI("getFolderItemsRspNative: numAttr: %d", numAttElements[count]);
+            param.p_item_list[count].u.media.p_attr_list =
+                            new btrc_attr_entry_t[numAttElements[count]];
+
+            for (int i = 0; i < numAttElements[count]; i++) {
+                text = (jstring) env->GetObjectArrayElement(attValues, (7 * count) + i);
+                if (text == NULL) {
+                    ALOGE("getFolderItemsRspNative: Attribute string is NULL, continue to next");
+                    continue;
+                }
+                utfStringLength = env->GetStringUTFLength(text);
+                if (!utfStringLength) {
+                    ALOGE("getFolderItemsRspNative: GetStringUTFLength return NULL");
+                    env->DeleteLocalRef(text);
+                    continue;
+                }
+                textStr = env->GetStringUTFChars(text, NULL);
+                if (!textStr) {
+                    ALOGE("getFolderItemsRspNative: GetStringUTFChars return NULL");
+                    env->DeleteLocalRef(text);
+                    continue;
+                }
+                param.p_item_list[count].u.media.p_attr_list[num_attr].attr_id =
+                                                    attIdsElements[(7 * count) + i];
+                ALOGI("getFolderItemsRspNative: Attr id: %d",
+                    param.p_item_list[count].u.media.p_attr_list[num_attr].attr_id);
+                param.p_item_list[count].u.media.p_attr_list[num_attr].name.charset_id =
+                                                                        BTRC_CHARSET_UTF8;
+                param.p_item_list[count].u.media.p_attr_list[num_attr].name.str_len =
+                                                                        utfStringLength;
+                ALOGI("getFolderItemsRspNative: Attr Length: %d",
+                    param.p_item_list[count].u.media.p_attr_list[num_attr].name.str_len);
+                param.p_item_list[count].u.media.p_attr_list[num_attr].name.p_str =
+                                                            new uint8_t[utfStringLength + 1];
+                strlcpy((char *)param.p_item_list[count].u.media.p_attr_list[num_attr].
+                                                name.p_str, textStr, utfStringLength + 1);
+                num_attr++;
+                env->ReleaseStringUTFChars(text, textStr);
+                env->DeleteLocalRef(text);
+            }
+            param.p_item_list[count].u.media.attr_count = num_attr;
+            ALOGI("getFolderItemsRspNative: effective numAttr: %d",
+                            param.p_item_list[count].u.media.attr_count);
+        }
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->get_folder_items_rsp(&param,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_folder_items_rsp, status: %u", status);
+    }
+
+    if (numItems > 0) {
+        env->ReleaseIntArrayElements(itemType, itemTypeElements, 0);
+        env->ReleaseLongArrayElements(uid, uidElements, 0);
+        env->ReleaseIntArrayElements(type, typeElements, 0);
+        env->ReleaseByteArrayElements(playable, playableElements, 0);
+        env->ReleaseByteArrayElements(numAtt, numAttElements, 0);
+        env->ReleaseIntArrayElements(attIds, attIdsElements, 0);
+    }
+
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+// MediaPlayerItems are populated as byte stream from the apps
+static jboolean getMediaPlayerListRspNative(JNIEnv *env, jobject object, jbyte statusCode,
+                                    jint uidCounter, jint itemCount, jbyteArray folderItems,
+                                    jintArray folderItemLengths, jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+    int8_t *folderElements;
+    int32_t *folderElementLengths;
+    int32_t count = 0;
+    int32_t countElementLength = 0;
+    int32_t countTotalBytes = 0;
+    int32_t countTemp = 0;
+    int32_t checkLength = 0;
+    btrc_folder_list_entries_t param;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    folderElements = env->GetByteArrayElements(folderItems, NULL);
+    if (!folderElements) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    folderElementLengths = env->GetIntArrayElements(folderItemLengths, NULL);
+    if (!folderElementLengths) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+
+    param.status = statusCode;
+    param.uid_counter = uidCounter;
+    param.item_count = itemCount;
+    ALOGI("status: %d, item count: %d", param.status, param.item_count);
+    param.p_item_list = new btrc_folder_list_item_t[itemCount];
+    ALOGI("Intermediate List entries:");
+    for (; count < itemCount; count++) {
+        param.p_item_list[count].item_type = folderElements[countTotalBytes]; countTotalBytes++;
+        param.p_item_list[count].u.player.player_id =
+            (uint16_t)(folderElements[countTotalBytes] & 0x00ff); countTotalBytes++;
+        param.p_item_list[count].u.player.player_id +=
+            (uint16_t)((folderElements[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+        param.p_item_list[count].u.player.major_type =
+            folderElements[countTotalBytes]; countTotalBytes++;
+        param.p_item_list[count].u.player.sub_type =
+            (uint32_t)(folderElements[countTotalBytes] & 0x000000ff); countTotalBytes++;
+        param.p_item_list[count].u.player.sub_type +=
+            (uint32_t)((folderElements[countTotalBytes] << 8) & 0x0000ff00); countTotalBytes++;
+        param.p_item_list[count].u.player.sub_type +=
+            (uint32_t)((folderElements[countTotalBytes] << 16) & 0x00ff0000); countTotalBytes++;
+        param.p_item_list[count].u.player.sub_type +=
+            (uint32_t)((folderElements[countTotalBytes] << 24) & 0xff000000); countTotalBytes++;
+        param.p_item_list[count].u.player.play_status =
+            folderElements[countTotalBytes]; countTotalBytes++;
+        for (countTemp = 0; countTemp < 16; countTemp ++) {
+            param.p_item_list[count].u.player.features[countTemp] =
+                    folderElements[countTotalBytes]; countTotalBytes++;
+        }
+        param.p_item_list[count].u.player.name.charset_id =
+            (uint16_t)(folderElements[countTotalBytes] & 0x00ff); countTotalBytes++;
+        param.p_item_list[count].u.player.name.charset_id +=
+            (uint16_t)((folderElements[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+        param.p_item_list[count].u.player.name.str_len =
+            (uint16_t)(folderElements[countTotalBytes] & 0x00ff); countTotalBytes++;
+        param.p_item_list[count].u.player.name.str_len +=
+            (uint16_t)((folderElements[countTotalBytes] << 8) & 0xff00); countTotalBytes++;
+        param.p_item_list[count].u.player.name.p_str =
+            new uint8_t[param.p_item_list[count].u.player.name.str_len];
+        for (countTemp = 0; countTemp < param.p_item_list[count].u.player.name.str_len;
+                                                                        countTemp ++) {
+            param.p_item_list[count].u.player.name.p_str[countTemp] =
+                        folderElements[countTotalBytes]; countTotalBytes++;
+        }
+        /*To check if byte feeding went well*/
+        checkLength += folderElementLengths[count];
+        if (checkLength != countTotalBytes) {
+            ALOGE("Error Populating Intermediate Folder Entry");
+            ALOGE("checkLength = %u countTotalBytes = %u", checkLength, countTotalBytes);
+        }
+        ALOGI("entry: %u", count);
+        ALOGI("item type: %u", param.p_item_list[count].item_type);
+        ALOGI("player id: %u", param.p_item_list[count].u.player.player_id);
+        ALOGI("major type: %u", param.p_item_list[count].u.player.major_type);
+        ALOGI("sub type: %u", param.p_item_list[count].u.player.sub_type);
+        ALOGI("play status: %u", param.p_item_list[count].u.player.play_status);
+        ALOGI("features: ");
+        for (countTemp = 0; countTemp < 16; countTemp ++)
+            ALOGI("%u", param.p_item_list[count].u.player.features[countTemp]);
+        ALOGI("charset id: %u", param.p_item_list[count].u.player.name.charset_id);
+        ALOGI("name len: %u", param.p_item_list[count].u.player.name.str_len);
+        ALOGI("name: ");
+        for (countTemp = 0; countTemp < param.p_item_list[count].u.player.name.str_len;
+                                                                            countTemp ++) {
+            ALOGI("%u", param.p_item_list[count].u.player.name.p_str[countTemp]);
+        }
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->get_folder_items_rsp(&param,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed getMediaPlayerListRspNative, status: %u", status);
+    }
+
+    env->ReleaseByteArrayElements(folderItems, folderElements, 0);
+    env->ReleaseIntArrayElements(folderItemLengths, folderElementLengths, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean setAdressedPlayerRspNative(JNIEnv *env, jobject object, jbyte statusCode,
+                                            jbyteArray address) {
+    bt_status_t status;
+    jbyte *addr;
+
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if ((status = sBluetoothMultiAvrcpInterface->set_addressed_player_rsp((btrc_status_t)statusCode,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed setAdressedPlayerRspNative, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+}
+
+static jboolean getItemAttrRspNative(JNIEnv *env, jobject object, jbyte numAttr,
+                                     jintArray attrIds, jobjectArray textArray,
+                                     jbyteArray address) {
+    jint *attr;
+    jbyte *addr;
+    bt_status_t status;
+    jstring text;
+    int i;
+    btrc_element_attr_val_t *pAttrs = NULL;
+    const char* textStr;
+    jsize utfStringLength = 0;
+
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
+    }
+    if (numAttr > BTRC_MAX_ELEM_ATTR_SIZE) {
+        ALOGE("get_item_attr_rsp: number of attributes exceed maximum");
+        return JNI_FALSE;
+    }
+
+    pAttrs = new btrc_element_attr_val_t[numAttr];
     if (!pAttrs) {
-        ALOGE("get_element_attr_rsp: not have enough memeory");
+        ALOGE("get_item_attr_rsp: not have enough memeory");
         return JNI_FALSE;
     }
 
@@ -302,21 +1806,26 @@ static jboolean getPlayStatusRspNative(JNIEnv *env, jobject object, jint playSta
 
     for (i = 0; i < numAttr; ++i) {
         text = (jstring) env->GetObjectArrayElement(textArray, i);
+
+        utfStringLength = env->GetStringUTFLength(text);
+        if (!utfStringLength) {
+            ALOGE("setBrowsedPlayerRspNative: GetStringUTFLength return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+
         textStr = env->GetStringUTFChars(text, NULL);
         if (!textStr) {
-            ALOGE("get_element_attr_rsp: GetStringUTFChars return NULL");
+            ALOGE("get_item_attr_rsp: GetStringUTFChars return NULL");
             env->DeleteLocalRef(text);
             break;
         }
 
         pAttrs[i].attr_id = attr[i];
-        if (strlen(textStr) >= BTRC_MAX_ATTR_STR_LEN) {
-            ALOGE("get_element_attr_rsp: string length exceed maximum");
-            strncpy((char *)pAttrs[i].text, textStr, BTRC_MAX_ATTR_STR_LEN-1);
-            pAttrs[i].text[BTRC_MAX_ATTR_STR_LEN-1] = 0;
-        } else {
-            strcpy((char *)pAttrs[i].text, textStr);
+        if (utfStringLength >= BTRC_MAX_ATTR_STR_LEN) {
+            ALOGE("get_item_attr_rsp: string length exceed maximum");
         }
+        strlcpy((char *)pAttrs[i].text, textStr, BTRC_MAX_ATTR_STR_LEN);
         env->ReleaseStringUTFChars(text, textStr);
         env->DeleteLocalRef(text);
     }
@@ -327,108 +1836,200 @@ static jboolean getPlayStatusRspNative(JNIEnv *env, jobject object, jint playSta
         return JNI_FALSE;
     }
 
-    if ((status = sBluetoothAvrcpInterface->get_element_attr_rsp(numAttr, pAttrs)) !=
-        BT_STATUS_SUCCESS) {
-        ALOGE("Failed get_element_attr_rsp, status: %d", status);
+    if ((status = sBluetoothMultiAvrcpInterface->get_item_attr_rsp(numAttr, pAttrs,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed get_item_attr_rsp, status: %d", status);
     }
 
     delete[] pAttrs;
     env->ReleaseIntArrayElements(attrIds, attr, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
-static jboolean registerNotificationRspPlayStatusNative(JNIEnv *env, jobject object,
-                                                        jint type, jint playStatus) {
+static jboolean setBrowsedPlayerRspNative(JNIEnv *env, jobject object,
+                                          jbyte statusCode, jint uidCounter,
+                                          jint itemCount, jint folderDepth,
+                                          jint charId, jobjectArray folderNames,
+                                          jbyteArray address) {
     bt_status_t status;
-    btrc_register_notification_t param;
+    jbyte *addr;
+    int32_t count = 0;
+    jstring text;
+    const char* textStr;
+    jsize utfStringLength = 0;
 
-    ALOGI("%s: sBluetoothAvrcpInterface: %p", __FUNCTION__, sBluetoothAvrcpInterface);
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+    btrc_set_browsed_player_rsp_t param;
 
-    param.play_status = (btrc_play_status_t)playStatus;
-    if ((status = sBluetoothAvrcpInterface->register_notification_rsp(BTRC_EVT_PLAY_STATUS_CHANGED,
-                  (btrc_notification_type_t)type, &param)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed register_notification_rsp play status, status: %d", status);
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
+
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
     }
+    param.status = statusCode;
+    param.uid_counter = uidCounter;
+    param.num_items = itemCount;
+    param.charset_id = charId;
+    param.folder_depth = folderDepth;
+
+    ALOGI("statusCode: %d", statusCode);
+    ALOGI("uidCounter: %d", uidCounter);
+    ALOGI("itemCount: %d", itemCount);
+    ALOGI("charId: %d", charId);
+    ALOGI("folderDepth: %d", folderDepth);
+
+    param.p_folders = new btrc_name_t[folderDepth];
+
+    for (count = 0; count < folderDepth; ++count) {
+        text = (jstring) env->GetObjectArrayElement(folderNames, count);
+
+        utfStringLength = env->GetStringUTFLength(text);
+        if (!utfStringLength) {
+            ALOGE("setBrowsedPlayerRspNative: GetStringUTFLength return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+
+        textStr = env->GetStringUTFChars(text, NULL);
+        if (!textStr) {
+            ALOGE("setBrowsedPlayerRspNative: GetStringUTFChars return NULL");
+            env->DeleteLocalRef(text);
+            break;
+        }
+
+        param.p_folders[count].str_len = utfStringLength;
+        param.p_folders[count].p_str = new uint8_t[utfStringLength + 1];
+        strlcpy((char *)param.p_folders[count].p_str, textStr, utfStringLength + 1);
+        env->ReleaseStringUTFChars(text, textStr);
+        env->DeleteLocalRef(text);
 
+    }
+
+    if ((status = sBluetoothMultiAvrcpInterface->set_browsed_player_rsp(&param,
+                                            (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed setBrowsedPlayerRspNative, status: %u", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
-static jboolean registerNotificationRspTrackChangeNative(JNIEnv *env, jobject object,
-                                                         jint type, jbyteArray track) {
+static jboolean changePathRspNative(JNIEnv *env, jobject object, jint errStatus, jlong itemCount,
+                                    jbyteArray address) {
     bt_status_t status;
-    btrc_register_notification_t param;
-    jbyte *trk;
-    int i;
+    jbyte *addr;
 
-    ALOGI("%s: sBluetoothAvrcpInterface: %p", __FUNCTION__, sBluetoothAvrcpInterface);
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
 
-    trk = env->GetByteArrayElements(track, NULL);
-    if (!trk) {
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
         jniThrowIOException(env, EINVAL);
         return JNI_FALSE;
     }
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    ALOGV("status: %d, itemCount: %l", errStatus, itemCount);
 
-    for (i = 0; i < BTRC_UID_SIZE; ++i) {
-      param.track[i] = trk[i];
-    }
-
-    if ((status = sBluetoothAvrcpInterface->register_notification_rsp(BTRC_EVT_TRACK_CHANGE,
-                  (btrc_notification_type_t)type, &param)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed register_notification_rsp track change, status: %d", status);
+    if ((status = sBluetoothMultiAvrcpInterface->change_path_rsp((uint8_t)errStatus,
+                                        (uint32_t)itemCount,
+                                        (bt_bdaddr_t *)addr)) != BT_STATUS_SUCCESS) {
+        ALOGE("Failed sending change path response, status: %d", status);
     }
-
-    env->ReleaseByteArrayElements(track, trk, 0);
+    env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
-static jboolean registerNotificationRspPlayPosNative(JNIEnv *env, jobject object,
-                                                        jint type, jint playPos) {
+static jboolean playItemRspNative(JNIEnv *env, jobject object, jint errStatus,
+                                  jbyteArray address) {
     bt_status_t status;
-    btrc_register_notification_t param;
+    jbyte *addr;
 
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
 
-    param.song_pos = (uint32_t)playPos;
-    if ((status = sBluetoothAvrcpInterface->register_notification_rsp(BTRC_EVT_PLAY_POS_CHANGED,
-                  (btrc_notification_type_t)type, &param)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed register_notification_rsp play position, status: %d", status);
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
     }
+    ALOGV("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
+    ALOGV("status: %d", errStatus);
 
+    if ((status = sBluetoothMultiAvrcpInterface->play_item_rsp((uint8_t)errStatus,
+                                            (bt_bdaddr_t *)addr))!= BT_STATUS_SUCCESS) {
+        ALOGE("Failed sending play item response, status: %d", status);
+    }
+    env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
-static jboolean setVolumeNative(JNIEnv *env, jobject object, jint volume) {
-    bt_status_t status;
-
-    //TODO: delete test code
-    ALOGI("%s: jint: %d, uint8_t: %u", __FUNCTION__, volume, (uint8_t) volume);
+static jboolean isDeviceActiveInHandOffNative(JNIEnv *env, jobject object, jbyteArray address) {
+    bt_status_t status = BT_STATUS_SUCCESS;
+    jbyte *addr;
 
-    ALOGI("%s: sBluetoothAvrcpInterface: %p", __FUNCTION__, sBluetoothAvrcpInterface);
-    if (!sBluetoothAvrcpInterface) return JNI_FALSE;
+    if (!sBluetoothMultiAvrcpInterface) return JNI_FALSE;
 
-    if ((status = sBluetoothAvrcpInterface->set_volume((uint8_t)volume)) != BT_STATUS_SUCCESS) {
-        ALOGE("Failed set_volume, status: %d", status);
+    addr = env->GetByteArrayElements(address, NULL);
+    if (!addr) {
+        jniThrowIOException(env, EINVAL);
+        return JNI_FALSE;
     }
+    ALOGI("%s: sBluetoothMultiAvrcpInterface: %p", __FUNCTION__, sBluetoothMultiAvrcpInterface);
 
+    status = sBluetoothMultiAvrcpInterface->is_device_active_in_handoff((bt_bdaddr_t *)addr);
+
+    ALOGI("isDeviceActiveInHandOffNative: status: %d", status);
+
+    env->ReleaseByteArrayElements(address, addr, 0);
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+
+
 static JNINativeMethod sMethods[] = {
     {"classInitNative", "()V", (void *) classInitNative},
-    {"initNative", "()V", (void *) initNative},
+    {"initNative", "(I)V", (void *) initNative},
     {"cleanupNative", "()V", (void *) cleanupNative},
-    {"getPlayStatusRspNative", "(III)Z", (void *) getPlayStatusRspNative},
-    {"getElementAttrRspNative", "(B[I[Ljava/lang/String;)Z", (void *) getElementAttrRspNative},
-    {"registerNotificationRspPlayStatusNative", "(II)Z",
+    {"getPlayStatusRspNative", "(III[B)Z", (void *) getPlayStatusRspNative},
+    {"getElementAttrRspNative", "(B[I[Ljava/lang/String;[B)Z", (void *) getElementAttrRspNative},
+    {"getListPlayerappAttrRspNative", "(B[B[B)Z", (void *) getListPlayerappAttrRspNative},
+    {"getPlayerAppValueRspNative", "(B[B[B)Z", (void *) getPlayerAppValueRspNative},
+    {"registerNotificationRspPlayStatusNative", "(II[B)Z",
      (void *) registerNotificationRspPlayStatusNative},
-    {"registerNotificationRspTrackChangeNative", "(I[B)Z",
+    {"SendCurrentPlayerValueRspNative", "(B[B[B)Z",
+     (void *) SendCurrentPlayerValueRspNative},
+    {"registerNotificationPlayerAppRspNative", "(IB[B[B)Z",
+     (void *) registerNotificationPlayerAppRspNative},
+    {"registerNotificationRspTrackChangeNative", "(I[B[B)Z",
      (void *) registerNotificationRspTrackChangeNative},
-    {"registerNotificationRspPlayPosNative", "(II)Z",
+    {"SendSetPlayerAppRspNative", "(I[B)Z",
+     (void *) SendSetPlayerAppRspNative},
+    {"sendSettingsTextRspNative" , "(I[BI[Ljava/lang/String;[B)Z",
+     (void *) sendSettingsTextRspNative},
+    {"sendValueTextRspNative" , "(I[BI[Ljava/lang/String;[B)Z",
+     (void *) sendValueTextRspNative},
+    {"registerNotificationRspPlayPosNative", "(II[B)Z",
      (void *) registerNotificationRspPlayPosNative},
-    {"setVolumeNative", "(I)Z",
+    {"setVolumeNative", "(I[B)Z",
      (void *) setVolumeNative},
+    {"setAdressedPlayerRspNative", "(B[B)Z",
+     (void *) setAdressedPlayerRspNative},
+    {"getMediaPlayerListRspNative", "(BII[B[I[B)Z",
+     (void *) getMediaPlayerListRspNative},
+    {"registerNotificationRspAddressedPlayerChangedNative", "(II[B)Z",
+     (void *) registerNotificationRspAddressedPlayerChangedNative},
+    {"registerNotificationRspAvailablePlayersChangedNative", "(I[B)Z",
+     (void *) registerNotificationRspAvailablePlayersChangedNative},
+    {"registerNotificationRspNowPlayingContentChangedNative", "(I[B)Z",
+     (void *) registerNotificationRspNowPlayingContentChangedNative},
+    {"setBrowsedPlayerRspNative", "(BIIII[Ljava/lang/String;[B)Z",
+                                (void *) setBrowsedPlayerRspNative},
+    {"changePathRspNative", "(IJ[B)Z", (void *) changePathRspNative},
+    {"playItemRspNative", "(I[B)Z", (void *) playItemRspNative},
+    {"getItemAttrRspNative", "(B[I[Ljava/lang/String;[B)Z", (void *) getItemAttrRspNative},
+    {"getFolderItemsRspNative", "(BJ[I[J[I[B[Ljava/lang/String;[B[Ljava/lang/String;[I[B)Z",
+                                                            (void *) getFolderItemsRspNative},
+    {"isDeviceActiveInHandOffNative", "([B)Z", (void *) isDeviceActiveInHandOffNative},
 };
 
 int register_com_android_bluetooth_avrcp(JNIEnv* env)
diff --git a/jni/com_android_bluetooth_btservice_AdapterService.cpp b/jni/com_android_bluetooth_btservice_AdapterService.cpp
index e2af3dd..056d183 100755
--- a/jni/com_android_bluetooth_btservice_AdapterService.cpp
+++ b/jni/com_android_bluetooth_btservice_AdapterService.cpp
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2013 The Linux Foundation. All rights reserved
+ * Not a Contribution.
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -50,8 +52,8 @@ static const bt_interface_t *sBluetoothInterface = NULL;
 static const btsock_interface_t *sBluetoothSocketInterface = NULL;
 static JNIEnv *callbackEnv = NULL;
 
-static jobject sJniAdapterServiceObj;
-static jobject sJniCallbacksObj;
+static jobject sJniAdapterServiceObj = NULL;
+static jobject sJniCallbacksObj = NULL;
 static jfieldID sJniCallbacksField;
 
 
@@ -88,8 +90,12 @@ static void adapter_state_change_callback(bt_state_t status) {
     }
     ALOGV("%s: Status is: %d", __FUNCTION__, status);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);
+    if(sJniCallbacksObj) {
+       callbackEnv->CallVoidMethod(sJniCallbacksObj, method_stateChangeCallback, (jint)status);
 
+    } else {
+       ALOGE("JNI ERROR : JNI reference already cleaned : adapter_state_change_callback", __FUNCTION__);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
 }
 
@@ -167,8 +173,11 @@ static void adapter_properties_callback(bt_status_t status, int num_properties,
         return;
     }
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_adapterPropertyChangedCallback, types,
-                                props);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_adapterPropertyChangedCallback, types,
+
+                                    props);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(props);
     callbackEnv->DeleteLocalRef(types);
@@ -237,8 +246,11 @@ static void remote_device_properties_callback(bt_status_t status, bt_bdaddr_t *b
         return;
     }
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_devicePropertyChangedCallback, addr,
-                                types, props);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_devicePropertyChangedCallback, addr,
+
+                                    types, props);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(props);
     callbackEnv->DeleteLocalRef(types);
@@ -279,7 +291,9 @@ static void device_found_callback(int num_properties, bt_property_t *properties)
     remote_device_properties_callback(BT_STATUS_SUCCESS, (bt_bdaddr_t *)properties[addr_index].val,
                                       num_properties, properties);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_deviceFoundCallback, addr);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_deviceFoundCallback, addr);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(addr);
 }
@@ -303,8 +317,10 @@ static void bond_state_changed_callback(bt_status_t status, bt_bdaddr_t *bd_addr
     }
     callbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte *)bd_addr);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_bondStateChangeCallback, (jint) status,
-                                addr, (jint)state);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_bondStateChangeCallback, (jint) status,
+                                    addr, (jint)state);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(addr);
 }
@@ -329,8 +345,10 @@ static void acl_state_changed_callback(bt_status_t status, bt_bdaddr_t *bd_addr,
     }
     callbackEnv->SetByteArrayRegion(addr, 0, sizeof(bt_bdaddr_t), (jbyte *)bd_addr);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_aclStateChangeCallback, (jint) status,
-                                addr, (jint)state);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_aclStateChangeCallback, (jint) status,
+                                    addr, (jint)state);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(addr);
 }
@@ -344,9 +362,13 @@ static void discovery_state_changed_callback(bt_discovery_state_t state) {
 
     ALOGV("%s: DiscoveryState:%d ", __FUNCTION__, state);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_discoveryStateChangeCallback,
-                                (jint)state);
 
+
+
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_discoveryStateChangeCallback,
+                                    (jint)state);
+    }
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
 }
 
@@ -371,8 +393,10 @@ static void pin_request_callback(bt_bdaddr_t *bd_addr, bt_bdname_t *bdname, uint
 
     callbackEnv->SetByteArrayRegion(devname, 0, sizeof(bt_bdname_t), (jbyte*)bdname);
 
+    if (sJniCallbacksObj) {
     callbackEnv->CallVoidMethod(sJniCallbacksObj, method_pinRequestCallback, addr, devname, cod,
             min_16_digits);
+    }
 
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(addr);
@@ -405,8 +429,10 @@ static void ssp_request_callback(bt_bdaddr_t *bd_addr, bt_bdname_t *bdname, uint
     if (devname == NULL) goto Fail;
     callbackEnv->SetByteArrayRegion(devname, 0, sizeof(bt_bdname_t), (jbyte*)bdname);
 
-    callbackEnv->CallVoidMethod(sJniCallbacksObj, method_sspRequestCallback, addr, devname, cod,
-                                (jint) pairing_variant, pass_key);
+    if (sJniCallbacksObj) {
+        callbackEnv->CallVoidMethod(sJniCallbacksObj, method_sspRequestCallback, addr, devname, cod,
+                                    (jint) pairing_variant, pass_key);
+    }
 
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
     callbackEnv->DeleteLocalRef(addr);
@@ -454,9 +480,13 @@ static void energy_info_recv_callback(bt_activity_energy_info *p_energy_info)
        return;
     }
 
-    callbackEnv->CallVoidMethod(sJniAdapterServiceObj, method_energyInfo, p_energy_info->status,
-        p_energy_info->ctrl_state, p_energy_info->tx_time, p_energy_info->rx_time,
-        p_energy_info->idle_time, p_energy_info->energy_used);
+    if (sJniAdapterServiceObj) {
+        callbackEnv->CallVoidMethod(sJniAdapterServiceObj, method_energyInfo, p_energy_info->status,
+            p_energy_info->ctrl_state, p_energy_info->tx_time, p_energy_info->rx_time,
+            p_energy_info->idle_time, p_energy_info->energy_used);
+    } else {
+       ALOGE("JNI ERROR : JNI reference already cleaned : energy_info_recv_callback", __FUNCTION__);
+    }
 
     checkAndClearExceptionFromCallback(callbackEnv, __FUNCTION__);
 }
@@ -475,7 +505,8 @@ static bt_callbacks_t sBluetoothCallbacks = {
     callback_thread_event,
     dut_mode_recv_callback,
     le_test_mode_recv_callback,
-    energy_info_recv_callback
+    energy_info_recv_callback,
+    NULL
 };
 
 // The callback to call when the wake alarm fires.
@@ -495,6 +526,7 @@ static bool set_wake_alarm_callout(uint64_t delay_millis, bool should_wake,
     JNIEnv *env;
     JavaVM *vm = AndroidRuntime::getJavaVM();
     jint status = vm->GetEnv((void **)&env, JNI_VERSION_1_6);
+    jboolean ret = JNI_FALSE;
 
     if (status != JNI_OK && status != JNI_EDETACHED) {
         ALOGE("%s unable to get environment for JNI call", __func__);
@@ -510,9 +542,15 @@ static bool set_wake_alarm_callout(uint64_t delay_millis, bool should_wake,
     sAlarmCallbackData = data;
 
     jboolean jshould_wake = should_wake ? JNI_TRUE : JNI_FALSE;
-    jboolean ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_setWakeAlarm,
+    if (sJniAdapterServiceObj) {
+        ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_setWakeAlarm,
             (jlong)delay_millis, jshould_wake);
+    } else {
+       ALOGE("JNI ERROR : JNI reference already cleaned : set_wake_alarm_callout", __FUNCTION__);
+    }
+
     if (!ret) {
+        ALOGE("%s setWakeAlarm failed:ret= %d ", __func__,ret);
         sAlarmCallback = NULL;
         sAlarmCallbackData = NULL;
     }
@@ -540,8 +578,12 @@ static int acquire_wake_lock_callout(const char *lock_name) {
     jboolean ret = JNI_FALSE;
     jstring lock_name_jni = env->NewStringUTF(lock_name);
     if (lock_name_jni) {
-        ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_acquireWakeLock, lock_name_jni);
-        env->DeleteLocalRef(lock_name_jni);
+        if (sJniAdapterServiceObj) {
+            ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_acquireWakeLock, lock_name_jni);
+            env->DeleteLocalRef(lock_name_jni);
+        } else {
+            ALOGE("JNI ERROR : JNI reference already cleaned : acquire_wake_lock_callout", __FUNCTION__);
+        }
     } else {
         ALOGE("%s unable to allocate string: %s", __func__, lock_name);
     }
@@ -569,8 +611,12 @@ static int release_wake_lock_callout(const char *lock_name) {
     jboolean ret = JNI_FALSE;
     jstring lock_name_jni = env->NewStringUTF(lock_name);
     if (lock_name_jni) {
-        ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_releaseWakeLock, lock_name_jni);
-        env->DeleteLocalRef(lock_name_jni);
+        if (sJniAdapterServiceObj) {
+            ret = env->CallBooleanMethod(sJniAdapterServiceObj, method_releaseWakeLock, lock_name_jni);
+            env->DeleteLocalRef(lock_name_jni);
+        } else {
+            ALOGE("JNI ERROR : JNI reference already cleaned : release_wake_lock_callout", __FUNCTION__);
+        }
     } else {
         ALOGE("%s unable to allocate string: %s", __func__, lock_name);
     }
@@ -665,7 +711,7 @@ static bool initNative(JNIEnv* env, jobject obj) {
 
     if (sBluetoothInterface) {
         int ret = sBluetoothInterface->init(&sBluetoothCallbacks);
-        if (ret != BT_STATUS_SUCCESS) {
+        if (ret != BT_STATUS_SUCCESS && ret != BT_STATUS_DONE) {
             ALOGE("Error while setting the callbacks: %d\n", ret);
             sBluetoothInterface = NULL;
             return JNI_FALSE;
@@ -697,8 +743,37 @@ static bool cleanupNative(JNIEnv *env, jobject obj) {
     sBluetoothInterface->cleanup();
     ALOGI("%s: return from cleanup",__FUNCTION__);
 
-    env->DeleteGlobalRef(sJniCallbacksObj);
-    env->DeleteGlobalRef(sJniAdapterServiceObj);
+    if (sJniAdapterServiceObj) {
+        env->DeleteGlobalRef(sJniAdapterServiceObj);
+        sJniAdapterServiceObj = NULL;
+    }
+
+    if (sJniCallbacksObj) {
+        env->DeleteGlobalRef(sJniCallbacksObj);
+        sJniCallbacksObj = NULL;
+    }
+    return JNI_TRUE;
+}
+
+static bool ssrcleanupNative(JNIEnv *env, jobject obj, jboolean cleanup) {
+    ALOGV("%s:",__FUNCTION__);
+
+    jboolean result = JNI_FALSE;
+    if (!sBluetoothInterface) return result;
+
+    sBluetoothInterface->ssrcleanup();
+    ALOGI("%s: return from cleanup",__FUNCTION__);
+    if (cleanup == JNI_TRUE) {
+        ALOGI("%s: SSR Cleanup - DISABLE Timeout   ",__FUNCTION__);
+        if (sJniCallbacksObj) {
+            env->DeleteGlobalRef(sJniCallbacksObj);
+            sJniCallbacksObj = NULL;
+        }
+        if (sJniAdapterServiceObj) {
+            env->DeleteGlobalRef(sJniAdapterServiceObj);
+            sJniAdapterServiceObj = NULL;
+        }
+    }
     return JNI_TRUE;
 }
 
@@ -981,6 +1056,67 @@ static jboolean setDevicePropertyNative(JNIEnv *env, jobject obj, jbyteArray add
     return result;
 }
 
+static int getSocketOptNative(JNIEnv *env, jobject obj, jint type, jint channel, jint optionName,
+                                        jbyteArray optionVal) {
+    ALOGV("%s:",__FUNCTION__);
+
+    jbyte *option_val = NULL;
+    int option_len;
+    bt_status_t status;
+
+    if (!sBluetoothSocketInterface) return -1;
+
+    option_val = env->GetByteArrayElements(optionVal, NULL);
+    if (option_val == NULL) {
+        ALOGE("getSocketOptNative :jniThrowIOException ");
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    if ( (status = sBluetoothSocketInterface->get_sock_opt((btsock_type_t)type, channel,
+         (btsock_option_type_t) optionName, (void *) option_val, &option_len)) !=
+                                                           BT_STATUS_SUCCESS) {
+        ALOGE("get_sock_opt failed: %d", status);
+        goto Fail;
+    }
+    env->ReleaseByteArrayElements(optionVal, option_val, 0);
+
+    return option_len;
+Fail:
+    env->ReleaseByteArrayElements(optionVal, option_val, 0);
+    return -1;
+}
+
+static int setSocketOptNative(JNIEnv *env, jobject obj, jint type, jint channel, jint optionName,
+                                        jbyteArray optionVal, jint optionLen) {
+    ALOGV("%s:",__FUNCTION__);
+
+    jbyte *option_val = NULL;
+    bt_status_t status;
+
+    if (!sBluetoothSocketInterface) return -1;
+
+    option_val = env->GetByteArrayElements(optionVal, NULL);
+    if (option_val == NULL) {
+        ALOGE("setSocketOptNative:jniThrowIOException ");
+        jniThrowIOException(env, EINVAL);
+        return -1;
+    }
+
+    if ( (status = sBluetoothSocketInterface->set_sock_opt((btsock_type_t)type, channel,
+         (btsock_option_type_t) optionName, (void *) option_val, optionLen)) !=
+                                                         BT_STATUS_SUCCESS) {
+        ALOGE("set_sock_opt failed: %d", status);
+        goto Fail;
+    }
+    env->ReleaseByteArrayElements(optionVal, option_val, 0);
+
+    return 0;
+Fail:
+    env->ReleaseByteArrayElements(optionVal, option_val, 0);
+    return -1;
+}
+
 static jboolean getRemoteServicesNative(JNIEnv *env, jobject obj, jbyteArray address) {
     ALOGV("%s:",__FUNCTION__);
 
@@ -1129,11 +1265,33 @@ static jboolean factoryResetNative(JNIEnv *env, jobject obj) {
     return (ret == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+static void interopDatabaseClearNative(JNIEnv *env, jobject obj) {
+    ALOGV("%s()", __FUNCTION__);
+    if (!sBluetoothInterface) return;
+    sBluetoothInterface->interop_database_clear();
+}
+
+static void interopDatabaseAddNative(JNIEnv *env, jobject obj, int feature,
+                                      jbyteArray address, int length) {
+    ALOGV("%s()", __FUNCTION__);
+    if (!sBluetoothInterface) return;
+
+    jbyte *addr = env->GetByteArrayElements(address, NULL);
+    if (addr == NULL) {
+        jniThrowIOException(env, EINVAL);
+        return;
+    }
+
+    sBluetoothInterface->interop_database_add(feature, (bt_bdaddr_t *)addr, length);
+    env->ReleaseByteArrayElements(address, addr, 0);
+}
+
 static JNINativeMethod sMethods[] = {
     /* name, signature, funcPtr */
     {"classInitNative", "()V", (void *) classInitNative},
     {"initNative", "()Z", (void *) initNative},
     {"cleanupNative", "()V", (void*) cleanupNative},
+    {"ssrcleanupNative", "(Z)V", (void*) ssrcleanupNative},
     {"enableNative", "(Z)Z",  (void*) enableNative},
     {"disableNative", "()Z",  (void*) disableNative},
     {"setAdapterPropertyNative", "(I[B)Z", (void*) setAdapterPropertyNative},
@@ -1157,7 +1315,11 @@ static JNINativeMethod sMethods[] = {
     {"alarmFiredNative", "()V", (void *) alarmFiredNative},
     {"readEnergyInfo", "()I", (void*) readEnergyInfo},
     {"dumpNative", "(Ljava/io/FileDescriptor;)V", (void*) dumpNative},
-    {"factoryResetNative", "()Z", (void*)factoryResetNative}
+    {"factoryResetNative", "()Z", (void*)factoryResetNative},
+    {"getSocketOptNative", "(III[B)I", (void*) getSocketOptNative},
+    {"setSocketOptNative", "(III[BI)I", (void*) setSocketOptNative},
+    {"interopDatabaseClearNative", "()V", (void*) interopDatabaseClearNative},
+    {"interopDatabaseAddNative", "(I[BI)V", (void*) interopDatabaseAddNative}
 };
 
 int register_com_android_bluetooth_btservice_AdapterService(JNIEnv* env)
diff --git a/res/values-sk/cm_strings.xml b/res/values-sk/cm_strings.xml
new file mode 100644
index 0000000..25ce0db
--- /dev/null
+++ b/res/values-sk/cm_strings.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+    <!--
+        This is the short description of a permission associated with the
+        Bluetooth Avrcp Data Manager. It is displayed as part of the description of
+        any application that was granted that permission. This specific
+        permission controls access to the Bluetooth Avrcp Data Manager.
+    -->
+    <string name="permlab_bluetoothAvrcpDataManager">Prístup k AVRCP metadátam.</string>
+    <!--
+        This is the long description of a permission associated with the
+        Bluetooth Avrcp Data Manager. It is displayed as part of the description of
+        any application that was granted that permission. This specific
+        permission controls access to the Bluetooth Avrcp Data Manager.
+    -->
+    <string name="permdesc_bluetoothAvrcpDataManager">Dáva aplikácii prístup k AVRCP metadátam a pre ich následné zobrazenie.</string>
+
+    <string name="upload_fail_waiting">Nedá sa odoslať súbor, skúšam znova\u2026</string>
+</resources>
diff --git a/res/values/cm_strings.xml b/res/values/cm_strings.xml
new file mode 100644
index 0000000..fb74e21
--- /dev/null
+++ b/res/values/cm_strings.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2015 The CyanogenMod Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+    <!--
+        This is the short description of a permission associated with the
+        Bluetooth Avrcp Data Manager. It is displayed as part of the description of
+        any application that was granted that permission. This specific
+        permission controls access to the Bluetooth Avrcp Data Manager.
+    -->
+    <string name="permlab_bluetoothAvrcpDataManager">Access AVRCP metadata.</string>
+    <!--
+        This is the long description of a permission associated with the
+        Bluetooth Avrcp Data Manager. It is displayed as part of the description of
+        any application that was granted that permission. This specific
+        permission controls access to the Bluetooth Avrcp Data Manager.
+    -->
+    <string name="permdesc_bluetoothAvrcpDataManager">Allows the app to access the Bluetooth AVRCP metadata and use it to display on UI.</string>
+
+    <string name="upload_fail_waiting">Unable to send file, retrying\u2026</string>
+</resources>
diff --git a/src/com/android/bluetooth/OolConnManager.java b/src/com/android/bluetooth/OolConnManager.java
new file mode 100644
index 0000000..55d26e5
--- /dev/null
+++ b/src/com/android/bluetooth/OolConnManager.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *    * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *      from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.bluetooth;
+import java.util.UUID;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSocket;
+import android.util.Log;
+import java.io.IOException;
+import android.bluetooth.SdpOppOpsRecord;
+public class OolConnManager {
+
+    private static final String TAG="OolConnManager";
+    static int channel = 0;
+    static boolean sdpDone = false;
+    static String mAddress;
+
+    public static BluetoothSocket CreateL2capConnection(BluetoothDevice remBtDev,UUID uuid ) {
+
+        Log.d(TAG,"createL2cConnection "+remBtDev.getAddress());
+        try {
+            return remBtDev.createL2capSocket(channel);
+        } catch (IOException e) {
+            Log.e(TAG, "BtSocket Connect error " + e.getMessage());
+        }
+        return null;
+    }
+
+    public static void setSdpInitiatedAddress(BluetoothDevice remBtDev) {
+
+        if (remBtDev != null)
+            mAddress = remBtDev.getAddress();
+        else
+            mAddress = null;
+        Log.d(TAG,"setSdpInitiatedAddress "+ mAddress);
+
+    }
+
+    public static int getL2cPSM(BluetoothDevice remBtDev) {
+
+        int waitCount = 0;
+        int channelNo = -1;
+        while(!sdpDone && waitCount < 100) {
+           try {
+               Thread.sleep(100);
+           } catch (InterruptedException e) {
+               Log.e(TAG, "Interrupted", e);
+           }
+           waitCount++;
+        }
+        waitCount = 0;
+        sdpDone = false;
+
+        Log.d(TAG,"returning l2c channel as "+channel);
+        channelNo = channel;
+        channel = -1;
+        return channelNo;
+    }
+
+    public static void saveOppSdpRecord(SdpOppOpsRecord sdpRec, BluetoothDevice btDevice) {
+
+        Log.v(TAG,"saveOppSdpRecord"+ btDevice.getAddress());
+        if ((mAddress != null) && mAddress.equalsIgnoreCase(btDevice.getAddress())) {
+           channel = sdpRec != null ? sdpRec.getL2capPsm() : -1;
+           sdpDone = true;
+           Log.d(TAG,"saveOppSdpRecord channel "+ channel);
+        }
+    }
+
+}
diff --git a/src/com/android/bluetooth/a2dp/A2dpService.java b/src/com/android/bluetooth/a2dp/A2dpService.java
index e14302c..094766b 100755
--- a/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -22,8 +25,10 @@ import android.bluetooth.BluetoothUuid;
 import android.bluetooth.IBluetoothA2dp;
 import android.content.Context;
 import android.content.Intent;
+import android.media.AudioManager;
 import android.os.ParcelUuid;
 import android.provider.Settings;
+import android.os.SystemProperties;
 import android.util.Log;
 import com.android.bluetooth.avrcp.Avrcp;
 import com.android.bluetooth.btservice.ProfileService;
@@ -38,11 +43,12 @@ import java.util.Map;
  * @hide
  */
 public class A2dpService extends ProfileService {
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String TAG="A2dpService";
 
     private A2dpStateMachine mStateMachine;
     private Avrcp mAvrcp;
+    private AudioManager mAudioManager;
     private static A2dpService sAd2dpService;
     static final ParcelUuid[] A2DP_SOURCE_UUID = {
         BluetoothUuid.AudioSource
@@ -61,9 +67,28 @@ public class A2dpService extends ProfileService {
     }
 
     protected boolean start() {
-        mAvrcp = Avrcp.make(this);
-        mStateMachine = A2dpStateMachine.make(this, this);
+        int maxConnections = 1;
+        int multiCastState = 0;
+        int maxA2dpConnection =
+                SystemProperties.getInt("persist.bt.max.a2dp.connections", 1);
+        int a2dpMultiCastState =
+                SystemProperties.getInt("persist.bt.enable.multicast", 0);
+        if (a2dpMultiCastState == 1)
+                multiCastState = a2dpMultiCastState;
+        if (maxA2dpConnection == 2)
+                maxConnections = maxA2dpConnection;
+        // enable soft hands-off also when multicast is enabled.
+        if (multiCastState == 1 && maxConnections != 2) {
+            Log.i(TAG,"Enable soft handsoff as multicast is enabled");
+            maxConnections = 2;
+        }
+        log( "maxA2dpConnections = " + maxConnections);
+        log( "multiCastState = " + multiCastState);
+        mAvrcp = Avrcp.make(this, this, maxConnections);
+        mStateMachine = A2dpStateMachine.make(this, this,
+                maxConnections, multiCastState);
         setA2dpService(this);
+        mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
         return true;
     }
 
@@ -209,8 +234,43 @@ public class A2dpService extends ProfileService {
         mAvrcp.setAbsoluteVolume(volume);
     }
 
-    public void setAvrcpAudioState(int state) {
-        mAvrcp.setA2dpAudioState(state);
+    public void setAvrcpAudioState(int state, BluetoothDevice device) {
+        mAvrcp.setA2dpAudioState(state, device);
+    }
+
+    public List<BluetoothDevice> getA2dpPlayingDevice() {
+        return mStateMachine.getPlayingDevice();
+    }
+
+    public boolean isMulticastEnabled() {
+        return mStateMachine.isMulticastEnabled();
+    }
+
+    public boolean isMulticastFeatureEnabled() {
+        return mStateMachine.isMulticastFeatureEnabled();
+    }
+
+    // return status of multicast,needed for blocking outgoing connections
+    public boolean isMulticastOngoing(BluetoothDevice device) {
+
+        Log.i(TAG,"audio isMusicActive is " + mAudioManager.isMusicActive());
+        // we should never land is case where playing device size is bigger
+        // than 2 still have safe check.
+        if (device == null) {
+            if ((getA2dpPlayingDevice().size() >= 2) &&
+                    (mAudioManager.isMusicActive())) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+        if ((getA2dpPlayingDevice().size() >= 2) &&
+                mAudioManager.isMusicActive() &&
+                !(getA2dpPlayingDevice().contains(device))) {
+            return true;
+        } else {
+            return false;
+        }
     }
 
     synchronized boolean isA2dpPlaying(BluetoothDevice device) {
@@ -249,6 +309,11 @@ public class A2dpService extends ProfileService {
         public boolean connect(BluetoothDevice device) {
             A2dpService service = getService();
             if (service == null) return false;
+            //do not allow new connections with active multicast
+            if (service.isMulticastOngoing(device)) {
+                Log.i(TAG,"A2dp Multicast is Ongoing, ignore Connection Request");
+                return false;
+            }
             return service.connect(device);
         }
 
diff --git a/src/com/android/bluetooth/a2dp/A2dpSinkService.java b/src/com/android/bluetooth/a2dp/A2dpSinkService.java
index 5dcec73..8bfe076 100644
--- a/src/com/android/bluetooth/a2dp/A2dpSinkService.java
+++ b/src/com/android/bluetooth/a2dp/A2dpSinkService.java
@@ -20,6 +20,7 @@ import android.bluetooth.BluetoothAudioConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetoothA2dpSink;
+import android.provider.Settings;
 import android.util.Log;
 import com.android.bluetooth.btservice.ProfileService;
 import com.android.bluetooth.Utils;
@@ -32,7 +33,7 @@ import java.util.Map;
  * @hide
  */
 public class A2dpSinkService extends ProfileService {
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String TAG = "A2dpSinkService";
 
     private A2dpSinkStateMachine mStateMachine;
@@ -143,6 +144,36 @@ public class A2dpSinkService extends ProfileService {
         return mStateMachine.getConnectionState(device);
     }
 
+    public boolean setPriority(BluetoothDevice device, int priority) {
+        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                       "Need BLUETOOTH_ADMIN permission");
+        Settings.Global.putInt(getContentResolver(),
+            Settings.Global.getBluetoothA2dpSrcPriorityKey(device.getAddress()),
+            priority);
+        Log.d(TAG,"Saved priority " + device + " = " + priority);
+        return true;
+    }
+
+    public int getPriority(BluetoothDevice device) {
+        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
+                                       "Need BLUETOOTH_ADMIN permission");
+        int priority = Settings.Global.getInt(getContentResolver(),
+            Settings.Global.getBluetoothA2dpSrcPriorityKey(device.getAddress()),
+            BluetoothProfile.PRIORITY_UNDEFINED);
+        return priority;
+    }
+
+    public void informAvrcpStatePlaying(BluetoothDevice device) {
+        if(mStateMachine != null)
+            mStateMachine.informAvrcpStatePlaying(device);
+    }
+    synchronized boolean isA2dpPlaying(BluetoothDevice device) {
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM,
+                                       "Need BLUETOOTH permission");
+        Log.d(TAG, "isA2dpPlaying(" + device + ")");
+        return mStateMachine.isPlaying(device);
+    }
+
     BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getAudioConfig(device);
@@ -204,6 +235,24 @@ public class A2dpSinkService extends ProfileService {
             return service.getConnectionState(device);
         }
 
+        public boolean isA2dpPlaying(BluetoothDevice device) {
+            A2dpSinkService service = getService();
+            if (service == null) return false;
+            return service.isA2dpPlaying(device);
+        }
+
+        public boolean setPriority(BluetoothDevice device, int priority) {
+            A2dpSinkService service = getService();
+            if (service == null) return false;
+            return service.setPriority(device, priority);
+        }
+
+        public int getPriority(BluetoothDevice device) {
+            A2dpSinkService service = getService();
+            if (service == null) return BluetoothProfile.PRIORITY_UNDEFINED;
+            return service.getPriority(device);
+        }
+
         public BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
             A2dpSinkService service = getService();
             if (service == null) return null;
diff --git a/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java b/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
index d57a0ca..a614fbd 100644
--- a/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
+++ b/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
@@ -1,5 +1,8 @@
 /*
- * Copyright (C) 2014 The Android Open Source Project
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,18 +28,21 @@
  *                 CONNECTED |    | CONNECT
  *                           V    |
  *                        (Connected)
+ *                           |    ^
+ *  CONNECTING/DISCONNECTING |    | CONNECTED/DISCONNECTED
+ *                           V    |
+ *                  (MultiConnectionpending)
+
  */
 package com.android.bluetooth.a2dp;
 
-import android.bluetooth.BluetoothA2dpSink;
+import android.bluetooth.BluetoothA2dp;
 import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothAudioConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothUuid;
 import android.bluetooth.IBluetooth;
 import android.content.Context;
-import android.media.AudioFormat;
 import android.media.AudioManager;
 import android.os.Handler;
 import android.os.Message;
@@ -57,22 +63,40 @@ import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.HashMap;
 import java.util.Set;
 
-final class A2dpSinkStateMachine extends StateMachine {
-    private static final boolean DBG = false;
+final class A2dpStateMachine extends StateMachine {
+    private static final boolean DBG = true;
+    private static final String TAG="A2dpStateMachine";
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
     private static final int STACK_EVENT = 101;
     private static final int CONNECT_TIMEOUT = 201;
+    /* Allow time for possible LMP response timeout + Page timeout */
+    private static final int CONNECT_TIMEOUT_SEC = 38000;
+
+
+    // Max number of A2dp connections at any time
+    private int maxA2dpConnections = 1;
+
+    private static final int IS_INVALID_DEVICE = 0;
+    private static final int IS_VALID_DEVICE = 1;
+
+    // enable disable multicast
+    private static final int DISABLE_MULTICAST = 0;
+    private static final int ENABLE_MULTICAST = 1;
+    private static boolean isMultiCastEnabled = false;
+    private static boolean isScanDisabled = false;
+    private static boolean isMultiCastFeatureEnabled = false;
 
     private Disconnected mDisconnected;
     private Pending mPending;
     private Connected mConnected;
+    // Multi A2dp: add new class object
+    private MultiConnectionPending mMultiConnectionPending;
 
-    private A2dpSinkService mService;
+    private A2dpService mService;
     private Context mContext;
     private BluetoothAdapter mAdapter;
     private final AudioManager mAudioManager;
@@ -88,6 +112,9 @@ final class A2dpSinkStateMachine extends StateMachine {
     //                  and mTargetDevice are null
     //                when either mCurrentDevice or mTargetDevice is not null,
     //                  mIncomingDevice is null
+    // mMultiDisconnectDevice is the device for which disconnect is initiated
+    // in connected state.It is cleared when disconnected event is recieved
+    // from stack.
     // Stable states
     //   No connection, Disconnected state
     //                  both mCurrentDevice and mTargetDevice are null
@@ -103,77 +130,122 @@ final class A2dpSinkStateMachine extends StateMachine {
     //                        mCurrentDevice is not null, mTargetDevice is null
     //   Incoming connections Pending
     //                        Both mCurrentDevice and mTargetDevice are null
+    // MultiConnectionPending to hanle connection/disconnection for new device
+    // when already connected to one device
+
     private BluetoothDevice mCurrentDevice = null;
     private BluetoothDevice mTargetDevice = null;
     private BluetoothDevice mIncomingDevice = null;
-
-    private final HashMap<BluetoothDevice,BluetoothAudioConfig> mAudioConfigs
-            = new HashMap<BluetoothDevice,BluetoothAudioConfig>();
+    private BluetoothDevice mMultiDisconnectDevice = null;
+    // Multi A2dp: Connected devices list holds all currently connected headsets
+    private ArrayList<BluetoothDevice> mConnectedDevicesList =
+            new ArrayList<BluetoothDevice>();
+    private ArrayList<BluetoothDevice> mPlayingA2dpDevice =
+            new ArrayList<BluetoothDevice>();
 
     static {
         classInitNative();
     }
 
-    private A2dpSinkStateMachine(A2dpSinkService svc, Context context) {
-        super("A2dpSinkStateMachine");
+    private A2dpStateMachine(A2dpService svc, Context context, int
+            maxConnections, int multiCastState) {
+        super("A2dpStateMachine");
         mService = svc;
         mContext = context;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
+        maxA2dpConnections = maxConnections;
+        // By default isMultiCastEnabled is set to false, value changes based on stack update
+        isMultiCastEnabled = false;
+        if (multiCastState == 1) {
+            isMultiCastFeatureEnabled = true;
+        } else {
+            isMultiCastFeatureEnabled = false;
+        }
 
-        initNative();
+        initNative(maxA2dpConnections, multiCastState);
 
         mDisconnected = new Disconnected();
         mPending = new Pending();
         mConnected = new Connected();
+        // Multi A2dp: initialise new class variable
+        mMultiConnectionPending = new MultiConnectionPending();
 
         addState(mDisconnected);
         addState(mPending);
         addState(mConnected);
+        // Multi A2dp: add State
+        addState(mMultiConnectionPending);
 
         setInitialState(mDisconnected);
 
         PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
-        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpSinkService");
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpService");
 
         mIntentBroadcastHandler = new IntentBroadcastHandler();
 
         mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
     }
 
-    static A2dpSinkStateMachine make(A2dpSinkService svc, Context context) {
-        Log.d("A2dpSinkStateMachine", "make");
-        A2dpSinkStateMachine a2dpSm = new A2dpSinkStateMachine(svc, context);
+    static A2dpStateMachine make(A2dpService svc, Context context,
+             int maxConnections, int multiCastState) {
+        Log.d("A2dpStateMachine", "make");
+        A2dpStateMachine a2dpSm = new A2dpStateMachine(svc, context,
+                 maxConnections, multiCastState);
         a2dpSm.start();
         return a2dpSm;
     }
 
     public void doQuit() {
+        if ((mTargetDevice != null) &&
+            (getConnectionState(mTargetDevice) == BluetoothProfile.STATE_CONNECTING)) {
+            log("doQuit()- Move A2DP State to DISCONNECTED");
+            broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
+                                     BluetoothProfile.STATE_CONNECTING);
+        }
+
+        if ((mIncomingDevice!= null) &&
+            (getConnectionState(mIncomingDevice) == BluetoothProfile.STATE_CONNECTING)) {
+            log("doQuit()- Move A2DP State to DISCONNECTED");
+            broadcastConnectionState(mIncomingDevice, BluetoothProfile.STATE_DISCONNECTED,
+                                     BluetoothProfile.STATE_CONNECTING);
+        }
+
         quitNow();
     }
 
     public void cleanup() {
+        int deviceSize = mConnectedDevicesList.size();
+        log("cleanup: mConnectedDevicesList size is " + deviceSize);
+        for (int i = 0; i < deviceSize; i++) {
+             mCurrentDevice = mConnectedDevicesList.get(i);
+             broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED,
+                                      BluetoothProfile.STATE_CONNECTED);
+        }
         cleanupNative();
-        mAudioConfigs.clear();
-    }
-
-    public void dump(StringBuilder sb) {
-        ProfileService.println(sb, "mCurrentDevice: " + mCurrentDevice);
-        ProfileService.println(sb, "mTargetDevice: " + mTargetDevice);
-        ProfileService.println(sb, "mIncomingDevice: " + mIncomingDevice);
-        ProfileService.println(sb, "StateMachine: " + this.toString());
     }
 
-    private class Disconnected extends State {
+        private class Disconnected extends State {
         @Override
         public void enter() {
             log("Enter Disconnected: " + getCurrentMessage().what);
+            log("mConnectedDevicesList size: " + mConnectedDevicesList.size());
+            // Remove Timeout msg when moved to stable state
+            removeMessages(CONNECT_TIMEOUT);
+            mCurrentDevice = null;
         }
 
         @Override
         public boolean processMessage(Message message) {
             log("Disconnected process message: " + message.what);
-            if (mCurrentDevice != null || mTargetDevice != null  || mIncomingDevice != null) {
-                loge("ERROR: current, target, or mIncomingDevice not null in Disconnected");
+            log("mConnectedDevicesList size: " + mConnectedDevicesList.size());
+            if (mCurrentDevice != null || mTargetDevice != null  || mIncomingDevice != null
+                    || mConnectedDevicesList.size() != 0) {
+                loge("ERROR: mConnectedDevicesList is not empty," +
+                        "current, target, or mIncomingDevice not null in Disconnected");
+                loge("mCurrentDevice is " + mCurrentDevice);
+                loge("mTargetDevice is " + mTargetDevice);
+                loge("mIncomingDevice is " + mIncomingDevice);
+                loge("mConnectedDevicesList.size() is " + mConnectedDevicesList.size());
                 return NOT_HANDLED;
             }
 
@@ -190,13 +262,15 @@ final class A2dpSinkStateMachine extends StateMachine {
                         break;
                     }
 
-                    synchronized (A2dpSinkStateMachine.this) {
+                    synchronized (A2dpStateMachine.this) {
                         mTargetDevice = device;
                         transitionTo(mPending);
                     }
                     // TODO(BT) remove CONNECT_TIMEOUT when the stack
                     //          sends back events consistently
-                    sendMessageDelayed(CONNECT_TIMEOUT, 30000);
+                    Message m = obtainMessage(CONNECT_TIMEOUT);
+                    m.obj = device;
+                    sendMessageDelayed(m, CONNECT_TIMEOUT_SEC);
                     break;
                 case DISCONNECT:
                     // ignore
@@ -207,9 +281,6 @@ final class A2dpSinkStateMachine extends StateMachine {
                         case EVENT_TYPE_CONNECTION_STATE_CHANGED:
                             processConnectionEvent(event.valueInt, event.device);
                             break;
-                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
-                            processAudioConfigEvent(event.audioConfig, event.device);
-                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
@@ -228,16 +299,18 @@ final class A2dpSinkStateMachine extends StateMachine {
 
         // in Disconnected state
         private void processConnectionEvent(int state, BluetoothDevice device) {
+            log("processConnectionEvent state = " + state +
+                    ", device = " + device);
             switch (state) {
             case CONNECTION_STATE_DISCONNECTED:
-                logw("Ignore HF DISCONNECTED event, device: " + device);
+                logw("Ignore A2DP DISCONNECTED event, device: " + device);
                 break;
             case CONNECTION_STATE_CONNECTING:
-                if (okToConnect(device)){
+                if (okToConnect(device)) {
                     logi("Incoming A2DP accepted");
                     broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
                                              BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpSinkStateMachine.this) {
+                    synchronized (A2dpStateMachine.this) {
                         mIncomingDevice = device;
                         transitionTo(mPending);
                     }
@@ -249,20 +322,25 @@ final class A2dpSinkStateMachine extends StateMachine {
                     AdapterService adapterService = AdapterService.getAdapterService();
                     if (adapterService != null) {
                         adapterService.connectOtherProfile(device,
-                                                           AdapterService.PROFILE_CONN_REJECTED);
+                                AdapterService.PROFILE_CONN_REJECTED);
                     }
                 }
                 break;
             case CONNECTION_STATE_CONNECTED:
                 logw("A2DP Connected from Disconnected state");
-                if (okToConnect(device)){
+                if (okToConnect(device)) {
                     logi("Incoming A2DP accepted");
-                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
-                                             BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpSinkStateMachine.this) {
+                    synchronized (A2dpStateMachine.this) {
+                        if (!mConnectedDevicesList.contains(device)) {
+                            mConnectedDevicesList.add(device);
+                            log( "device " + device.getAddress() +
+                                    " is adding in Disconnected state");
+                        }
                         mCurrentDevice = device;
                         transitionTo(mConnected);
                     }
+                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                             BluetoothProfile.STATE_DISCONNECTED);
                 } else {
                     //reject the connection and stay in Disconnected state itself
                     logi("Incoming A2DP rejected");
@@ -276,7 +354,7 @@ final class A2dpSinkStateMachine extends StateMachine {
                 }
                 break;
             case CONNECTION_STATE_DISCONNECTING:
-                logw("Ignore HF DISCONNECTING event, device: " + device);
+                logw("Ignore A2dp DISCONNECTING event, device: " + device);
                 break;
             default:
                 loge("Incorrect state: " + state);
@@ -293,7 +371,8 @@ final class A2dpSinkStateMachine extends StateMachine {
 
         @Override
         public boolean processMessage(Message message) {
-            log("Pending process message: " + message.what);
+            log("Pending process message: " + message.what + ", size: "
+                    + mConnectedDevicesList.size());
 
             boolean retValue = HANDLED;
             switch(message.what) {
@@ -301,17 +380,29 @@ final class A2dpSinkStateMachine extends StateMachine {
                     deferMessage(message);
                     break;
                 case CONNECT_TIMEOUT:
+                    // This is always for Outgoing connection
+                    BluetoothDevice device = (BluetoothDevice) message.obj;
+                    // getByteAddress has no null check
+                    Log.v(TAG,"device for timeout is " + device);
+                    if (device != null && (mTargetDevice == null ||
+                            !mTargetDevice.equals(device))) {
+                        log("Timeout for unknown device " + device);
+                        onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
+                                getByteAddress(device));
+                        break;
+                    }
+                    disconnectA2dpNative(getByteAddress(mTargetDevice));
                     onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
                                              getByteAddress(mTargetDevice));
                     break;
                 case DISCONNECT:
-                    BluetoothDevice device = (BluetoothDevice) message.obj;
+                    BluetoothDevice dev = (BluetoothDevice) message.obj;
                     if (mCurrentDevice != null && mTargetDevice != null &&
-                        mTargetDevice.equals(device) ) {
+                        mTargetDevice.equals(dev) ) {
                         // cancel connection to the mTargetDevice
-                        broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                        broadcastConnectionState(dev, BluetoothProfile.STATE_DISCONNECTED,
                                        BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpSinkStateMachine.this) {
+                        synchronized (A2dpStateMachine.this) {
                             mTargetDevice = null;
                         }
                     } else {
@@ -322,12 +413,8 @@ final class A2dpSinkStateMachine extends StateMachine {
                     StackEvent event = (StackEvent) message.obj;
                     switch (event.type) {
                         case EVENT_TYPE_CONNECTION_STATE_CHANGED:
-                            removeMessages(CONNECT_TIMEOUT);
                             processConnectionEvent(event.valueInt, event.device);
                             break;
-                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
-                            processAudioConfigEvent(event.audioConfig, event.device);
-                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
@@ -341,97 +428,196 @@ final class A2dpSinkStateMachine extends StateMachine {
 
         // in Pending state
         private void processConnectionEvent(int state, BluetoothDevice device) {
+            log("processConnectionEvent state = " + state +
+                    ", device = " + device);
             switch (state) {
                 case CONNECTION_STATE_DISCONNECTED:
-                    mAudioConfigs.remove(device);
-                    if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
-                        broadcastConnectionState(mCurrentDevice,
-                                                 BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_DISCONNECTING);
-                        synchronized (A2dpSinkStateMachine.this) {
+                    // remove this device from playing device list
+                    if (mPlayingA2dpDevice.size() != 0 &&
+                            mPlayingA2dpDevice.contains(device)) {
+                        log ("Playing A2dp Device is disconnected, setting it to null");
+                        broadcastAudioState(device,
+                                BluetoothA2dp.STATE_NOT_PLAYING,
+                                BluetoothA2dp.STATE_PLAYING);
+                        mPlayingA2dpDevice.remove(device);
+                    }
+                    // Reset scan mode if it set due to multicast
+                    Log.i(TAG,"getScanMode " + mAdapter.getScanMode() +
+                        " isScanDisabled: " + isScanDisabled);
+                    if (mPlayingA2dpDevice.size() <= 1 &&
+                            (mAdapter.getScanMode() ==
+                            BluetoothAdapter.SCAN_MODE_NONE) &&
+                            isScanDisabled) {
+                        isScanDisabled = false;
+                        AdapterService adapterService =
+                                AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.restoreScanMode();
+                        }
+                    }
+                    if (mConnectedDevicesList.contains(device)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mConnectedDevicesList.remove(device);
+                            log( "device " + device.getAddress() +
+                                    " is removed in Pending state");
+                        }
+                        broadcastConnectionState(device,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_DISCONNECTING);
+                        synchronized (A2dpStateMachine.this) {
                             mCurrentDevice = null;
                         }
-
+                        log("disconnected for target in pending state " + mTargetDevice);
                         if (mTargetDevice != null) {
                             if (!connectA2dpNative(getByteAddress(mTargetDevice))) {
                                 broadcastConnectionState(mTargetDevice,
-                                                         BluetoothProfile.STATE_DISCONNECTED,
-                                                         BluetoothProfile.STATE_CONNECTING);
-                                synchronized (A2dpSinkStateMachine.this) {
+                                        BluetoothProfile.STATE_DISCONNECTED,
+                                        BluetoothProfile.STATE_CONNECTING);
+                                synchronized (A2dpStateMachine.this) {
                                     mTargetDevice = null;
                                     transitionTo(mDisconnected);
                                 }
                             }
                         } else {
-                            synchronized (A2dpSinkStateMachine.this) {
+                            synchronized (A2dpStateMachine.this) {
                                 mIncomingDevice = null;
-                                transitionTo(mDisconnected);
+                                if (mConnectedDevicesList.size() == 0) {
+                                    transitionTo(mDisconnected);
+                                } else {
+                                    processMultiA2dpDisconnected(device);
+                                }
                             }
                         }
                     } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
                         // outgoing connection failed
-                        broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpSinkStateMachine.this) {
+                        broadcastConnectionState(mTargetDevice,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        // check if there is some incoming connection request
+                        if (mIncomingDevice != null) {
+                            logi("disconnect for outgoing in pending state");
+                            synchronized (A2dpStateMachine.this) {
+                                mTargetDevice = null;
+                            }
+                            break;
+                        }
+                        synchronized (A2dpStateMachine.this) {
                             mTargetDevice = null;
-                            transitionTo(mDisconnected);
+                            if (mConnectedDevicesList.size() == 0) {
+                                transitionTo(mDisconnected);
+                            } else {
+                                transitionTo(mConnected);
+                            }
                         }
                     } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
                         broadcastConnectionState(mIncomingDevice,
-                                                 BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpSinkStateMachine.this) {
+                               BluetoothProfile.STATE_DISCONNECTED,
+                               BluetoothProfile.STATE_CONNECTING);
+                        // check if there is some outgoing connection request
+                        if (mTargetDevice != null) {
+                            logi("disconnect for incoming in pending state");
+                            synchronized (A2dpStateMachine.this) {
+                                mIncomingDevice = null;
+                            }
+                            break;
+                        }
+                        synchronized (A2dpStateMachine.this) {
                             mIncomingDevice = null;
-                            transitionTo(mDisconnected);
+                            if (mConnectedDevicesList.size() == 0) {
+                                transitionTo(mDisconnected);
+                            } else {
+                                transitionTo(mConnected);
+                            }
                         }
                     } else {
                         loge("Unknown device Disconnected: " + device);
                     }
                     break;
             case CONNECTION_STATE_CONNECTED:
-                if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
+                if (mConnectedDevicesList.contains(device)) {
                     // disconnection failed
-                    broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED,
-                                             BluetoothProfile.STATE_DISCONNECTING);
+                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                            BluetoothProfile.STATE_DISCONNECTING);
                     if (mTargetDevice != null) {
                         broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_CONNECTING);
+                                BluetoothProfile.STATE_CONNECTING);
                     }
-                    synchronized (A2dpSinkStateMachine.this) {
+                    synchronized (A2dpStateMachine.this) {
                         mTargetDevice = null;
                         transitionTo(mConnected);
                     }
                 } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
-                    broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_CONNECTED,
-                                             BluetoothProfile.STATE_CONNECTING);
-                    synchronized (A2dpSinkStateMachine.this) {
+                    synchronized (A2dpStateMachine.this) {
                         mCurrentDevice = mTargetDevice;
+                        mConnectedDevicesList.add(mTargetDevice);
                         mTargetDevice = null;
-                        transitionTo(mConnected);
+                        log( "device " + device.getAddress() +
+                                " is added in Pending state");
+                        if (mIncomingDevice == null ||
+                                (mIncomingDevice != null && !okToConnect(mIncomingDevice)))
+                            transitionTo(mConnected);
                     }
+                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                            BluetoothProfile.STATE_CONNECTING);
                 } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
-                    broadcastConnectionState(mIncomingDevice, BluetoothProfile.STATE_CONNECTED,
-                                             BluetoothProfile.STATE_CONNECTING);
-                    synchronized (A2dpSinkStateMachine.this) {
-                        mCurrentDevice = mIncomingDevice;
-                        mIncomingDevice = null;
-                        transitionTo(mConnected);
+                    // check for a2dp connection allowed for this device in race condition
+                    if (okToConnect(mIncomingDevice)) {
+                        logi("Ready to connect incoming Connection from pending state");
+                        synchronized (A2dpStateMachine.this) {
+                            mCurrentDevice = mIncomingDevice;
+                            mConnectedDevicesList.add(mIncomingDevice);
+                            mIncomingDevice = null;
+                            if (mTargetDevice == null)
+                                transitionTo(mConnected);
+                            log( "device " + device.getAddress() +
+                                    " is added in Pending state");
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                               BluetoothProfile.STATE_CONNECTING);
+                    } else {
+                        // A2dp connection unchecked for this device
+                        loge("Incoming A2DP rejected from pending state");
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                     AdapterService.PROFILE_CONN_REJECTED);
+                        }
                     }
                 } else {
                     loge("Unknown device Connected: " + device);
                     // something is wrong here, but sync our state with stack
-                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
-                                             BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpSinkStateMachine.this) {
-                        mCurrentDevice = device;
-                        mTargetDevice = null;
-                        mIncomingDevice = null;
-                        transitionTo(mConnected);
+                    if (okToConnect(device)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mConnectedDevicesList.add(device);
+                            if (mTargetDevice != null) {
+                                log("Waiting for Connected event for mTargetDevice");
+                            } else if (mIncomingDevice != null) {
+                                log("Waiting for Connected event for mIncomingDevice");
+                            }
+                            log( "device " + device.getAddress() +
+                                    " is added in Pending state");
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                    } else {
+                        //reject the connection and stay in Pending state itself
+                        Log.i(TAG,"Incoming A2dp rejected. priority=" +
+                                mService.getPriority(device) + " bondState=" +
+                                device.getBondState());
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                     AdapterService.PROFILE_CONN_REJECTED);
+                        }
                     }
                 }
                 break;
             case CONNECTION_STATE_CONNECTING:
-                if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
+                if (mConnectedDevicesList.contains(device)) {
                     log("current device tries to connect back");
                     // TODO(BT) ignore or reject
                 } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
@@ -440,12 +626,31 @@ final class A2dpSinkStateMachine extends StateMachine {
                     // we already broadcasted the intent, doing nothing here
                     log("Stack and target device are connecting");
                 }
-                else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
-                    loge("Another connecting event on the incoming device");
+                else if (mIncomingDevice != null) {
+                    if (mIncomingDevice.equals(device)) {
+                        loge("Connecting for same device");
+                    } else {
+                        log("Processing incoming " + mIncomingDevice +
+                                " Rejecting incoming " + device);
+                        disconnectA2dpNative(getByteAddress(device));
+                    }
                 } else {
                     // We get an incoming connecting request while Pending
                     // TODO(BT) is stack handing this case? let's ignore it for now
-                    log("Incoming connection while pending, ignore");
+                    log("Incoming connection while pending, accept it");
+                    if (okToConnect(device)) {
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                        mIncomingDevice = device;
+                    } else {
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                    AdapterService.PROFILE_CONN_REJECTED);
+                        }
+                    }
                 }
                 break;
             case CONNECTION_STATE_DISCONNECTING:
@@ -459,7 +664,7 @@ final class A2dpSinkStateMachine extends StateMachine {
                 } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
                     loge("IncomingDevice is getting disconnected");
                 } else {
-                    loge("Disconnecting unknown device: " + device);
+                    loge("Disconnecting unknow device: " + device);
                 }
                 break;
             default:
@@ -468,20 +673,46 @@ final class A2dpSinkStateMachine extends StateMachine {
             }
         }
 
+        private void processMultiA2dpDisconnected(BluetoothDevice device) {
+            log("Pending state: processMultiA2dpDisconnected");
+            /* Assign the current activedevice again if the disconnected
+            device equals to the current active device*/
+            if (mCurrentDevice != null && mCurrentDevice.equals(device)) {
+                int deviceSize = mConnectedDevicesList.size();
+                mCurrentDevice = mConnectedDevicesList.get(deviceSize-1);
+            }
+            transitionTo(mConnected);
+            log("processMultiA2dpDisconnected , the latest mCurrentDevice is:"
+                    + mCurrentDevice);
+            log("Pending state: processMultiA2dpDisconnected ," +
+                    "fake broadcasting for new mCurrentDevice");
+            broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED,
+                    BluetoothProfile.STATE_DISCONNECTED);
+        }
     }
 
     private class Connected extends State {
         @Override
         public void enter() {
-            log("Enter Connected: " + getCurrentMessage().what);
+            // Remove pending connection attempts that were deferred during the pending
+            // state. This is to prevent auto connect attempts from disconnecting
+            // devices that previously successfully connected.
+            // TODO: This needs to check for multiple A2DP connections, once supported...
+            log("Enter Connected: " + getCurrentMessage().what +
+                    ", size: " + mConnectedDevicesList.size());
+            // remove timeout for connected device only.
+            if (getDeviceForMessage(CONNECT_TIMEOUT) == null) {
+                removeMessages(CONNECT_TIMEOUT);
+            }
             // Upon connected, the audio starts out as stopped
-            broadcastAudioState(mCurrentDevice, BluetoothA2dpSink.STATE_NOT_PLAYING,
-                                BluetoothA2dpSink.STATE_PLAYING);
+            broadcastAudioState(mCurrentDevice, BluetoothA2dp.STATE_NOT_PLAYING,
+                                BluetoothA2dp.STATE_PLAYING);
         }
 
         @Override
         public boolean processMessage(Message message) {
-            log("Connected process message: " + message.what);
+            log("Connected process message: " + message.what +
+                     ", size: " + mConnectedDevicesList.size());
             if (mCurrentDevice == null) {
                 loge("ERROR: mCurrentDevice is null in Connected");
                 return NOT_HANDLED;
@@ -492,38 +723,83 @@ final class A2dpSinkStateMachine extends StateMachine {
                 case CONNECT:
                 {
                     BluetoothDevice device = (BluetoothDevice) message.obj;
-                    if (mCurrentDevice.equals(device)) {
+                    if (device == null) {
+                        Log.e(TAG,"device is NULL");
                         break;
                     }
-
-                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
-                                   BluetoothProfile.STATE_DISCONNECTED);
-                    if (!disconnectA2dpNative(getByteAddress(mCurrentDevice))) {
-                        broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
-                                       BluetoothProfile.STATE_CONNECTING);
+                    if (mConnectedDevicesList.contains(device)) {
+                        Log.e(TAG, "ERROR: Connect received for already connected device, Ignore");
                         break;
                     }
-
-                    synchronized (A2dpSinkStateMachine.this) {
-                        mTargetDevice = device;
-                        transitionTo(mPending);
+                    if (mConnectedDevicesList.size() >= maxA2dpConnections) {
+                        BluetoothDevice disconnectConnectedDevice = null;
+                        log( "Reach to max size, disconnect one of them first");
+                        disconnectConnectedDevice = mConnectedDevicesList.get(0);
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                        if (!disconnectA2dpNative(getByteAddress(disconnectConnectedDevice))) {
+                            broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_CONNECTING);
+                            break;
+                        } else {
+                            broadcastConnectionState(disconnectConnectedDevice,
+                                    BluetoothProfile.STATE_DISCONNECTING,
+                                    BluetoothProfile.STATE_CONNECTED);
+                        }
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = device;
+                            if (maxA2dpConnections == 1) {
+                                transitionTo(mPending);
+                            } else {
+                                mMultiDisconnectDevice = disconnectConnectedDevice;
+                                transitionTo(mMultiConnectionPending);
+                            }
+                            disconnectConnectedDevice = null;
+                        }
+                    } else if (mConnectedDevicesList.size() < maxA2dpConnections) {
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                        if (!connectA2dpNative(getByteAddress(device))) {
+                            broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_CONNECTING);
+                            break;
+                        }
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = device;
+                            // Transtion to MultiConnectionPending state for
+                            // Multi A2dp connection
+                            transitionTo(mMultiConnectionPending);
+                        }
                     }
+                    Message m = obtainMessage(CONNECT_TIMEOUT);
+                    m.obj = device;
+                    sendMessageDelayed(m, CONNECT_TIMEOUT_SEC);
+
                 }
                     break;
                 case DISCONNECT:
                 {
                     BluetoothDevice device = (BluetoothDevice) message.obj;
-                    if (!mCurrentDevice.equals(device)) {
+                    if (!mConnectedDevicesList.contains(device)) {
+                        log("device not connected " + device);
                         break;
                     }
+                    /* do not remove playing device here, wait for
+                     * disconnected event from stack to remove from palying
+                     * device.*/
                     broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTING,
-                                   BluetoothProfile.STATE_CONNECTED);
+                            BluetoothProfile.STATE_CONNECTED);
                     if (!disconnectA2dpNative(getByteAddress(device))) {
                         broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
-                                       BluetoothProfile.STATE_DISCONNECTED);
+                                BluetoothProfile.STATE_DISCONNECTING);
                         break;
                     }
-                    transitionTo(mPending);
+                    if (mConnectedDevicesList.size() > 1) {
+                        mMultiDisconnectDevice = device;
+                        transitionTo(mMultiConnectionPending);
+                    } else {
+                        transitionTo(mPending);
+                    }
                 }
                     break;
                 case STACK_EVENT:
@@ -535,14 +811,33 @@ final class A2dpSinkStateMachine extends StateMachine {
                         case EVENT_TYPE_AUDIO_STATE_CHANGED:
                             processAudioStateEvent(event.valueInt, event.device);
                             break;
-                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
-                            processAudioConfigEvent(event.audioConfig, event.device);
-                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
                     }
                     break;
+                case CONNECT_TIMEOUT:
+                    BluetoothDevice timedOutDevice = getDeviceForMessage(CONNECT_TIMEOUT);
+                    if ((mTargetDevice == null) || (timedOutDevice == null)) {
+                        loge("CONNECT_TIMEOUT received : targetDevice : " +
+                            mTargetDevice + " : timedout device : " + timedOutDevice);
+                    } else if(mTargetDevice.equals(timedOutDevice)) {
+                        loge("CONNECT_TIMEOUT received : connected devices : " +
+                            mConnectedDevicesList.size() +
+                            " : timedout device : " + timedOutDevice);
+                        broadcastConnectionState(mTargetDevice,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        mTargetDevice = null;
+                    } else {
+                        /* Should not hit this
+                         */
+                        loge("CONNECT_TIMEOUT received : connected devices : " +
+                            mConnectedDevicesList.size() +
+                            " : targetDevice : " + mTargetDevice +
+                            " : timedout device : " + timedOutDevice);
+                    }
+                    break;
                 default:
                     return NOT_HANDLED;
             }
@@ -551,40 +846,246 @@ final class A2dpSinkStateMachine extends StateMachine {
 
         // in Connected state
         private void processConnectionEvent(int state, BluetoothDevice device) {
+            log( "processConnectionEvent state = " + state + ", device = "
+                    + device);
             switch (state) {
                 case CONNECTION_STATE_DISCONNECTED:
-                    mAudioConfigs.remove(device);
-                    if (mCurrentDevice.equals(device)) {
-                        broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_CONNECTED);
-                        synchronized (A2dpSinkStateMachine.this) {
-                            mCurrentDevice = null;
-                            transitionTo(mDisconnected);
+                    if (mConnectedDevicesList.contains(device)) {
+                        // if device is playing then remove it from playing
+                        // device list.
+                        if (mPlayingA2dpDevice.size() != 0 &&
+                                mPlayingA2dpDevice.contains(device)) {
+                            log ("Playing A2dp Device is disconnected, setting it to null");
+                            broadcastAudioState(device,
+                                    BluetoothA2dp.STATE_NOT_PLAYING,
+                                    BluetoothA2dp.STATE_PLAYING);
+                            mPlayingA2dpDevice.remove(device);
+                        }
+                        // Reset scan mode if it set due to multicast
+                        Log.i(TAG,"getScanMode: " + mAdapter.getScanMode() +
+                            " isScanDisabled: " + isScanDisabled);
+                        if (mPlayingA2dpDevice.size() <= 1 &&
+                                (mAdapter.getScanMode() ==
+                                BluetoothAdapter.SCAN_MODE_NONE) &&
+                                isScanDisabled) {
+                            isScanDisabled = false;
+                            AdapterService adapterService =
+                                    AdapterService.getAdapterService();
+                            if (adapterService != null) {
+                                adapterService.restoreScanMode();
+                            }
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                             BluetoothProfile.STATE_CONNECTED);
+                        synchronized (A2dpStateMachine.this) {
+                            mConnectedDevicesList.remove(device);
+                            log( "device " + device.getAddress() +
+                                    " is removed in Connected state");
+                            if (mConnectedDevicesList.size() == 0) {
+                                mCurrentDevice = null;
+                                // cleanup mMultiDisconnectDevice, if incoming
+                                // disconnect is processed first.
+                                if (mMultiDisconnectDevice != null)
+                                    mMultiDisconnectDevice = null;
+                                transitionTo(mDisconnected);
+                            } else {
+                                processMultiA2dpDisconnected(device);
+                            }
+                        }
+                    } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                        broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                                                 BluetoothProfile.STATE_CONNECTING);
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = null;
                         }
+                        logi("Disconnected from mTargetDevice in connected state device: " +
+                                device);
                     } else {
                         loge("Disconnected from unknown device: " + device);
                     }
                     break;
+                case CONNECTION_STATE_CONNECTING:
+                    // 2nd incoming connection
+                    log("Incoming connection in Connected State for device " +
+                            device);
+                    if (mConnectedDevicesList.contains(device)) {
+                        log("device is already connected ");
+                        mIncomingDevice = null;
+                        mTargetDevice = null;
+                        break;
+                    }
+                    // this should be never be case, as we will move to MPC
+                    if (mTargetDevice != null) {
+                        log("Outgoing initiated before incoming");
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                    AdapterService.PROFILE_CONN_REJECTED);
+                        }
+                        break;
+                    }
+                    if (okToConnect(device) &&
+                            (mConnectedDevicesList.size() < maxA2dpConnections)) {
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                        mIncomingDevice = device;
+                        transitionTo(mMultiConnectionPending);
+                        Message m = obtainMessage(CONNECT_TIMEOUT);
+                        m.obj = device;
+                        sendMessageDelayed(m, CONNECT_TIMEOUT_SEC);
+                    } else {
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                    AdapterService.PROFILE_CONN_REJECTED);
+                        }
+                    }
+
+                    break;
+                case CONNECTION_STATE_CONNECTED:
+                    // 2nd incoming connection
+                    log("Connected event for device " + device);
+                    if (mConnectedDevicesList.contains(device)) {
+                        log("device already connected ");
+                        mIncomingDevice = null;
+                        mTargetDevice = null;
+                        break;
+                    }
+                    if (mMultiDisconnectDevice != null) {
+                        log("disconnection failed for device");
+                        mMultiDisconnectDevice = null;
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_DISCONNECTING);
+                        break;
+                    }
+                    if (mTargetDevice != null && mTargetDevice.equals(device) &&
+                            (mConnectedDevicesList.size() < maxA2dpConnections)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mCurrentDevice = mTargetDevice;
+                            mConnectedDevicesList.add(mTargetDevice);
+                            mTargetDevice = null;
+                            log( "device " + device.getAddress() +
+                                    " is added in Connected state");
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        break;
+                    }
+                    Log.i(TAG,"okToConnect in connected state " + okToConnect(device));
+                    if (okToConnect(device) &&
+                            (mConnectedDevicesList.size() < maxA2dpConnections)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mCurrentDevice = device;
+                            mConnectedDevicesList.add(device);
+                            mIncomingDevice= null;
+                            log( "device " + device.getAddress() +
+                                    " is added in Connected state");
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_DISCONNECTED);
+                    } else {
+                        disconnectA2dpNative(getByteAddress(device));
+                        // the other profile connection should be initiated
+                        AdapterService adapterService = AdapterService.getAdapterService();
+                        if (adapterService != null) {
+                            adapterService.connectOtherProfile(device,
+                                    AdapterService.PROFILE_CONN_REJECTED);
+                        }
+                    }
+                    break;
+                    // this case would never happen
+                case CONNECTION_STATE_DISCONNECTING:
+                    loge("Disconnecting in Connected State ignore it");
+                    break;
+
               default:
                   loge("Connection State Device: " + device + " bad state: " + state);
                   break;
             }
         }
+        private void processMultiA2dpDisconnected(BluetoothDevice device) {
+            log("Connect state: processMultiA2dpDisconnected");
+            /* Assign the current activedevice again if the disconnected
+            device equals to the current active device */
+            if (mCurrentDevice != null && mCurrentDevice.equals(device)) {
+                int deviceSize = mConnectedDevicesList.size();
+                mCurrentDevice = mConnectedDevicesList.get(deviceSize-1);
+            }
+            log("processMultiA2dpDisconnected, the latest mCurrentDevice is:" +
+                    mCurrentDevice);
+            log("Connect state: processMultiA2dpDisconnected ," +
+                    "fake broadcasting for mCurrentDevice");
+            broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED,
+                   BluetoothProfile.STATE_DISCONNECTED);
+        }
+
         private void processAudioStateEvent(int state, BluetoothDevice device) {
-            if (!mCurrentDevice.equals(device)) {
-                loge("Audio State Device:" + device + "is different from ConnectedDevice:" +
-                                                           mCurrentDevice);
+            if (!mConnectedDevicesList.contains(device)) {
+                loge("Audio State Device:" + device + "is not in mConnectedDevicesList" +
+                        mCurrentDevice);
                 return;
             }
+            log("connectedState: processAudioStateEvent state: " + state + " device "
+                    + device);
+            log("mPlayingA2dpDevice size is " + mPlayingA2dpDevice.size());
+            log("mConnectedDevicesList size is " +
+                    mConnectedDevicesList.contains(device));
             switch (state) {
                 case AUDIO_STATE_STARTED:
-                    broadcastAudioState(device, BluetoothA2dpSink.STATE_PLAYING,
-                                        BluetoothA2dpSink.STATE_NOT_PLAYING);
+                    synchronized (A2dpStateMachine.this) {
+                        if (mConnectedDevicesList.contains(device) &&
+                                !(mPlayingA2dpDevice.size() != 0 &&
+                                mPlayingA2dpDevice.contains(device))) {
+                            /* set scan mode before adding device to mPlayingA2dpDevice
+                             * so that scan mode is set to last set mode after multicast
+                             * is stopped. */
+                            if (mPlayingA2dpDevice.size() == 1) {
+                                Log.i(TAG,"setScanMode:SCAN_MODE_NONE");
+                                isScanDisabled = true;
+                                mAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_NONE);
+                            }
+                            mPlayingA2dpDevice.add(device);
+                            mService.setAvrcpAudioState(BluetoothA2dp.STATE_PLAYING, device);
+                            broadcastAudioState(device, BluetoothA2dp.STATE_PLAYING,
+                                    BluetoothA2dp.STATE_NOT_PLAYING);
+                        }
+                        /* cancel any discovery if in progress and scan mode to
+                         * none when multicast is active.Set flag to reset
+                         * scan mode if changed due to multicast.*/
+                        if (mPlayingA2dpDevice.size() == 2) {
+                            if (mAdapter.isDiscovering()) {
+                                mAdapter.cancelDiscovery();
+                            }
+                        }
+                    }
                     break;
-                case AUDIO_STATE_REMOTE_SUSPEND:
                 case AUDIO_STATE_STOPPED:
-                    broadcastAudioState(device, BluetoothA2dpSink.STATE_NOT_PLAYING,
-                                        BluetoothA2dpSink.STATE_PLAYING);
+                case AUDIO_STATE_REMOTE_SUSPEND:
+                    synchronized (A2dpStateMachine.this) {
+                        if (mPlayingA2dpDevice.size() != 0 &&
+                                mPlayingA2dpDevice.contains(device)) {
+                            mPlayingA2dpDevice.remove(device);
+                            mService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING, device);
+                            broadcastAudioState(device, BluetoothA2dp.STATE_NOT_PLAYING,
+                                     BluetoothA2dp.STATE_PLAYING);
+                        }
+                        // Reset scan mode if it set due to multicast
+                        Log.i(TAG,"getScanMode: " + mAdapter.getScanMode() +
+                            " isScanDisabled: " + isScanDisabled);
+                        if (mPlayingA2dpDevice.size() <= 1 &&
+                                (mAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_NONE) &&
+                                isScanDisabled) {
+                            isScanDisabled = false;
+                            AdapterService adapterService = AdapterService.getAdapterService();
+                            if (adapterService != null) {
+                                adapterService.restoreScanMode();
+                            }
+                        }
+                    }
                     break;
                 default:
                   loge("Audio State Device: " + device + " bad state: " + state);
@@ -592,24 +1093,427 @@ final class A2dpSinkStateMachine extends StateMachine {
             }
         }
     }
+    /* Add MultiConnectionPending state when atleast 1 HS is connected
+        and disconnect/connect is initiated for new HS */
+    private class MultiConnectionPending extends State {
+        @Override
+        public void enter() {
+            log("Enter MultiConnectionPending: " + getCurrentMessage().what +
+                    ", size: " + mConnectedDevicesList.size());
+        }
 
-    private void processAudioConfigEvent(BluetoothAudioConfig audioConfig, BluetoothDevice device) {
-        mAudioConfigs.put(device, audioConfig);
-        broadcastAudioConfig(device, audioConfig);
+        public boolean processMessage(Message message) {
+            log( "MultiConnectionPending process message: " + message.what +
+                    ", size: " + mConnectedDevicesList.size());
+            boolean retValue = HANDLED;
+            switch(message.what) {
+                case CONNECT:
+                    deferMessage(message);
+                     break;
+                case DISCONNECT:
+                    BluetoothDevice device = (BluetoothDevice) message.obj;
+                    if (mConnectedDevicesList.contains(device) &&
+                            mTargetDevice != null && mTargetDevice.equals(device)) {
+                        // cancel connection to the mTargetDevice
+                        broadcastConnectionState(device,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = null;
+                        }
+                    } else {
+                        deferMessage(message);
+                    }
+                    break;
+                case CONNECT_TIMEOUT:
+                    // This is always for Outgoing connection
+                    BluetoothDevice dev = (BluetoothDevice)message.obj;
+                    // getByteAddress has no null check
+                    log("Timeout for device in MCP " + dev);
+                    if ((dev != null) && (mTargetDevice == null ||
+                            !mTargetDevice.equals(dev))) {
+                           log("Timeout for incoming device " + dev);
+                        onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
+                                getByteAddress(dev));
+                        break;
+                    }
+                    disconnectA2dpNative(getByteAddress(mTargetDevice));
+                    onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
+                            getByteAddress(mTargetDevice));
+                    break;
+                case STACK_EVENT:
+                    StackEvent event = (StackEvent) message.obj;
+                    switch (event.type) {
+                        case EVENT_TYPE_CONNECTION_STATE_CHANGED:
+                            processConnectionEvent(event.valueInt, event.device);
+                            break;
+                        case EVENT_TYPE_AUDIO_STATE_CHANGED:
+                            processAudioStateEvent(event.valueInt, event.device);
+                            break;
+                        default:
+                            loge("Unexpected stack event: " + event.type);
+                            break;
+                    }
+                    break;
+                default:
+                    return NOT_HANDLED;
+            }
+            return retValue;
+        }
+
+        @Override
+        public void exit() {
+            log("Exit MultiConnectionPending: " + getCurrentMessage().what);
+        }
+
+        // in MultiConnectionPending state
+        private void processConnectionEvent(int state, BluetoothDevice device) {
+            log("processConnectionEvent state = " + state +
+                    ", device = " + device);
+            switch (state) {
+                case CONNECTION_STATE_DISCONNECTED:
+                    if (mConnectedDevicesList.contains(device)) {
+                        if (mPlayingA2dpDevice.size() != 0 &&
+                                mPlayingA2dpDevice.contains(device)) {
+                            log ("mPlayingA2dpDevice is disconnected, setting it to null");
+                            broadcastAudioState(device, BluetoothA2dp.STATE_NOT_PLAYING,
+                                    BluetoothA2dp.STATE_PLAYING);
+                            mPlayingA2dpDevice.remove(device);
+                        }
+                        // Reset scan mode if it set due to multicast
+                        Log.i(TAG,"getScanMode: " + mAdapter.getScanMode() +
+                            " isScanDisabled: " + isScanDisabled);
+                        if (mPlayingA2dpDevice.size() <= 1 &&
+                                (mAdapter.getScanMode() ==
+                                BluetoothAdapter.SCAN_MODE_NONE) &&
+                                isScanDisabled) {
+                            isScanDisabled = false;
+                            AdapterService adapterService =
+                                    AdapterService.getAdapterService();
+                            if (adapterService != null) {
+                                adapterService.restoreScanMode();
+                            }
+                        }
+                        if (mMultiDisconnectDevice != null &&
+                                mMultiDisconnectDevice.equals(device)) {
+                            mMultiDisconnectDevice = null;
+                            synchronized (A2dpStateMachine.this) {
+                                mConnectedDevicesList.remove(device);
+                                log( "device " + device.getAddress() +
+                                        " is removed in MultiConnectionPending state");
+                            }
+                            broadcastConnectionState(device,
+                                    BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_DISCONNECTING);
+                            if (mTargetDevice != null) {
+                                if (!connectA2dpNative(getByteAddress(mTargetDevice))) {
+                                    broadcastConnectionState(mTargetDevice,
+                                            BluetoothProfile.STATE_DISCONNECTED,
+                                            BluetoothProfile.STATE_CONNECTING);
+                                    synchronized (A2dpStateMachine.this) {
+                                        mTargetDevice = null;
+                                        if (mConnectedDevicesList.size() == 0) {
+                                            // Should be not in this state since it has at least
+                                            // one HF connected in MultiHFPending state
+                                            log( "Should be not in this state, error handling");
+                                            transitionTo(mDisconnected);
+
+                                        } else {
+                                            processMultiA2dpDisconnected(device);
+                                        }
+                                    }
+                                }
+                            }  else {
+                                synchronized (A2dpStateMachine.this) {
+                                    mIncomingDevice = null;
+                                    if (mConnectedDevicesList.size() == 0) {
+                                        transitionTo(mDisconnected);
+                                    } else {
+                                        processMultiA2dpDisconnected(device);
+                                    }
+                                }
+                            }
+                        } else {
+                            /* HS disconnected, when other HS is connected */
+                            synchronized (A2dpStateMachine.this) {
+                                mConnectedDevicesList.remove(device);
+
+                                log( "device " + device.getAddress() +
+                                        " is removed in MultiConnectionPending state");
+                            }
+                            broadcastConnectionState(device,
+                                    BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_CONNECTED);
+                        }
+                    } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                        broadcastConnectionState(mTargetDevice,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = null;
+                            if (mConnectedDevicesList.size() == 0) {
+                                transitionTo(mDisconnected);
+                            } else {
+                                transitionTo(mConnected);
+                            }
+                        }
+                    } else if (mIncomingDevice!= null && mIncomingDevice.equals(device)) {
+                        // incoming connection failure
+                        broadcastConnectionState(mIncomingDevice,
+                                BluetoothProfile.STATE_DISCONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                        synchronized (A2dpStateMachine.this) {
+                            mIncomingDevice = null;
+                            if (mConnectedDevicesList.size() == 0) {
+                                transitionTo(mDisconnected);
+                            } else {
+                                transitionTo(mConnected);
+                            }
+                        }
+                    } else {
+                        // mTargetDevice & mIncomingDevice is made null when
+                        // 3rd device is connected, hence move to connected
+                        // state if mConnectedDevicesList size is 2 and other
+                        // device are null
+                        if (mTargetDevice == null && mIncomingDevice == null &&
+                                (mConnectedDevicesList.size() ==
+                                maxA2dpConnections)) {
+                            transitionTo(mConnected);
+                        }
+                        Log.e(TAG, "Unknown device Disconnected: " + device);
+                    }
+
+                    break;
+                case CONNECTION_STATE_CONNECTING:
+                    if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                        log("Outgoing Connection initiated, Ignore it");
+                    } else if (mIncomingDevice!= null &&
+                            mIncomingDevice.equals(device)) {
+                        log("Incoming connection from same device, Ignore it");
+                    } else if (mConnectedDevicesList.contains(device)) {
+                        log("current device tries to connect back");
+                    } else {
+                        log("Connection event from new device " + device);
+                        if (okToConnect(device) &&
+                                (mConnectedDevicesList.size() < maxA2dpConnections)) {
+                            broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
+                                    BluetoothProfile.STATE_DISCONNECTED);
+                            mIncomingDevice = device;
+                        } else {
+                            disconnectA2dpNative(getByteAddress(device));
+                            // the other profile connection should be initiated
+                            AdapterService adapterService = AdapterService.getAdapterService();
+                            if (adapterService != null) {
+                                adapterService.connectOtherProfile(device,
+                                        AdapterService.PROFILE_CONN_REJECTED);
+                            }
+                        }
+                    }
+                    break;
+                case CONNECTION_STATE_CONNECTED:
+                    log("Connected event for device " + device);
+                    if (mConnectedDevicesList.size() == maxA2dpConnections) {
+
+                        // Unkown device connected, check for target and
+                        // incoming devices, make them null and broadcast
+                        // disconnection for them
+                        if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                            log("mTargetDevice, connected list is full");
+                            broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                                   BluetoothProfile.STATE_CONNECTING);
+                            synchronized (A2dpStateMachine.this) {
+                                mTargetDevice = null;
+                            }
+                            disconnectA2dpNative(getByteAddress(device));
+                            onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
+                                    getByteAddress(device));
+                        }
+                        if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
+                            log("mIncomingDevice connected list is full");
+                            broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_CONNECTING);
+                            synchronized (A2dpStateMachine.this) {
+                                mIncomingDevice = null;
+                            }
+
+                            disconnectA2dpNative(getByteAddress(device));
+                            onConnectionStateChanged(CONNECTION_STATE_DISCONNECTED,
+                                    getByteAddress(device));
+                        }
+                    }
+                    if (mConnectedDevicesList.contains(device)) {
+                        log("Disconnection failed event for device " + device);
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_DISCONNECTING);
+                        if (mTargetDevice != null) {
+                            broadcastConnectionState(mTargetDevice,
+                                    BluetoothProfile.STATE_DISCONNECTED,
+                                    BluetoothProfile.STATE_CONNECTING);
+                        }
+                        synchronized (A2dpStateMachine.this) {
+                            mTargetDevice = null;
+                            transitionTo(mConnected);
+                        }
+                    } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mCurrentDevice = device;
+                            mConnectedDevicesList.add(device);
+                            log( "device " + device.getAddress() +
+                                    " is added in MultiConnectionPending state");
+                            mTargetDevice = null;
+                            transitionTo(mConnected);
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+                    } else if (mIncomingDevice!= null && mIncomingDevice.equals(device)) {
+                        synchronized (A2dpStateMachine.this) {
+                            mCurrentDevice = device;
+                            mConnectedDevicesList.add(device);
+                            log( "device " + device.getAddress() +
+                                    " is added in MultiConnectionPending state");
+                            mIncomingDevice = null;
+                            transitionTo(mConnected);
+                        }
+                        broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                BluetoothProfile.STATE_CONNECTING);
+
+                    } else {
+                        log("Unknown Device connected");
+                        if (okToConnect(device) &&
+                                (mConnectedDevicesList.size() < maxA2dpConnections)) {
+                            mCurrentDevice = device;
+                            mConnectedDevicesList.add(device);
+                            log( "device " + device.getAddress() +
+                                    " is added in MultiConnectionPending state");
+                            broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
+                                    BluetoothProfile.STATE_DISCONNECTED);
+
+                        } else {
+                            disconnectA2dpNative(getByteAddress(device));
+                        }
+
+                    }
+                    break;
+                case CONNECTION_STATE_DISCONNECTING:
+                    if (mConnectedDevicesList.contains(device)) {
+                        // we already broadcasted the intent, doing nothing here
+                        log("stack is disconnecting mCurrentDevice");
+                    } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
+                        loge("TargetDevice is getting disconnected");
+                    } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
+                        loge("mIncomingDevice is getting disconnected");
+                    } else {
+                        loge("Disconnecting unknow device: " + device);
+                    }
+                    break;
+                default:
+                    loge("Incorrect state: " + state);
+                    break;
+
+            }
+
+        }
+
+        private void processAudioStateEvent(int state, BluetoothDevice device) {
+            if (!mConnectedDevicesList.contains(device)) {
+                loge("Audio State Device:" + device + "is not in mConnectedDevicesList" +
+                        mCurrentDevice);
+                return;
+            }
+            log("MultiPendingState: processAudioStateEvent state: " + state + " device "
+                    + device.getName());
+            log("mPlayingA2dpDevice size is " + mPlayingA2dpDevice.size());
+            log("mConnectedDevicesList size is " + mConnectedDevicesList.size());
+            switch (state) {
+                case AUDIO_STATE_STARTED:
+                    synchronized (A2dpStateMachine.this) {
+                        if (mConnectedDevicesList.contains(device) &&
+                                !(mPlayingA2dpDevice.size()!= 0 &&
+                                mPlayingA2dpDevice.contains(device))) {
+                            /* set scan mode before adding device to mPlayingA2dpDevice
+                             * so that scan mode is set to last set mode after multicast
+                             * is stopped. */
+                            if (mPlayingA2dpDevice.size() == 1) {
+                                Log.i(TAG,"setScanMode:SCAN_MODE_NONE");
+                                isScanDisabled = true;
+                                mAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_NONE);
+                            }
+                            mPlayingA2dpDevice.add(device);
+                            mService.setAvrcpAudioState(BluetoothA2dp.STATE_PLAYING, device);
+                            broadcastAudioState(device, BluetoothA2dp.STATE_PLAYING,
+                                    BluetoothA2dp.STATE_NOT_PLAYING);
+                        }
+                        /* cancel any discovery if in progress and scan mode to
+                         * none when multicast is active.Set flag to reset
+                         * scan mode if changed due to multicast.*/
+                        if (mPlayingA2dpDevice.size() == 2) {
+                            if (mAdapter.isDiscovering()) {
+                                mAdapter.cancelDiscovery();
+                            }
+                        }
+                    }
+                    break;
+                case AUDIO_STATE_REMOTE_SUSPEND:
+                case AUDIO_STATE_STOPPED:
+                    synchronized (A2dpStateMachine.this) {
+                        if (mPlayingA2dpDevice.size() != 0 &&
+                                mPlayingA2dpDevice.contains(device)) {
+                            mPlayingA2dpDevice.remove(device);
+                            mService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING, device);
+                            broadcastAudioState(device, BluetoothA2dp.STATE_NOT_PLAYING,
+                                    BluetoothA2dp.STATE_PLAYING);
+                     }
+                        // Reset scan mode if it set due to multicast
+                        Log.i(TAG,"getScanMode: " + mAdapter.getScanMode() +
+                            " isScanDisabled: " + isScanDisabled);
+                        if (mPlayingA2dpDevice.size() <= 1 &&
+                                (mAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_NONE) &&
+                                isScanDisabled) {
+                            isScanDisabled = false;
+                            AdapterService adapterService = AdapterService.getAdapterService();
+                            if (adapterService != null) {
+                                adapterService.restoreScanMode();
+                            }
+                        }
+                    }
+                    break;
+                default:
+                  loge("Audio State Device: " + device + " bad state: " + state);
+                  break;
+            }
+        }
+
+        private void processMultiA2dpDisconnected(BluetoothDevice device) {
+            log("processMultiA2dpDisconnected state: processMultiA2dpDisconnected");
+
+            if (mCurrentDevice != null && mCurrentDevice.equals(device)) {
+                int deviceSize = mConnectedDevicesList.size();
+                mCurrentDevice = mConnectedDevicesList.get(deviceSize-1);
+            }
+            transitionTo(mConnected);
+            log("processMultiA2dpDisconnected , the latest mCurrentDevice is:"
+                    + mCurrentDevice);
+            log("MultiA2dpPending state: processMultiA2dpDisconnected ," +
+                    "fake broadcasting for mCurrentDevice");
+            broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED,
+                    BluetoothProfile.STATE_DISCONNECTED);
+        }
     }
 
     int getConnectionState(BluetoothDevice device) {
         if (getCurrentState() == mDisconnected) {
+            log( "currentState is Disconnected");
             return BluetoothProfile.STATE_DISCONNECTED;
         }
 
         synchronized (this) {
             IState currentState = getCurrentState();
+            log( "currentState = " + currentState);
             if (currentState == mPending) {
                 if ((mTargetDevice != null) && mTargetDevice.equals(device)) {
                     return BluetoothProfile.STATE_CONNECTING;
                 }
-                if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
+                if (mConnectedDevicesList.contains(device)) {
                     return BluetoothProfile.STATE_DISCONNECTING;
                 }
                 if ((mIncomingDevice != null) && mIncomingDevice.equals(device)) {
@@ -618,8 +1522,26 @@ final class A2dpSinkStateMachine extends StateMachine {
                 return BluetoothProfile.STATE_DISCONNECTED;
             }
 
+            if (currentState == mMultiConnectionPending) {
+                if ((mTargetDevice != null) && mTargetDevice.equals(device)) {
+                    return BluetoothProfile.STATE_CONNECTING;
+                }
+                if ((mIncomingDevice != null) && mIncomingDevice.equals(device)) {
+                    return BluetoothProfile.STATE_CONNECTING; // incoming connection
+                }
+                if (mConnectedDevicesList.contains(device)) {
+                    if ((mMultiDisconnectDevice != null) &&
+                            (!mMultiDisconnectDevice.equals(device))) {
+                        // The device is still connected
+                         return BluetoothProfile.STATE_CONNECTED;
+                    }
+                    return BluetoothProfile.STATE_DISCONNECTING;
+                }
+                return BluetoothProfile.STATE_DISCONNECTED;
+            }
+
             if (currentState == mConnected) {
-                if (mCurrentDevice.equals(device)) {
+                if (mConnectedDevicesList.contains(device)) {
                     return BluetoothProfile.STATE_CONNECTED;
                 }
                 return BluetoothProfile.STATE_DISCONNECTED;
@@ -630,29 +1552,58 @@ final class A2dpSinkStateMachine extends StateMachine {
         }
     }
 
-    BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
-        return mAudioConfigs.get(device);
-    }
-
     List<BluetoothDevice> getConnectedDevices() {
         List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
+        Log.i(TAG,"mConnectedDevicesList size is " +
+                mConnectedDevicesList.size());
         synchronized(this) {
-            if (getCurrentState() == mConnected) {
-                devices.add(mCurrentDevice);
+            /* If connected and mCurrentDevice is not null*/
+            for (int i = 0; i < mConnectedDevicesList.size(); i++) {
+                devices.add(mConnectedDevicesList.get(i));
             }
         }
         return devices;
     }
 
+    boolean isPlaying(BluetoothDevice device) {
+        synchronized(this) {
+            if (mPlayingA2dpDevice.contains(device)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public List<BluetoothDevice> getPlayingDevice() {
+        return mPlayingA2dpDevice;
+    }
+
+    public boolean isMulticastEnabled() {
+        return isMultiCastEnabled;
+    }
+
+    public boolean isMulticastFeatureEnabled() {
+        return isMultiCastFeatureEnabled;
+    }
+
     boolean okToConnect(BluetoothDevice device) {
         AdapterService adapterService = AdapterService.getAdapterService();
-        boolean ret = true;
+        int priority = mService.getPriority(device);
+        boolean ret = false;
         //check if this is an incoming connection in Quiet mode.
         if((adapterService == null) ||
            ((adapterService.isQuietModeEnabled() == true) &&
            (mTargetDevice == null))){
             ret = false;
         }
+        // check priority and accept or reject the connection. if priority is undefined
+        // it is likely that our SDP has not completed and peer is initiating the
+        // connection. Allow this connection, provided the device is bonded
+        else if((BluetoothProfile.PRIORITY_OFF < priority) ||
+                ((BluetoothProfile.PRIORITY_UNDEFINED == priority) &&
+                (device.getBondState() != BluetoothDevice.BOND_NONE))){
+            ret= true;
+        }
         return ret;
     }
 
@@ -663,7 +1614,7 @@ final class A2dpSinkStateMachine extends StateMachine {
 
         for (BluetoothDevice device : bondedDevices) {
             ParcelUuid[] featureUuids = device.getUuids();
-            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.AudioSource)) {
+            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.AudioSink)) {
                 continue;
             }
             connectionState = getConnectionState(device);
@@ -676,13 +1627,38 @@ final class A2dpSinkStateMachine extends StateMachine {
         return deviceList;
     }
 
+    private BluetoothDevice getDeviceForMessage(int what) {
+        if (what == CONNECT_TIMEOUT) {
+            log("getDeviceForMessage: returning mTargetDevice for what=" + what);
+            return mTargetDevice;
+        }
+        if (mConnectedDevicesList.size() == 0) {
+            log("getDeviceForMessage: No connected device. what=" + what);
+            return null;
+        }
+        for (BluetoothDevice device : mConnectedDevicesList){
+            if (getHandler().hasMessages(what, device)) {
+                log("getDeviceForMessage: returning " + device + "for what " +
+                        what);
+                return device;
+            }
+        }
+        log("getDeviceForMessage: No matching device for " + what + ". Returning null");
+        return null;
+    }
+
 
     // This method does not check for error conditon (newState == prevState)
     private void broadcastConnectionState(BluetoothDevice device, int newState, int prevState) {
 
         int delay = mAudioManager.setBluetoothA2dpDeviceConnectionState(device, newState,
-                BluetoothProfile.A2DP_SINK);
+                BluetoothProfile.A2DP);
+        Log.i(TAG,"connectoin state change " + device + " state " + newState);
 
+        if (newState == BluetoothProfile.STATE_DISCONNECTING ||
+                newState == BluetoothProfile.STATE_CONNECTING) {
+            delay = 0;
+        }
         mWakeLock.acquire();
         mIntentBroadcastHandler.sendMessageDelayed(mIntentBroadcastHandler.obtainMessage(
                                                         MSG_CONNECTION_STATE_CHANGED,
@@ -693,26 +1669,16 @@ final class A2dpSinkStateMachine extends StateMachine {
     }
 
     private void broadcastAudioState(BluetoothDevice device, int state, int prevState) {
-        Intent intent = new Intent(BluetoothA2dpSink.ACTION_PLAYING_STATE_CHANGED);
+        Intent intent = new Intent(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED);
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
         intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
         intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
-//FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
+        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, A2dpService.BLUETOOTH_PERM);
 
         log("A2DP Playing state : device: " + device + " State:" + prevState + "->" + state);
     }
 
-    private void broadcastAudioConfig(BluetoothDevice device, BluetoothAudioConfig audioConfig) {
-        Intent intent = new Intent(BluetoothA2dpSink.ACTION_AUDIO_CONFIG_CHANGED);
-        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
-        intent.putExtra(BluetoothA2dpSink.EXTRA_AUDIO_CONFIG, audioConfig);
-//FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
-
-        log("A2DP Audio Config : device: " + device + " config: " + audioConfig);
-    }
-
     private byte[] getByteAddress(BluetoothDevice device) {
         return Utils.getBytesFromAddress(device.getAddress());
     }
@@ -731,14 +1697,26 @@ final class A2dpSinkStateMachine extends StateMachine {
         sendMessage(STACK_EVENT, event);
     }
 
-    private void onAudioConfigChanged(byte[] address, int sampleRate, int channelCount) {
-        StackEvent event = new StackEvent(EVENT_TYPE_AUDIO_CONFIG_CHANGED);
-        int channelConfig = (channelCount == 1 ? AudioFormat.CHANNEL_IN_MONO
-                                               : AudioFormat.CHANNEL_IN_STEREO);
-        event.audioConfig = new BluetoothAudioConfig(sampleRate, channelConfig,
-                AudioFormat.ENCODING_PCM_16BIT);
-        event.device = getDevice(address);
-        sendMessage(STACK_EVENT, event);
+    private void onCheckConnectionPriority(byte[] address) {
+        BluetoothDevice device = getDevice(address);
+        logw(" device " + device + " okToConnect " + okToConnect(device));
+        if (okToConnect(device)) {
+            // if connection is allowed then go ahead and connect
+            allowConnectionNative(IS_VALID_DEVICE, getByteAddress(device));
+        } else {
+            // if connection is not allowed DO NOT CONNECT
+            allowConnectionNative(IS_INVALID_DEVICE, getByteAddress(device));
+        }
+    }
+
+    private void onMulticastStateChanged(int state) {
+        if (state == ENABLE_MULTICAST) {
+            Log.i(TAG,"A2dp Multicast is Enabled");
+            isMultiCastEnabled = true;
+        } else {
+            Log.i(TAG,"A2dp Multicast is Disabled");
+            isMultiCastEnabled = false;
+        }
     }
 
     private BluetoothDevice getDevice(byte[] address) {
@@ -749,7 +1727,6 @@ final class A2dpSinkStateMachine extends StateMachine {
         int type = EVENT_TYPE_NONE;
         int valueInt = 0;
         BluetoothDevice device = null;
-        BluetoothAudioConfig audioConfig = null;
 
         private StackEvent(int type) {
             this.type = type;
@@ -759,15 +1736,14 @@ final class A2dpSinkStateMachine extends StateMachine {
     private class IntentBroadcastHandler extends Handler {
 
         private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
-            Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
+            Intent intent = new Intent(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
             intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
             intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
             intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
-//FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
             mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
             log("Connection state " + device + ": " + prevState + "->" + state);
-            mService.notifyProfileConnectionStateChanged(device, BluetoothProfile.A2DP_SINK,
-                    state, prevState);
+            mService.notifyProfileConnectionStateChanged(device, BluetoothProfile.A2DP, state, prevState);
         }
 
         @Override
@@ -781,12 +1757,18 @@ final class A2dpSinkStateMachine extends StateMachine {
         }
     }
 
+    public void dump(StringBuilder sb) {
+        ProfileService.println(sb, "mCurrentDevice: " + mCurrentDevice);
+        ProfileService.println(sb, "mTargetDevice: " + mTargetDevice);
+        ProfileService.println(sb, "mIncomingDevice: " + mIncomingDevice);
+        ProfileService.println(sb, "mPlayingA2dpDevice: " + mPlayingA2dpDevice);
+        ProfileService.println(sb, "StateMachine: " + this.toString());
+    }
 
     // Event types for STACK_EVENT message
     final private static int EVENT_TYPE_NONE = 0;
     final private static int EVENT_TYPE_CONNECTION_STATE_CHANGED = 1;
     final private static int EVENT_TYPE_AUDIO_STATE_CHANGED = 2;
-    final private static int EVENT_TYPE_AUDIO_CONFIG_CHANGED = 3;
 
    // Do not modify without updating the HAL bt_av.h files.
 
@@ -802,8 +1784,10 @@ final class A2dpSinkStateMachine extends StateMachine {
     final static int AUDIO_STATE_STARTED = 2;
 
     private native static void classInitNative();
-    private native void initNative();
+    private native void initNative(int maxA2dpConnectionsAllowed,
+            int multiCastState);
     private native void cleanupNative();
     private native boolean connectA2dpNative(byte[] address);
     private native boolean disconnectA2dpNative(byte[] address);
+    private native void allowConnectionNative(int isValid, byte[] address);
 }
diff --git a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
index 7ad4a59..2aa61a3 100755
--- a/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
+++ b/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
@@ -1,5 +1,8 @@
 /*
- * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
+ * Copyright (C) 2014 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,14 +31,23 @@
  */
 package com.android.bluetooth.a2dp;
 
-import android.bluetooth.BluetoothA2dp;
+import android.bluetooth.BluetoothA2dpSink;
 import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothAudioConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothUuid;
 import android.bluetooth.IBluetooth;
+import android.content.BroadcastReceiver;
 import android.content.Context;
+import android.media.AudioFormat;
 import android.media.AudioManager;
+import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.AudioDevicePort;
+import android.media.AudioPatch;
+import android.media.AudioSystem;
+import android.media.AudioPortConfig;
+import android.media.AudioPort;
 import android.os.Handler;
 import android.os.Message;
 import android.os.ParcelUuid;
@@ -50,26 +62,36 @@ import android.util.Log;
 import com.android.bluetooth.Utils;
 import com.android.bluetooth.btservice.AdapterService;
 import com.android.bluetooth.btservice.ProfileService;
+import com.android.bluetooth.avrcp.AvrcpControllerService;
 import com.android.internal.util.IState;
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.HashMap;
 import java.util.Set;
 
-final class A2dpStateMachine extends StateMachine {
-    private static final boolean DBG = false;
+final class A2dpSinkStateMachine extends StateMachine {
+    private static final boolean DBG = true;
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
+    private static final int REQUEST_AUDIO_FOCUS = 4;
     private static final int STACK_EVENT = 101;
     private static final int CONNECT_TIMEOUT = 201;
 
+    private static final int IS_INVALID_DEVICE = 0;
+    private static final int IS_VALID_DEVICE = 1;
+    public static final int AVRC_ID_PLAY = 0x44;
+    public static final int AVRC_ID_PAUSE = 0x46;
+    public static final int KEY_STATE_PRESSED = 0;
+    public static final int KEY_STATE_RELEASED = 1;
+
     private Disconnected mDisconnected;
     private Pending mPending;
     private Connected mConnected;
 
-    private A2dpService mService;
+    private A2dpSinkService mService;
     private Context mContext;
     private BluetoothAdapter mAdapter;
     private final AudioManager mAudioManager;
@@ -78,6 +100,29 @@ final class A2dpStateMachine extends StateMachine {
 
     private static final int MSG_CONNECTION_STATE_CHANGED = 0;
 
+    private static final int AUDIO_FOCUS_LOSS = 0;
+    private static final int AUDIO_FOCUS_GAIN = 1;
+    private static final int AUDIO_FOCUS_LOSS_TRANSIENT = 2;
+    private static final int AUDIO_FOCUS_LOSS_CAN_DUCK = 3;
+    private static final int AUDIO_FOCUS_REQUEST_MESSAGE_DELAYED = 500;
+    private static final boolean USE_AUDIOTRACK = true;
+
+    private int mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
+
+     /* Used to indicate focus lost */
+    private static final int STATE_FOCUS_LOST = 0;
+    /* Used to inform bluedroid about AVRCP State changes */
+    private static final int STATE_FOCUS_READY = 1;
+    /* Used to inform bluedroid that focus is granted */
+    private static final int STATE_FOCUS_GRANTED = 3;
+
+    private final Object mLockForPatch = new Object();
+    private AudioDevicePort mInPortA2dpSink;
+    private AudioDevicePort mOutPortSpeaker;
+    private AudioPatch mA2dpSinkAudioPatch;
+    private static final int maxA2dpSinkConnections = 1;
+    private static final int multiCastState = 0;
+
     // mCurrentDevice is the device connected before the state changes
     // mTargetDevice is the device to be connected
     // mIncomingDevice is the device connecting to us, valid only in Pending state
@@ -103,20 +148,23 @@ final class A2dpStateMachine extends StateMachine {
     private BluetoothDevice mCurrentDevice = null;
     private BluetoothDevice mTargetDevice = null;
     private BluetoothDevice mIncomingDevice = null;
-    private BluetoothDevice mPlayingA2dpDevice = null;
+    private BluetoothDevice mPlayingDevice = null;
 
+    private final HashMap<BluetoothDevice,BluetoothAudioConfig> mAudioConfigs
+            = new HashMap<BluetoothDevice,BluetoothAudioConfig>();
 
     static {
         classInitNative();
     }
 
-    private A2dpStateMachine(A2dpService svc, Context context) {
-        super("A2dpStateMachine");
+    private A2dpSinkStateMachine(A2dpSinkService svc, Context context) {
+        super("A2dpSinkStateMachine");
         mService = svc;
         mContext = context;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
 
-        initNative();
+        // for sink soft handsoff and multicast are disabled
+        initNative(maxA2dpSinkConnections, multiCastState);
 
         mDisconnected = new Disconnected();
         mPending = new Pending();
@@ -129,38 +177,161 @@ final class A2dpStateMachine extends StateMachine {
         setInitialState(mDisconnected);
 
         PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
-        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpService");
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "BluetoothA2dpSinkService");
 
         mIntentBroadcastHandler = new IntentBroadcastHandler();
 
         mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        if(!USE_AUDIOTRACK)
+            mAudioManager.registerAudioPortUpdateListener(mAudioPortListener);
     }
+    private void releasePatch() {
+        if(USE_AUDIOTRACK) {
+            log(" releasePatch: AudioTrack, inform focus loss");
+            informAudioFocusStateNative(STATE_FOCUS_LOST);
+            return;
+        }
+        synchronized (mLockForPatch){
+            log("releaseAudioPatch AudioPatch = " + mA2dpSinkAudioPatch);
+            if(mA2dpSinkAudioPatch != null) {
+                mAudioManager.releaseAudioPatch(mA2dpSinkAudioPatch);
+                mA2dpSinkAudioPatch = null;
+            }
+        }
+    }
+    private void patchPorts() {
+        /* If we are using AudioTrack, we need to broadcast and inform bluedroid from here */
+        if(USE_AUDIOTRACK){
+            log(" patchPorts: AudioTrack, inform focus gain");
+            broadcastAudioState(mPlayingDevice, BluetoothA2dpSink.STATE_PLAYING,
+                    BluetoothA2dpSink.STATE_NOT_PLAYING);
+            informAudioFocusStateNative(STATE_FOCUS_GRANTED);
+            return;
+        }
+        synchronized (mLockForPatch) {
+            log("patchPorts : mA2dpSinkAudioPatch: " + mA2dpSinkAudioPatch +
+                " mPlayingDevice " + mPlayingDevice + "mOutPortSpeaker" + mOutPortSpeaker);
+            if((mA2dpSinkAudioPatch == null) && (mPlayingDevice != null) &&
+               (mOutPortSpeaker != null) && (mInPortA2dpSink != null)) {
+                if((mAudioConfigs == null)||(!mAudioConfigs.containsKey(mPlayingDevice))) {
+                    log(" AudioConfigs not yet received, returning");
+                    return;
+                }
+                /*Fix for below klockworks issue */
+                /*Null pointer dereference of 'getAudioConfig(...)' where null is returned from a map or a collection */
+                /*We are checking mAudioConfigs in above if condition and Fix is not allowd will update in False positive doc */
+                int sampleRate = getAudioConfig(mPlayingDevice).getSampleRate();
+                int channelMask = getAudioConfig(mPlayingDevice).getChannelConfig();
+                int format =  getAudioConfig(mPlayingDevice).getAudioFormat();
+
+                AudioPortConfig sourcePortArray[] =
+                    {mInPortA2dpSink.buildConfig(sampleRate, channelMask, format, null)};
+                AudioPortConfig sinkPortArray[] =
+                    {mOutPortSpeaker.buildConfig(sampleRate, channelMask, format, null)};
+                AudioPatch patchPortArray[] = {null};
+                /*  broadCast Audio State */
+                broadcastAudioState(mPlayingDevice, BluetoothA2dpSink.STATE_PLAYING,
+                                                 BluetoothA2dpSink.STATE_NOT_PLAYING);
+
+                int ret = mAudioManager.createAudioPatch(patchPortArray, sourcePortArray,
+                                                                                   sinkPortArray);
+                if (ret == 0) {
+                    mA2dpSinkAudioPatch = patchPortArray[0];
+                    log("PatchCreated success: " + ret + " mA2dpSinkAudioPatch: "
+                                                                         + mA2dpSinkAudioPatch);
+                } else {
+                    log("PatchCreated failed returned: " + ret);
+                }
+            }
+        }
+    }
+
+    private final AudioManager.OnAudioPortUpdateListener mAudioPortListener =
+                       new AudioManager.OnAudioPortUpdateListener(){
+        public void onAudioPortListUpdate(AudioPort[] portList) {
+            synchronized (mLockForPatch){
+                log("onAudioPortListUpdate");
+                mOutPortSpeaker = null;
+                mInPortA2dpSink = null;
+
+                for (int i = 0; i < portList.length; i++) {
+                    AudioPort port = portList[i];
+                    if(port instanceof AudioDevicePort) {
+                        AudioDevicePort devicePort = (AudioDevicePort)port;
+                        if(devicePort.type() == AudioSystem.DEVICE_OUT_SPEAKER) {
+                            log("Updating Speaker Port");
+                            mOutPortSpeaker = devicePort;
+                        } else if(devicePort.type() == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
+                            log("Updating In Port A2DP Sink");
+                            mInPortA2dpSink = devicePort;
+                            /* Check if we still have focus */
+                            if ((mAudioFocusAcquired == AUDIO_FOCUS_GAIN) &&
+                                (mInPortA2dpSink != null) && (mA2dpSinkAudioPatch == null)) {
+                                /* This is the case of Port available
+                                 * later than focus acquired. Try patching ports now
+                                 */
+                                 log(" Sink Port updated, but patch not made");
+                                 patchPorts();
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        public void onAudioPatchListUpdate(AudioPatch[] patchList){
+            log("onAudioPatchListUpdate");
+            for(int i = 0; i < patchList.length; i++) {
+                log("Patch List " + i +" : "+ patchList[i]);
+            }
+        }
+
+        public void onServiceDied() {
+            log(" Service Died");
+        }
+    };
 
-    static A2dpStateMachine make(A2dpService svc, Context context) {
-        Log.d("A2dpStateMachine", "make");
-        A2dpStateMachine a2dpSm = new A2dpStateMachine(svc, context);
+    static A2dpSinkStateMachine make(A2dpSinkService svc, Context context) {
+        Log.d("A2dpSinkStateMachine", "make");
+        A2dpSinkStateMachine a2dpSm = new A2dpSinkStateMachine(svc, context);
         a2dpSm.start();
         return a2dpSm;
     }
 
     public void doQuit() {
-        if ((mTargetDevice != null) &&
-            (getConnectionState(mTargetDevice) == BluetoothProfile.STATE_CONNECTING)) {
-            log("doQuit()- Move A2DP State to DISCONNECTED");
-            broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
-                                     BluetoothProfile.STATE_CONNECTING);
-        }
         quitNow();
     }
 
     public void cleanup() {
+        /*
+         * remove cleanup of resources
+         * not acquired in AudioTrack approach
+         */
+        if(!USE_AUDIOTRACK)
+            releasePatch();
         cleanupNative();
+        mAudioConfigs.clear();
+        if(USE_AUDIOTRACK) return;
+        if (mContext != null)
+            mContext.unregisterReceiver(mA2dpReceiver);
+        mAudioManager.unregisterAudioPortUpdateListener(mAudioPortListener);
+    }
+
+    public void dump(StringBuilder sb) {
+        ProfileService.println(sb, "mCurrentDevice: " + mCurrentDevice);
+        ProfileService.println(sb, "mTargetDevice: " + mTargetDevice);
+        ProfileService.println(sb, "mIncomingDevice: " + mIncomingDevice);
+        ProfileService.println(sb, "StateMachine: " + this.toString());
     }
 
-        private class Disconnected extends State {
+    private class Disconnected extends State {
         @Override
         public void enter() {
             log("Enter Disconnected: " + getCurrentMessage().what);
+            /*
+             * Remove audio focus request when not in connected state
+             */
+            removeMessages(REQUEST_AUDIO_FOCUS);
         }
 
         @Override
@@ -184,7 +355,7 @@ final class A2dpStateMachine extends StateMachine {
                         break;
                     }
 
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mTargetDevice = device;
                         transitionTo(mPending);
                     }
@@ -201,6 +372,9 @@ final class A2dpStateMachine extends StateMachine {
                         case EVENT_TYPE_CONNECTION_STATE_CHANGED:
                             processConnectionEvent(event.valueInt, event.device);
                             break;
+                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
+                            processAudioConfigEvent(event.audioConfig, event.device);
+                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
@@ -228,7 +402,7 @@ final class A2dpStateMachine extends StateMachine {
                     logi("Incoming A2DP accepted");
                     broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
                                              BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mIncomingDevice = device;
                         transitionTo(mPending);
                     }
@@ -250,10 +424,16 @@ final class A2dpStateMachine extends StateMachine {
                     logi("Incoming A2DP accepted");
                     broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
                                              BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mCurrentDevice = device;
                         transitionTo(mConnected);
                     }
+                    // the other profile connection should be initiated
+                    AdapterService adapterService = AdapterService.getAdapterService();
+                    if (adapterService != null) {
+                        adapterService.connectOtherProfile(device,
+                                AdapterService.PROFILE_CONN_CONNECTED);
+                    }
                 } else {
                     //reject the connection and stay in Disconnected state itself
                     logi("Incoming A2DP rejected");
@@ -267,7 +447,7 @@ final class A2dpStateMachine extends StateMachine {
                 }
                 break;
             case CONNECTION_STATE_DISCONNECTING:
-                logw("Ignore A2dp DISCONNECTING event, device: " + device);
+                logw("Ignore HF DISCONNECTING event, device: " + device);
                 break;
             default:
                 loge("Incorrect state: " + state);
@@ -280,6 +460,10 @@ final class A2dpStateMachine extends StateMachine {
         @Override
         public void enter() {
             log("Enter Pending: " + getCurrentMessage().what);
+            /*
+             * Remove audio focus request when not in connected state
+             */
+            removeMessages(REQUEST_AUDIO_FOCUS);
         }
 
         @Override
@@ -302,7 +486,7 @@ final class A2dpStateMachine extends StateMachine {
                         // cancel connection to the mTargetDevice
                         broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
                                        BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpStateMachine.this) {
+                        synchronized (A2dpSinkStateMachine.this) {
                             mTargetDevice = null;
                         }
                     } else {
@@ -316,6 +500,9 @@ final class A2dpStateMachine extends StateMachine {
                             removeMessages(CONNECT_TIMEOUT);
                             processConnectionEvent(event.valueInt, event.device);
                             break;
+                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
+                            processAudioConfigEvent(event.audioConfig, event.device);
+                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
@@ -331,11 +518,12 @@ final class A2dpStateMachine extends StateMachine {
         private void processConnectionEvent(int state, BluetoothDevice device) {
             switch (state) {
                 case CONNECTION_STATE_DISCONNECTED:
+                    mAudioConfigs.remove(device);
                     if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
                         broadcastConnectionState(mCurrentDevice,
                                                  BluetoothProfile.STATE_DISCONNECTED,
                                                  BluetoothProfile.STATE_DISCONNECTING);
-                        synchronized (A2dpStateMachine.this) {
+                        synchronized (A2dpSinkStateMachine.this) {
                             mCurrentDevice = null;
                         }
 
@@ -344,13 +532,13 @@ final class A2dpStateMachine extends StateMachine {
                                 broadcastConnectionState(mTargetDevice,
                                                          BluetoothProfile.STATE_DISCONNECTED,
                                                          BluetoothProfile.STATE_CONNECTING);
-                                synchronized (A2dpStateMachine.this) {
+                                synchronized (A2dpSinkStateMachine.this) {
                                     mTargetDevice = null;
                                     transitionTo(mDisconnected);
                                 }
                             }
                         } else {
-                            synchronized (A2dpStateMachine.this) {
+                            synchronized (A2dpSinkStateMachine.this) {
                                 mIncomingDevice = null;
                                 transitionTo(mDisconnected);
                             }
@@ -359,15 +547,7 @@ final class A2dpStateMachine extends StateMachine {
                         // outgoing connection failed
                         broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
                                                  BluetoothProfile.STATE_CONNECTING);
-                        // check if there is some incoming connection request
-                        if (mIncomingDevice != null) {
-                            logi("disconnect for outgoing in pending state");
-                            synchronized (A2dpStateMachine.this) {
-                                mTargetDevice = null;
-                            }
-                            break;
-                        }
-                        synchronized (A2dpStateMachine.this) {
+                        synchronized (A2dpSinkStateMachine.this) {
                             mTargetDevice = null;
                             transitionTo(mDisconnected);
                         }
@@ -375,7 +555,7 @@ final class A2dpStateMachine extends StateMachine {
                         broadcastConnectionState(mIncomingDevice,
                                                  BluetoothProfile.STATE_DISCONNECTED,
                                                  BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpStateMachine.this) {
+                        synchronized (A2dpSinkStateMachine.this) {
                             mIncomingDevice = null;
                             transitionTo(mDisconnected);
                         }
@@ -392,14 +572,14 @@ final class A2dpStateMachine extends StateMachine {
                         broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_DISCONNECTED,
                                                  BluetoothProfile.STATE_CONNECTING);
                     }
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mTargetDevice = null;
                         transitionTo(mConnected);
                     }
                 } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
                     broadcastConnectionState(mTargetDevice, BluetoothProfile.STATE_CONNECTED,
                                              BluetoothProfile.STATE_CONNECTING);
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mCurrentDevice = mTargetDevice;
                         mTargetDevice = null;
                         transitionTo(mConnected);
@@ -407,31 +587,30 @@ final class A2dpStateMachine extends StateMachine {
                 } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
                     broadcastConnectionState(mIncomingDevice, BluetoothProfile.STATE_CONNECTED,
                                              BluetoothProfile.STATE_CONNECTING);
-                    // check for a2dp connection allowed for this device in race condition
-                    if (okToConnect(mIncomingDevice)) {
-                        logi("Ready to connect incoming Connection from pending state");
-                        synchronized (A2dpStateMachine.this) {
-                            mCurrentDevice = mIncomingDevice;
-                            mIncomingDevice = null;
-                            transitionTo(mConnected);
-                        }
-                    } else {
-                        // A2dp connection unchecked for this device
-                        loge("Incoming A2DP rejected from pending state");
-                        disconnectA2dpNative(getByteAddress(device));
+                    synchronized (A2dpSinkStateMachine.this) {
+                        mCurrentDevice = mIncomingDevice;
+                        mIncomingDevice = null;
+                        transitionTo(mConnected);
                     }
                 } else {
                     loge("Unknown device Connected: " + device);
                     // something is wrong here, but sync our state with stack
                     broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTED,
                                              BluetoothProfile.STATE_DISCONNECTED);
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mCurrentDevice = device;
                         mTargetDevice = null;
                         mIncomingDevice = null;
                         transitionTo(mConnected);
                     }
                 }
+                // the other profile connection should be initiated
+                AdapterService adapterService = AdapterService.getAdapterService();
+                if (adapterService != null) {
+                    adapterService.connectOtherProfile(device,
+                            AdapterService.PROFILE_CONN_CONNECTED);
+                }
+
                 break;
             case CONNECTION_STATE_CONNECTING:
                 if ((mCurrentDevice != null) && mCurrentDevice.equals(device)) {
@@ -448,10 +627,7 @@ final class A2dpStateMachine extends StateMachine {
                 } else {
                     // We get an incoming connecting request while Pending
                     // TODO(BT) is stack handing this case? let's ignore it for now
-                    log("Incoming connection while pending, accept it");
-                    broadcastConnectionState(device, BluetoothProfile.STATE_CONNECTING,
-                                             BluetoothProfile.STATE_DISCONNECTED);
-                    mIncomingDevice = device;
+                    log("Incoming connection while pending, ignore");
                 }
                 break;
             case CONNECTION_STATE_DISCONNECTING:
@@ -465,7 +641,7 @@ final class A2dpStateMachine extends StateMachine {
                 } else if (mIncomingDevice != null && mIncomingDevice.equals(device)) {
                     loge("IncomingDevice is getting disconnected");
                 } else {
-                    loge("Disconnecting unknow device: " + device);
+                    loge("Disconnecting unknown device: " + device);
                 }
                 break;
             default:
@@ -479,16 +655,10 @@ final class A2dpStateMachine extends StateMachine {
     private class Connected extends State {
         @Override
         public void enter() {
-            // Remove pending connection attempts that were deferred during the pending
-            // state. This is to prevent auto connect attempts from disconnecting
-            // devices that previously successfully connected.
-            // TODO: This needs to check for multiple A2DP connections, once supported...
-            removeDeferredMessages(CONNECT);
-
             log("Enter Connected: " + getCurrentMessage().what);
             // Upon connected, the audio starts out as stopped
-            broadcastAudioState(mCurrentDevice, BluetoothA2dp.STATE_NOT_PLAYING,
-                                BluetoothA2dp.STATE_PLAYING);
+            broadcastAudioState(mCurrentDevice, BluetoothA2dpSink.STATE_NOT_PLAYING,
+                                BluetoothA2dpSink.STATE_PLAYING);
         }
 
         @Override
@@ -516,7 +686,7 @@ final class A2dpStateMachine extends StateMachine {
                         break;
                     }
 
-                    synchronized (A2dpStateMachine.this) {
+                    synchronized (A2dpSinkStateMachine.this) {
                         mTargetDevice = device;
                         transitionTo(mPending);
                     }
@@ -535,9 +705,22 @@ final class A2dpStateMachine extends StateMachine {
                                        BluetoothProfile.STATE_DISCONNECTED);
                         break;
                     }
+
+                    if (mAudioFocusAcquired != AUDIO_FOCUS_LOSS) {
+                        releasePatch();
+                        int status = mAudioManager.abandonAudioFocus(mAudioFocusListener);
+                        if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                            mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
+                        }
+                     }
+                    mPlayingDevice = null;
+
                     transitionTo(mPending);
                 }
                     break;
+                case REQUEST_AUDIO_FOCUS:
+                    processAudioFocusRequestEvent(1, (BluetoothDevice) message.obj);
+                    break;
                 case STACK_EVENT:
                     StackEvent event = (StackEvent) message.obj;
                     switch (event.type) {
@@ -547,6 +730,9 @@ final class A2dpStateMachine extends StateMachine {
                         case EVENT_TYPE_AUDIO_STATE_CHANGED:
                             processAudioStateEvent(event.valueInt, event.device);
                             break;
+                        case EVENT_TYPE_AUDIO_CONFIG_CHANGED:
+                            processAudioConfigEvent(event.audioConfig, event.device);
+                            break;
                         default:
                             loge("Unexpected stack event: " + event.type);
                             break;
@@ -562,20 +748,25 @@ final class A2dpStateMachine extends StateMachine {
         private void processConnectionEvent(int state, BluetoothDevice device) {
             switch (state) {
                 case CONNECTION_STATE_DISCONNECTED:
+                    mAudioConfigs.remove(device);
+                    if ((mPlayingDevice != null) && (device.equals(mPlayingDevice))) {
+                        mPlayingDevice = null;
+                    }
                     if (mCurrentDevice.equals(device)) {
                         broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED,
                                                  BluetoothProfile.STATE_CONNECTED);
-                        synchronized (A2dpStateMachine.this) {
+                        synchronized (A2dpSinkStateMachine.this) {
                             mCurrentDevice = null;
                             transitionTo(mDisconnected);
                         }
-                    } else if (mTargetDevice != null && mTargetDevice.equals(device)) {
-                        broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTED,
-                                                 BluetoothProfile.STATE_CONNECTING);
-                        synchronized (A2dpStateMachine.this) {
-                            mTargetDevice = null;
+                        releasePatch();
+                        int status = mAudioManager.abandonAudioFocus(mAudioFocusListener);
+                        if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                             mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
+                        /* Check if we need to release patch here
+                         * Would we ever get disconnect directly without
+                         * Suspend or Stoppped being called before */
                         }
-                        logi("Disconnected from mTargetDevice in connected state device: " + device);
                     } else {
                         loge("Disconnected from unknown device: " + device);
                     }
@@ -591,22 +782,33 @@ final class A2dpStateMachine extends StateMachine {
                                                            mCurrentDevice);
                 return;
             }
+            log(" processAudioStateEvent in state " + state);
             switch (state) {
                 case AUDIO_STATE_STARTED:
-                    if (mPlayingA2dpDevice == null) {
-                        mPlayingA2dpDevice = device;
-                        mService.setAvrcpAudioState(BluetoothA2dp.STATE_PLAYING);
-                        broadcastAudioState(device, BluetoothA2dp.STATE_PLAYING,
-                                            BluetoothA2dp.STATE_NOT_PLAYING);
+                    if (mPlayingDevice == null) {
+                        mPlayingDevice = device;
                     }
+                    if(!USE_AUDIOTRACK)
+                        requestAudioFocus(true, device, 0);
                     break;
                 case AUDIO_STATE_REMOTE_SUSPEND:
                 case AUDIO_STATE_STOPPED:
-                    if (mPlayingA2dpDevice != null) {
-                        mPlayingA2dpDevice = null;
-                        mService.setAvrcpAudioState(BluetoothA2dp.STATE_NOT_PLAYING);
-                        broadcastAudioState(device, BluetoothA2dp.STATE_NOT_PLAYING,
-                                            BluetoothA2dp.STATE_PLAYING);
+                    mPlayingDevice = null;
+                    releasePatch();
+                    broadcastAudioState(device, BluetoothA2dpSink.STATE_NOT_PLAYING,
+                                        BluetoothA2dpSink.STATE_PLAYING);
+                    if (mAudioFocusAcquired == AUDIO_FOCUS_LOSS) {
+                       /* Audio Focus was already lost, no need to do it again */
+                       return;
+                    }
+                    if ((mAudioFocusAcquired == AUDIO_FOCUS_LOSS_TRANSIENT) &&
+                                     (state == AUDIO_STATE_REMOTE_SUSPEND)) {
+                        log(" Dont't Loose audiofocus in case of suspend ");
+                        break;
+                    }
+                    int status = mAudioManager.abandonAudioFocus(mAudioFocusListener);
+                    if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                        mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
                     }
                     break;
                 default:
@@ -614,6 +816,41 @@ final class A2dpStateMachine extends StateMachine {
                   break;
             }
         }
+
+        private void processAudioFocusRequestEvent(int enable, BluetoothDevice device) {
+            if ((mCurrentDevice != null) && (mCurrentDevice.equals(device))
+                    && (1 == enable)) {
+
+                if (mAudioFocusAcquired == AUDIO_FOCUS_LOSS_TRANSIENT) {
+                    log(" Transient Loss Still, Don't acquire focus, Send PAUSE");
+                    SendPassThruPause(device);
+                    if(USE_AUDIOTRACK)
+                        informAudioFocusStateNative(STATE_FOCUS_LOST);
+                    return;
+                }
+                else if (mAudioFocusAcquired == AUDIO_FOCUS_GAIN) {
+                    patchPorts();
+                    return; /* if we already have focus, don't request again */
+                }
+                int status = mAudioManager.requestAudioFocus(mAudioFocusListener,
+                                  AudioManager.STREAM_MUSIC,AudioManager.AUDIOFOCUS_GAIN);
+                log(" Audio Focus Request returned " + status);
+                if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                    mAudioFocusAcquired = AUDIO_FOCUS_GAIN;
+                    patchPorts();
+                }
+                else {
+                    log("Can't acquire Focus, request with delay");
+                    requestAudioFocus(true, device, AUDIO_FOCUS_REQUEST_MESSAGE_DELAYED);
+                }
+            }
+        }
+    }
+
+    private void processAudioConfigEvent(BluetoothAudioConfig audioConfig, BluetoothDevice device) {
+        log("processAudioConfigEvent: " + device);
+        mAudioConfigs.put(device, audioConfig);
+        broadcastAudioConfig(device, audioConfig);
     }
 
     int getConnectionState(BluetoothDevice device) {
@@ -648,6 +885,10 @@ final class A2dpStateMachine extends StateMachine {
         }
     }
 
+    BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
+        return mAudioConfigs.get(device);
+    }
+
     List<BluetoothDevice> getConnectedDevices() {
         List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
         synchronized(this) {
@@ -660,13 +901,25 @@ final class A2dpStateMachine extends StateMachine {
 
     boolean isPlaying(BluetoothDevice device) {
         synchronized(this) {
-            if (device.equals(mPlayingA2dpDevice)) {
+            if ((mPlayingDevice != null) && (device.equals(mPlayingDevice))) {
                 return true;
             }
         }
         return false;
     }
 
+    void informAvrcpStatePlaying(BluetoothDevice device) {
+        if ((mPlayingDevice != null) && (device.equals(mPlayingDevice))) {
+            log(" AVRCP State is Playing");
+            /* If call is ongoing, Focus already acquired, no need to
+             * send this info to bluedroid
+             */
+            if(mAudioFocusAcquired == AUDIO_FOCUS_LOSS_TRANSIENT)
+                SendPassThruPause(device);
+            if((USE_AUDIOTRACK) && (mAudioFocusAcquired == AUDIO_FOCUS_LOSS))
+                informAudioFocusStateNative(STATE_FOCUS_READY);
+        }
+    }
     boolean okToConnect(BluetoothDevice device) {
         AdapterService adapterService = AdapterService.getAdapterService();
         int priority = mService.getPriority(device);
@@ -695,7 +948,7 @@ final class A2dpStateMachine extends StateMachine {
 
         for (BluetoothDevice device : bondedDevices) {
             ParcelUuid[] featureUuids = device.getUuids();
-            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.AudioSink)) {
+            if (!BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.AudioSource)) {
                 continue;
             }
             connectionState = getConnectionState(device);
@@ -712,8 +965,10 @@ final class A2dpStateMachine extends StateMachine {
     // This method does not check for error conditon (newState == prevState)
     private void broadcastConnectionState(BluetoothDevice device, int newState, int prevState) {
 
-        int delay = mAudioManager.setBluetoothA2dpDeviceConnectionState(device, newState,
-                BluetoothProfile.A2DP);
+       int delay = 0;
+       if(!USE_AUDIOTRACK)
+           delay = mAudioManager.setBluetoothA2dpDeviceConnectionState(device, newState,
+                BluetoothProfile.A2DP_SINK);
 
         mWakeLock.acquire();
         mIntentBroadcastHandler.sendMessageDelayed(mIntentBroadcastHandler.obtainMessage(
@@ -725,16 +980,26 @@ final class A2dpStateMachine extends StateMachine {
     }
 
     private void broadcastAudioState(BluetoothDevice device, int state, int prevState) {
-        Intent intent = new Intent(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED);
+        Intent intent = new Intent(BluetoothA2dpSink.ACTION_PLAYING_STATE_CHANGED);
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
         intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
         intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
-        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        mContext.sendBroadcast(intent, A2dpService.BLUETOOTH_PERM);
+//FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
 
         log("A2DP Playing state : device: " + device + " State:" + prevState + "->" + state);
     }
 
+    private void broadcastAudioConfig(BluetoothDevice device, BluetoothAudioConfig audioConfig) {
+        Intent intent = new Intent(BluetoothA2dpSink.ACTION_AUDIO_CONFIG_CHANGED);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+        intent.putExtra(BluetoothA2dpSink.EXTRA_AUDIO_CONFIG, audioConfig);
+//FIXME        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
+
+        log("A2DP Audio Config : device: " + device + " config: " + audioConfig);
+    }
+
     private byte[] getByteAddress(BluetoothDevice device) {
         return Utils.getBytesFromAddress(device.getAddress());
     }
@@ -752,6 +1017,32 @@ final class A2dpStateMachine extends StateMachine {
         event.device = getDevice(address);
         sendMessage(STACK_EVENT, event);
     }
+
+    private void onAudioConfigChanged(byte[] address, int sampleRate, int channelCount) {
+        StackEvent event = new StackEvent(EVENT_TYPE_AUDIO_CONFIG_CHANGED);
+        int channelConfig = (channelCount == 1 ? AudioFormat.CHANNEL_IN_MONO
+                                               : AudioFormat.CHANNEL_IN_STEREO);
+        event.audioConfig = new BluetoothAudioConfig(sampleRate, channelConfig,
+                AudioFormat.ENCODING_PCM_16BIT);
+        event.device = getDevice(address);
+        sendMessage(STACK_EVENT, event);
+    }
+
+    private void onAudioFocusRequested(byte[] address) {
+        BluetoothDevice device = getDevice(address);
+        if(device.equals(mPlayingDevice))
+            requestAudioFocus(true, device, 0);
+    }
+
+    private void requestAudioFocus(boolean enable, BluetoothDevice device, int delay) {
+        log(" requestAudioFocus for  " + device + " enable " + enable);
+        if (enable) {
+            // send a request for audio_focus
+            Message posMsg = obtainMessage(REQUEST_AUDIO_FOCUS, device);
+            sendMessageDelayed(posMsg, delay);
+        }
+    }
+
     private BluetoothDevice getDevice(byte[] address) {
         return mAdapter.getRemoteDevice(Utils.getAddressStringFromByte(address));
     }
@@ -760,6 +1051,7 @@ final class A2dpStateMachine extends StateMachine {
         int type = EVENT_TYPE_NONE;
         int valueInt = 0;
         BluetoothDevice device = null;
+        BluetoothAudioConfig audioConfig = null;
 
         private StackEvent(int type) {
             this.type = type;
@@ -769,14 +1061,15 @@ final class A2dpStateMachine extends StateMachine {
     private class IntentBroadcastHandler extends Handler {
 
         private void onConnectionStateChanged(BluetoothDevice device, int prevState, int state) {
-            Intent intent = new Intent(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
+            Intent intent = new Intent(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
             intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, prevState);
             intent.putExtra(BluetoothProfile.EXTRA_STATE, state);
             intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
-            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+//FIXME            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
             mContext.sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
             log("Connection state " + device + ": " + prevState + "->" + state);
-            mService.notifyProfileConnectionStateChanged(device, BluetoothProfile.A2DP, state, prevState);
+            mService.notifyProfileConnectionStateChanged(device, BluetoothProfile.A2DP_SINK,
+                    state, prevState);
         }
 
         @Override
@@ -790,18 +1083,137 @@ final class A2dpStateMachine extends StateMachine {
         }
     }
 
-    public void dump(StringBuilder sb) {
-        ProfileService.println(sb, "mCurrentDevice: " + mCurrentDevice);
-        ProfileService.println(sb, "mTargetDevice: " + mTargetDevice);
-        ProfileService.println(sb, "mIncomingDevice: " + mIncomingDevice);
-        ProfileService.println(sb, "mPlayingA2dpDevice: " + mPlayingA2dpDevice);
-        ProfileService.println(sb, "StateMachine: " + this.toString());
+    public boolean SendPassThruPlay(BluetoothDevice mDevice) {
+            log("SendPassThruPlay + ");
+            AvrcpControllerService avrcpCtrlService = AvrcpControllerService.getAvrcpControllerService();
+            if ((avrcpCtrlService != null) && (mDevice != null) &&
+                (avrcpCtrlService.getConnectedDevices().contains(mDevice))){
+                avrcpCtrlService.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_PRESSED);
+                avrcpCtrlService.sendPassThroughCmd(mDevice, AVRC_ID_PLAY, KEY_STATE_RELEASED);
+                log(" SendPassThruPlay command sent - ");
+                return true;
+            } else {
+                log("passthru command not sent, connection unavailable");
+                return false;
+            }
+        }
+
+    public boolean SendPassThruPause(BluetoothDevice mDevice) {
+        log("SendPassThruPause + ");
+        AvrcpControllerService avrcpCtrlService = AvrcpControllerService.getAvrcpControllerService();
+        if ((avrcpCtrlService != null) && (mDevice != null) &&
+            (avrcpCtrlService.getConnectedDevices().contains(mDevice))){
+            avrcpCtrlService.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_PRESSED);
+            avrcpCtrlService.sendPassThroughCmd(mDevice, AVRC_ID_PAUSE, KEY_STATE_RELEASED);
+            log(" SendPassThruPause command sent - ");
+            return true;
+        } else {
+            log("passthru command not sent, connection unavailable");
+            return false;
+        }
     }
 
+    private final BroadcastReceiver mA2dpReceiver = new BroadcastReceiver() {
+        @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                log("onReceive  " + action);
+                if (action.equals("com.android.music.musicservicecommand")) {
+                    String cmd = intent.getStringExtra("command");
+                    log("Command Received  " + cmd);
+                    if (cmd.equals("pause")) {
+                        if (mCurrentDevice != null) {
+                            if (SendPassThruPause(mCurrentDevice)) {
+                                log(" Sending AVRCP Pause");
+                            } else {
+                                log(" Sending Disconnect AVRCP Not Up");
+                                disconnectA2dpNative(getByteAddress(mCurrentDevice));
+                            }
+                            releasePatch();
+                            if (mAudioFocusAcquired != AUDIO_FOCUS_LOSS) {
+                                int status = mAudioManager.abandonAudioFocus(mAudioFocusListener);
+                                log("abandonAudioFocus returned" + status);
+                                if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                                    mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        };
+
+    private OnAudioFocusChangeListener mAudioFocusListener = new OnAudioFocusChangeListener() {
+        public void onAudioFocusChange(int focusChange){
+            log("onAudioFocusChangeListener focuschange " + focusChange);
+            switch(focusChange){
+                case AudioManager.AUDIOFOCUS_LOSS:
+                    if (mCurrentDevice != null) {
+                        /* First Release the Patch Anyways */
+                        if (SendPassThruPause(mCurrentDevice)) {
+                            log(" Sending AVRCP Pause");
+                        } else {
+                            log(" Sending Disconnect AVRCP Not Up");
+                            disconnectA2dpNative(getByteAddress(mCurrentDevice));
+                        }
+                        if(USE_AUDIOTRACK)
+                            informAudioFocusStateNative(STATE_FOCUS_LOST);
+                        int status = mAudioManager.abandonAudioFocus(mAudioFocusListener);
+                        log("abandonAudioFocus returned" + status);
+                        if (status == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                            mAudioFocusAcquired = AUDIO_FOCUS_LOSS;
+                        }
+                    }
+                    break;
+                case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+                    if ((mCurrentDevice != null) && (getCurrentState() == mConnected)) {
+                    /* don't abandon focus, but fake focus loss */
+                       mAudioFocusAcquired = AUDIO_FOCUS_LOSS_TRANSIENT;
+                       if (SendPassThruPause(mCurrentDevice)) {
+                            log(" Sending AVRCP Pause");
+                        } else {
+                            log(" AVRCP Connection not UP");
+                            disconnectA2dpNative(getByteAddress(mCurrentDevice));
+                            /* TODO what shld we do in case AVRCP connection is not there */
+                        }
+                       if(USE_AUDIOTRACK)
+                           informAudioFocusStateNative(STATE_FOCUS_LOST);
+                    }
+                    break;
+                case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+                    log(" Received AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK ");
+                    mAudioFocusAcquired = AUDIO_FOCUS_LOSS_CAN_DUCK;
+                    break;
+                case AudioManager.AUDIOFOCUS_GAIN:
+                    // we got focus gain
+                    if ((mCurrentDevice != null) && (getCurrentState() == mConnected)) {
+                        if (mAudioFocusAcquired == AUDIO_FOCUS_LOSS_CAN_DUCK) {
+                            log(" Received Can_Duck earlier, Ignore Now ");
+                            mAudioFocusAcquired = AUDIO_FOCUS_GAIN;
+                            break;
+                        }
+                        mAudioFocusAcquired = AUDIO_FOCUS_GAIN;
+                        if (SendPassThruPlay(mCurrentDevice)) {
+                            log(" Sending AVRCP Play");
+                        } else {
+                            log(" AVRCP Connection not up");
+                            /* TODO what shld we do in case AVRCP connection is not there */
+                        }
+                        if(USE_AUDIOTRACK)
+                            informAudioFocusStateNative(STATE_FOCUS_GRANTED);
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
     // Event types for STACK_EVENT message
     final private static int EVENT_TYPE_NONE = 0;
     final private static int EVENT_TYPE_CONNECTION_STATE_CHANGED = 1;
     final private static int EVENT_TYPE_AUDIO_STATE_CHANGED = 2;
+    final private static int EVENT_TYPE_AUDIO_CONFIG_CHANGED = 3;
 
    // Do not modify without updating the HAL bt_av.h files.
 
@@ -817,8 +1229,10 @@ final class A2dpStateMachine extends StateMachine {
     final static int AUDIO_STATE_STARTED = 2;
 
     private native static void classInitNative();
-    private native void initNative();
+    private native void initNative(int maxA2dpConnectionsAllowed,
+            int multiCastState);
     private native void cleanupNative();
     private native boolean connectA2dpNative(byte[] address);
     private native boolean disconnectA2dpNative(byte[] address);
+    private native void informAudioFocusStateNative(int focusGranted);
 }
diff --git a/src/com/android/bluetooth/avrcp/Avrcp.java b/src/com/android/bluetooth/avrcp/Avrcp.java
index abc0b84..dfdb42c 100755
--- a/src/com/android/bluetooth/avrcp/Avrcp.java
+++ b/src/com/android/bluetooth/avrcp/Avrcp.java
@@ -1,4 +1,7 @@
 /*
+ * Copyright (C) 2013-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2012 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -20,10 +23,13 @@ import java.util.Timer;
 import java.util.TimerTask;
 
 import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothA2dp;
 import android.bluetooth.BluetoothAvrcp;
+import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.graphics.Bitmap;
 import android.media.AudioManager;
 import android.media.IRemoteControlDisplay;
@@ -45,6 +51,8 @@ import android.os.SystemClock;
 import android.util.Log;
 import android.view.KeyEvent;
 
+import android.content.BroadcastReceiver;
+import com.android.bluetooth.a2dp.A2dpService;
 import com.android.bluetooth.btservice.AdapterService;
 import com.android.bluetooth.btservice.ProfileService;
 import com.android.bluetooth.Utils;
@@ -56,6 +64,17 @@ import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
+import java.util.Iterator;
+
+import android.provider.MediaStore;
+import android.content.ContentResolver;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteException;
+import android.net.Uri;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+
 /**
  * support Bluetooth AVRCP profile.
  * support metadata, play status and event notification
@@ -66,37 +85,40 @@ public final class Avrcp {
 
     private Context mContext;
     private final AudioManager mAudioManager;
+    private A2dpService mA2dpService;
     private AvrcpMessageHandler mHandler;
     private RemoteController mRemoteController;
     private RemoteControllerWeak mRemoteControllerCb;
+    private AvrcpRemoteControllerWeak mAvrcpRemoteControllerCb;
     private Metadata mMetadata;
     private int mTransportControlFlags;
-    private int mCurrentPlayState;
+    private int mCurrentPlayerState;
     private int mPlayStatusChangedNT;
     private int mTrackChangedNT;
-    private long mTrackNumber;
     private long mCurrentPosMs;
     private long mPlayStartTimeMs;
+    private long mTrackNumber;
     private long mSongLengthMs;
     private long mPlaybackIntervalMs;
     private int mPlayPosChangedNT;
-    private long mNextPosMs;
-    private long mPrevPosMs;
     private long mSkipStartTime;
-    private int mFeatures;
-    private int mAbsoluteVolume;
-    private int mLastSetVolume;
-    private int mLastDirection;
     private final int mVolumeStep;
     private final int mAudioStreamMax;
-    private boolean mVolCmdInProgress;
-    private int mAbsVolRetryTimes;
+    private static final String BLUETOOTH_ADMIN_PERM = android.Manifest.permission.BLUETOOTH_ADMIN;
+    private static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
     private int mSkipAmount;
+    private final BluetoothAdapter mAdapter;
+    private static Uri mMediaUriStatic;
+    private static long currentTrackPos;
+    private static boolean updatePlayTime;
+    private static boolean updateValues;
+    private int mAddressedPlayerId;
 
     /* BTRC features */
     public static final int BTRC_FEAT_METADATA = 0x01;
     public static final int BTRC_FEAT_ABSOLUTE_VOLUME = 0x02;
     public static final int BTRC_FEAT_BROWSE = 0x04;
+    public static final int BTRC_FEAT_AVRC_UI_UPDATE = 0x08;
 
     /* AVRC response codes, from avrc_defs */
     private static final int AVRC_RSP_NOT_IMPL = 8;
@@ -120,10 +142,32 @@ public final class Avrcp {
     private static final int MESSAGE_REWIND = 11;
     private static final int MESSAGE_CHANGE_PLAY_POS = 12;
     private static final int MESSAGE_SET_A2DP_AUDIO_STATE = 13;
+    private static final int MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT = 14;
+
+    private static final int AVRCP_BR_RSP_TIMEOUT = 2000;
+    private static final int MESSAGE_SEND_PASS_THROUGH_CMD = 2001;
+    private static final int MESSAGE_SET_ADDR_PLAYER = 2002;
+    private static final int MESSAGE_GET_FOLDER_ITEMS = 2003;
+    private static final int MESSAGE_SET_BROWSED_PLAYER = 2004;
+    private static final int MESSAGE_CHANGE_PATH = 2005;
+    private static final int MESSAGE_PLAY_ITEM = 2006;
+    private static final int MESSAGE_GET_ITEM_ATTRS = 2007;
+
+    private CachedRequest mCachedRequest = null;
+
     private static final int MSG_UPDATE_STATE = 100;
     private static final int MSG_SET_METADATA = 101;
     private static final int MSG_SET_TRANSPORT_CONTROLS = 102;
     private static final int MSG_SET_GENERATION_ID = 104;
+    private static final int MSG_UPDATE_AVAILABLE_PLAYERS = 201;
+    private static final int MSG_UPDATE_ADDRESSED_PLAYER = 202;
+    private static final int MSG_UPDATE_RCC_CHANGE = 203;
+    private static final int MSG_UPDATE_BROWSED_PLAYER_FOLDER = 204;
+    private static final int MSG_UPDATE_NOW_PLAYING_CONTENT_CHANGED = 205;
+    private static final int MSG_PLAY_ITEM_RESPONSE = 206;
+    private static final int MSG_NOW_PLAYING_ENTRIES_RECEIVED = 207;
+
+    private MediaPlayerInfo mediaPlayerInfo1;
 
     private static final int BUTTON_TIMEOUT_TIME = 2000;
     private static final int BASE_SKIP_AMOUNT = 2000;
@@ -136,32 +180,230 @@ public final class Avrcp {
     private static final int MAX_ERROR_RETRY_TIMES = 3;
     private static final int AVRCP_MAX_VOL = 127;
     private static final int AVRCP_BASE_VOLUME_STEP = 1;
+    private final static int MESSAGE_PLAYERSETTINGS_TIMEOUT = 602;
+
+    private static final int AVRCP_CONNECTED = 1;
+    public  static final int KEY_STATE_PRESSED = 0;
+    public  static final int KEY_STATE_RELEASED = 1;
+
+    private final static int TYPE_MEDIA_PLAYER_ITEM = 0x01;
+    private final static int TYPE_FOLDER_ITEM = 0x02;
+    private final static int TYPE_MEDIA_ELEMENT_ITEM = 0x03;
+
+    private final static int FOLDER_UP = 0x00;
+    private final static int FOLDER_DOWN = 0x01;
+
+    private static final String PATH_INVALID = "invalid";
+    private static final String PATH_ROOT = "root";
+    private static final String PATH_TITLES = "titles";
+    private static final String PATH_ALBUMS = "albums";
+    private static final String PATH_ARTISTS = "artists";
+    private static final String PATH_PLAYLISTS = "playlists";
+
+    private final static long UID_TITLES = 0x01;
+    private final static long UID_ALBUM = 0x02;
+    private final static long UID_ARTIST = 0x03;
+    private final static long UID_PLAYLIST = 0x04;
+    private final static int NUM_ROOT_ELEMENTS = 0x04;
+
+    private static final int INTERNAL_ERROR = 0x03;
+    private static final int OPERATION_SUCCESSFUL = 0x04;
+    private static final int INVALID_DIRECTION = 0x07;
+    private static final int NOT_A_DIRECTORY = 0x08;
+    private static final int DOES_NOT_EXIST = 0x09;
+    private static final int INVALID_SCOPE = 0x0a;
+    private static final int RANGE_OUT_OF_BOUNDS = 0x0b;
+    private static final int UID_A_DIRECTORY = 0x0c;
+    private static final int MEDIA_IN_USE = 0x0d;
+    private static final int INVALID_PLAYER_ID = 0x11;
+    private static final int PLAYER_NOT_BROWSABLE = 0x12;
+    private static final int PLAYER_NOT_ADDRESSED = 0x13;
+
+    private static final int FOLDER_TYPE_MIXED = 0x00;
+    private static final int FOLDER_TYPE_TITLES = 0x01;
+    private static final int FOLDER_TYPE_ALBUMS = 0x02;
+    private static final int FOLDER_TYPE_ARTISTS = 0x03;
+    private static final int FOLDER_TYPE_GENRES = 0x04;
+    private static final int FOLDER_TYPE_PLAYLISTS = 0x05;
+
+    private static final int MEDIA_TYPE_AUDIO = 0X00;
+    private static final int MEDIA_TYPE_VIDEO = 0X01;
+
+    private static final int MAX_BROWSE_ITEM_TO_SEND = 0x03;
+    private static final int MAX_ATTRIB_COUNT = 0x07;
+
+    private final static int ALBUMS_ITEM_INDEX = 0;
+    private final static int ARTISTS_ITEM_INDEX = 1;
+    private final static int PLAYLISTS_ITEM_INDEX = 2;
+    private final static int TITLES_ITEM_INDEX = 3;
+
+    //Intents for PlayerApplication Settings
+    private static final String PLAYERSETTINGS_REQUEST =
+            "org.codeaurora.music.playersettingsrequest";
+    private static final String PLAYERSETTINGS_RESPONSE =
+           "org.codeaurora.music.playersettingsresponse";
+    // Max number of Avrcp connections at any time
+    private int maxAvrcpConnections = 1;
+    BluetoothDevice mBrowserDevice = null;
+    private static final int INVALID_DEVICE_INDEX = 0xFF;
+    // codes for reset of of notifications
+    private static final int PLAY_POSITION_CHANGE_NOTIFICATION = 101;
+    private static final int PLAY_STATUS_CHANGE_NOTIFICATION = 102;
+    private static final int TRACK_CHANGE_NOTIFICATION = 103;
+    private static final int NOW_PALYING_CONTENT_CHANGED_NOTIFICATION = 104;
+
+    private static final int INVALID_ADDRESSED_PLAYER_ID = -1;
+    // Device dependent registered Notification & Variables
+    private class DeviceDependentFeature {
+        private BluetoothDevice mCurrentDevice;
+        private int mCurrentPlayState;
+        private int mPlayStatusChangedNT;
+        private int mPlayerStatusChangeNT;
+        private int mTrackChangedNT;
+        private long mNextPosMs;
+        private long mPrevPosMs;
+        private long mPlaybackIntervalMs;
+        private int mPlayPosChangedNT;
+        private int mFeatures;
+        private int mAbsoluteVolume;
+        private int mLastSetVolume;
+        private int mLastDirection;
+        private boolean mVolCmdInProgress;
+        private int mAbsVolRetryTimes;
+        private int keyPressState;
+        private int mAddressedPlayerChangedNT;
+        private int mAvailablePlayersChangedNT;
+        private int mNowPlayingContentChangedNT;
+        private String mRequestedAddressedPlayerPackageName;
+        private String mCurrentPath;
+        private String mCurrentPathUid;
+        private Uri mMediaUri;
+        private boolean isMusicAppResponsePending;
+        private boolean isBrowsingSupported;
+        private boolean isAbsoluteVolumeSupportingDevice;
+
+        public DeviceDependentFeature() {
+            mCurrentDevice = null;
+            mCurrentPlayState = RemoteControlClient.PLAYSTATE_NONE;
+            mPlayStatusChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mPlayerStatusChangeNT = NOTIFICATION_TYPE_CHANGED;
+            mTrackChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mPlaybackIntervalMs = 0L;
+            mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mFeatures = 0;
+            mAbsoluteVolume = -1;
+            mLastSetVolume = -1;
+            mLastDirection = 0;
+            mVolCmdInProgress = false;
+            mAbsVolRetryTimes = 0;
+            mSkipAmount = 0;
+            keyPressState = KEY_STATE_RELEASE; //Key release state
+            mAddressedPlayerChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mAvailablePlayersChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mNowPlayingContentChangedNT = NOTIFICATION_TYPE_CHANGED;
+            mRequestedAddressedPlayerPackageName = null;
+            mCurrentPath = PATH_INVALID;
+            mCurrentPathUid = null;
+            mMediaUri = Uri.EMPTY;
+            isMusicAppResponsePending = false;
+            isBrowsingSupported = false;
+            isAbsoluteVolumeSupportingDevice = false;
+
+        }
+    };
+
+    private class PlayerSettings {
+        public byte attr;
+        public byte [] attrIds;
+        public String path;
+    };
+
+    private PlayerSettings mPlayerSettings = new PlayerSettings();
+    private class localPlayerSettings {
+        public byte eq_value = 0x01;
+        public byte repeat_value = 0x01;
+        public byte shuffle_value = 0x01;
+        public byte scan_value = 0x01;
+    };
+    private localPlayerSettings settingValues = new localPlayerSettings();
+    private static final String COMMAND = "command";
+    private static final String CMDGET = "get";
+    private static final String CMDSET = "set";
+    private static final String EXTRA_GET_COMMAND = "commandExtra";
+    private static final String EXTRA_GET_RESPONSE = "Response";
+
+    private static final int GET_ATTRIBUTE_IDS = 0;
+    private static final int GET_VALUE_IDS = 1;
+    private static final int GET_ATTRIBUTE_TEXT = 2;
+    private static final int GET_VALUE_TEXT     = 3;
+    private static final int GET_ATTRIBUTE_VALUES = 4;
+    private static final int NOTIFY_ATTRIBUTE_VALUES = 5;
+    private static final int SET_ATTRIBUTE_VALUES  = 6;
+    private static final int GET_INVALID = 0xff;
+
+    private static final String EXTRA_ATTRIBUTE_ID = "Attribute";
+    private static final String EXTRA_VALUE_STRING_ARRAY = "ValueStrings";
+    private static final String EXTRA_ATTRIB_VALUE_PAIRS = "AttribValuePairs";
+    private static final String EXTRA_ATTRIBUTE_STRING_ARRAY = "AttributeStrings";
+    private static final String EXTRA_VALUE_ID_ARRAY = "Values";
+    private static final String EXTRA_ATTIBUTE_ID_ARRAY = "Attributes";
+
+    public static final int VALUE_SHUFFLEMODE_OFF = 1;
+    public static final int VALUE_SHUFFLEMODE_ALL = 2;
+    public static final int VALUE_REPEATMODE_OFF = 1;
+    public static final int VALUE_REPEATMODE_SINGLE = 2;
+    public static final int VALUE_REPEATMODE_ALL = 3;
+    public static final int VALUE_INVALID = 0;
+    public static final int ATTRIBUTE_NOTSUPPORTED = -1;
+
+    public static final int ATTRIBUTE_EQUALIZER = 1;
+    public static final int ATTRIBUTE_REPEATMODE = 2;
+    public static final int ATTRIBUTE_SHUFFLEMODE = 3;
+    public static final int ATTRIBUTE_SCANMODE = 4;
+    public static final int NUMPLAYER_ATTRIBUTE = 2;
+
+
+    private byte [] def_attrib = new byte [] {ATTRIBUTE_REPEATMODE, ATTRIBUTE_SHUFFLEMODE};
+    private byte [] value_repmode = new byte [] { VALUE_REPEATMODE_OFF,
+                                                  VALUE_REPEATMODE_SINGLE,
+                                                  VALUE_REPEATMODE_ALL };
+
+    private byte [] value_shufmode = new byte [] { VALUE_SHUFFLEMODE_OFF,
+                                                  VALUE_SHUFFLEMODE_ALL };
+    private byte [] value_default = new byte [] {0};
+    private final String UPDATE_ATTRIBUTES = "UpdateSupportedAttributes";
+    private final String UPDATE_VALUES = "UpdateSupportedValues";
+    private final String UPDATE_ATTRIB_VALUE = "UpdateCurrentValues";
+    private final String UPDATE_ATTRIB_TEXT = "UpdateAttributesText";
+    private final String UPDATE_VALUE_TEXT = "UpdateValuesText";
+    private ArrayList <Integer> mPendingCmds;
+    private ArrayList <Integer> mPendingSetAttributes;
+    DeviceDependentFeature[] deviceFeatures;
 
     static {
         classInitNative();
     }
 
-    private Avrcp(Context context) {
+    private Avrcp(Context context, A2dpService svc, int maxConnections ) {
+        if (DEBUG)
+            Log.v(TAG, "Avrcp");
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
         mMetadata = new Metadata();
-        mCurrentPlayState = RemoteControlClient.PLAYSTATE_NONE; // until we get a callback
-        mPlayStatusChangedNT = NOTIFICATION_TYPE_CHANGED;
-        mTrackChangedNT = NOTIFICATION_TYPE_CHANGED;
         mTrackNumber = -1L;
-        mCurrentPosMs = 0L;
+        mCurrentPosMs = -1L;
         mPlayStartTimeMs = -1L;
         mSongLengthMs = 0L;
-        mPlaybackIntervalMs = 0L;
-        mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
-        mFeatures = 0;
-        mAbsoluteVolume = -1;
-        mLastSetVolume = -1;
-        mLastDirection = 0;
-        mVolCmdInProgress = false;
-        mAbsVolRetryTimes = 0;
-
+        mA2dpService = svc;
+        maxAvrcpConnections = maxConnections;
+        deviceFeatures = new DeviceDependentFeature[maxAvrcpConnections];
+        mAddressedPlayerId = INVALID_ADDRESSED_PLAYER_ID;
+        mCurrentPlayerState = RemoteControlClient.PLAYSTATE_NONE;
+        for(int i = 0; i < maxAvrcpConnections; i++) {
+            deviceFeatures[i] = new DeviceDependentFeature();
+        }
         mContext = context;
 
-        initNative();
+        initNative(maxConnections);
 
         mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
         mAudioStreamMax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
@@ -169,33 +411,295 @@ public final class Avrcp {
     }
 
     private void start() {
+        if (DEBUG)
+            Log.v(TAG, "start");
         HandlerThread thread = new HandlerThread("BluetoothAvrcpHandler");
         thread.start();
         Looper looper = thread.getLooper();
         mHandler = new AvrcpMessageHandler(looper);
+        mPendingCmds = new ArrayList<Integer>();
+        mPendingSetAttributes = new ArrayList<Integer>();
+        // clear path for all devices
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+           deviceFeatures[i].mCurrentPath = PATH_INVALID;
+           deviceFeatures[i].mCurrentPathUid = null;
+           deviceFeatures[i].mMediaUri = Uri.EMPTY;
+        }
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(AudioManager.RCC_CHANGED_ACTION);
+        intentFilter.addAction(PLAYERSETTINGS_RESPONSE);
+        try {
+            mContext.registerReceiver(mIntentReceiver, intentFilter);
+        }catch (Exception e) {
+            Log.e(TAG,"Unable to register Avrcp receiver", e);
+        }
+        registerMediaPlayers();
         mRemoteControllerCb = new RemoteControllerWeak(mHandler);
-        mRemoteController = new RemoteController(mContext, mRemoteControllerCb);
+        mAvrcpRemoteControllerCb = new AvrcpRemoteControllerWeak(mHandler);
+        mRemoteController = new RemoteController(mContext, mRemoteControllerCb,
+                                                    null, mAvrcpRemoteControllerCb);
         mAudioManager.registerRemoteController(mRemoteController);
         mRemoteController.setSynchronizationMode(RemoteController.POSITION_SYNCHRONIZATION_CHECK);
     }
 
-    public static Avrcp make(Context context) {
-        if (DEBUG) Log.v(TAG, "make");
-        Avrcp ar = new Avrcp(context);
+    //Listen to intents from MediaPlayer and Audio Manager and update data structures
+    private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(AudioManager.RCC_CHANGED_ACTION)) {
+                Log.v(TAG, "received RCC_CHANGED_ACTION");
+                int isRCCFocussed = 0;
+                int isRCCAvailable = 0;
+                String callingPackageName =
+                        intent.getStringExtra(AudioManager.EXTRA_CALLING_PACKAGE_NAME);
+                boolean isFocussed =
+                        intent.getBooleanExtra(AudioManager.EXTRA_FOCUS_CHANGED_VALUE,
+                        false);
+                boolean isAvailable =
+                        intent.getBooleanExtra(AudioManager.EXTRA_AVAILABLITY_CHANGED_VALUE,
+                        false);
+                if (isFocussed)
+                    isRCCFocussed = 1;
+                if (isAvailable)
+                    isRCCAvailable = 1;
+                Log.v(TAG, "focus: " + isFocussed + " , availability: " + isAvailable);
+                if (mHandler != null) {
+                    mHandler.obtainMessage(MSG_UPDATE_RCC_CHANGE, isRCCFocussed,
+                            isRCCAvailable, callingPackageName).sendToTarget();
+                }
+            } else if (action.equals(PLAYERSETTINGS_RESPONSE)) {
+                int getResponse = intent.getIntExtra(EXTRA_GET_RESPONSE,
+                                                      GET_INVALID);
+                byte [] data;
+                String [] text;
+                boolean isSetAttrValRsp = false;
+                BluetoothDevice device = null;
+
+                synchronized (mPendingCmds) {
+                    Integer val = new Integer(getResponse);
+                    if (mPendingCmds.contains(val)) {
+                        if (getResponse == SET_ATTRIBUTE_VALUES) {
+                            isSetAttrValRsp = true;
+                            if (DEBUG) Log.v(TAG,"Response received for SET_ATTRIBUTE_VALUES");
+                        }
+                        mHandler.removeMessages(MESSAGE_PLAYERSETTINGS_TIMEOUT);
+                        mPendingCmds.remove(val);
+                    }
+                }
+                for (int i = 0; i < maxAvrcpConnections; i++) {
+                    if (deviceFeatures[i].isMusicAppResponsePending ==
+                            true) {
+                        device = deviceFeatures[i].mCurrentDevice;
+                        deviceFeatures[i].isMusicAppResponsePending = false;
+                        break;
+                    }
+                }
+
+                if (DEBUG)
+                    Log.v(TAG,"getResponse" + getResponse);
+                switch (getResponse) {
+                    case GET_ATTRIBUTE_IDS:
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!! device is null");
+                            return;
+                        }
+                        data = intent.getByteArrayExtra(EXTRA_ATTIBUTE_ID_ARRAY);
+                        byte numAttr = (byte) data.length;
+                        if (DEBUG)
+                            Log.v(TAG,"GET_ATTRIBUTE_IDS");
+                        getListPlayerappAttrRspNative(numAttr ,
+                                data ,getByteAddress(device));
+
+                    break;
+                    case GET_VALUE_IDS:
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!! device is null");
+                            return;
+                        }
+                        data = intent.getByteArrayExtra(EXTRA_VALUE_ID_ARRAY);
+                        numAttr = (byte) data.length;
+                        if (DEBUG)
+                            Log.v(TAG,"GET_VALUE_IDS" + numAttr);
+                        getPlayerAppValueRspNative(numAttr, data,
+                                getByteAddress(device));
+                    break;
+                    case GET_ATTRIBUTE_VALUES:
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!! device is null");
+                            return;
+                        }
+                        data = intent.getByteArrayExtra(EXTRA_ATTRIB_VALUE_PAIRS);
+                        updateLocalPlayerSettings(data);
+                        numAttr = (byte) data.length;
+                        if (DEBUG)
+                            Log.v(TAG,"GET_ATTRIBUTE_VALUES" + numAttr);
+                        SendCurrentPlayerValueRspNative(numAttr ,
+                                data, getByteAddress(device));
+                    break;
+                    case SET_ATTRIBUTE_VALUES:
+                        data = intent.getByteArrayExtra(EXTRA_ATTRIB_VALUE_PAIRS);
+                        updateLocalPlayerSettings(data);
+                        if (isSetAttrValRsp) {
+                            isSetAttrValRsp = false;
+                            for (int i = 0; i < maxAvrcpConnections; i++) {
+                                if (deviceFeatures[i].mCurrentDevice != null)  {
+                                    Log.v(TAG,"Respond to SET_ATTRIBUTE_VALUES request");
+                                    if (checkPlayerAttributeResponse(data)) {
+                                        SendSetPlayerAppRspNative(OPERATION_SUCCESSFUL,
+                                                getByteAddress(deviceFeatures[i].mCurrentDevice));
+                                    } else {
+                                        SendSetPlayerAppRspNative(INTERNAL_ERROR,
+                                                getByteAddress(deviceFeatures[i].mCurrentDevice));
+                                    }
+                                }
+                            }
+                            mPendingSetAttributes.clear();
+                        }
+                        for (int i = 0; i < maxAvrcpConnections; i++) {
+                            if (deviceFeatures[i].mPlayerStatusChangeNT ==
+                                    NOTIFICATION_TYPE_INTERIM) {
+                                Log.v(TAG,"device has registered for"+
+                                    "mPlayerStatusChangeNT");
+                                deviceFeatures[i].mPlayerStatusChangeNT =
+                                        NOTIFICATION_TYPE_CHANGED;
+                                sendPlayerAppChangedRsp(deviceFeatures[i].mPlayerStatusChangeNT,
+                                        deviceFeatures[i].mCurrentDevice);
+                               } else {
+                                   Log.v(TAG,"Drop Set Attr Val update from media player");
+                            }
+                        }
+                    break;
+                    case GET_ATTRIBUTE_TEXT:
+                        text = intent.getStringArrayExtra(EXTRA_ATTRIBUTE_STRING_ARRAY);
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!! device is null");
+                            return;
+                        }
+                        sendSettingsTextRspNative(mPlayerSettings.attrIds.length ,
+                                mPlayerSettings.attrIds ,text.length,
+                                text, getByteAddress(device));
+                        if (DEBUG)
+                            Log.v(TAG,"mPlayerSettings.attrIds"
+                                    + mPlayerSettings.attrIds.length);
+                    break;
+                    case GET_VALUE_TEXT:
+                        text = intent.getStringArrayExtra(EXTRA_VALUE_STRING_ARRAY);
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!! device is null");
+                            return;
+                        }
+                        sendValueTextRspNative(mPlayerSettings.attrIds.length ,
+                                mPlayerSettings.attrIds,
+                                text.length, text,
+                                getByteAddress(device));
+                    break;
+                }
+            }
+
+        }
+    };
+
+    /* This method is used for create entries of existing media players on RCD start
+     * Later when media players become avaialable corresponding entries
+     * are marked accordingly and similarly when media players changes focus
+     * the corresponding fields are modified */
+    private void registerMediaPlayers () {
+        if (DEBUG)
+            Log.v(TAG, "registerMediaPlayers");
+        int[] featureMasks = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+        byte[] playerName1 = {0x4d, 0x75, 0x73, 0x69, 0x63}/*Music*/;
+
+        featureMasks[FEATURE_MASK_PLAY_OFFSET] =
+            featureMasks[FEATURE_MASK_PLAY_OFFSET] | FEATURE_MASK_PLAY_MASK;
+        featureMasks[FEATURE_MASK_PAUSE_OFFSET] =
+            featureMasks[FEATURE_MASK_PAUSE_OFFSET] | FEATURE_MASK_PAUSE_MASK;
+        featureMasks[FEATURE_MASK_STOP_OFFSET] =
+            featureMasks[FEATURE_MASK_STOP_OFFSET] | FEATURE_MASK_STOP_MASK;
+        featureMasks[FEATURE_MASK_PAGE_UP_OFFSET] =
+            featureMasks[FEATURE_MASK_PAGE_UP_OFFSET] | FEATURE_MASK_PAGE_UP_MASK;
+        featureMasks[FEATURE_MASK_PAGE_DOWN_OFFSET] =
+            featureMasks[FEATURE_MASK_PAGE_DOWN_OFFSET] | FEATURE_MASK_PAGE_DOWN_MASK;
+        featureMasks[FEATURE_MASK_REWIND_OFFSET] =
+            featureMasks[FEATURE_MASK_REWIND_OFFSET] | FEATURE_MASK_REWIND_MASK;
+        featureMasks[FEATURE_MASK_FAST_FWD_OFFSET] =
+            featureMasks[FEATURE_MASK_FAST_FWD_OFFSET] | FEATURE_MASK_FAST_FWD_MASK;
+        featureMasks[FEATURE_MASK_VENDOR_OFFSET] =
+            featureMasks[FEATURE_MASK_VENDOR_OFFSET] | FEATURE_MASK_VENDOR_MASK;
+        featureMasks[FEATURE_MASK_ADV_CTRL_OFFSET] =
+            featureMasks[FEATURE_MASK_ADV_CTRL_OFFSET] | FEATURE_MASK_ADV_CTRL_MASK;
+        featureMasks[FEATURE_MASK_BROWSE_OFFSET] =
+            featureMasks[FEATURE_MASK_BROWSE_OFFSET] | FEATURE_MASK_BROWSE_MASK;
+        featureMasks[FEATURE_MASK_NOW_PLAY_OFFSET] =
+            featureMasks[FEATURE_MASK_NOW_PLAY_OFFSET] | FEATURE_MASK_NOW_PLAY_MASK;
+        featureMasks[FEATURE_MASK_BR_WH_ADDR_OFFSET] =
+            featureMasks[FEATURE_MASK_BR_WH_ADDR_OFFSET] | FEATURE_MASK_BR_WH_ADDR_MASK;
+
+        mediaPlayerInfo1 = new MediaPlayerInfo ((short)0x0001,
+                    MAJOR_TYPE_AUDIO,
+                    SUB_TYPE_NONE,
+                    (byte)RemoteControlClient.PLAYSTATE_PAUSED,
+                    CHAR_SET_UTF8,
+                    (short)0x05,
+                    playerName1,
+                    "com.android.music",
+                    true,
+                    featureMasks);
+
+        mMediaPlayers.add(mediaPlayerInfo1);
+    }
+
+    public static Avrcp make(Context context, A2dpService svc,
+            int maxConnections) {
+        if (DEBUG)
+            Log.v(TAG, "make");
+        Avrcp ar = new Avrcp(context, svc, maxConnections);
         ar.start();
         return ar;
     }
 
     public void doQuit() {
+        if (DEBUG)
+            Log.v(TAG, "doQuit");
         mHandler.removeCallbacksAndMessages(null);
         Looper looper = mHandler.getLooper();
         if (looper != null) {
             looper.quit();
         }
         mAudioManager.unregisterRemoteController(mRemoteController);
+        clearDeviceDependentFeature();
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            cleanupDeviceFeaturesIndex(i);
+        }
+        try {
+            mContext.unregisterReceiver(mIntentReceiver);
+        }catch (Exception e) {
+            Log.e(TAG,"Unable to unregister Avrcp receiver", e);
+        }
+        mMediaPlayers.clear();
+        if (mHandler.hasMessages(MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT)) {
+            mHandler.removeMessages(MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT);
+            if (DEBUG)
+                Log.v(TAG, "Addressed player message cleanup as part of doQuit");
+        }
+    }
+
+    public void clearDeviceDependentFeature() {
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            deviceFeatures[i].keyPressState = KEY_STATE_RELEASE; //Key release state
+            deviceFeatures[i].mCurrentPath = PATH_INVALID;
+            deviceFeatures[i].mMediaUri = Uri.EMPTY;
+            deviceFeatures[i].mCurrentPathUid = null;
+            deviceFeatures[i].mRequestedAddressedPlayerPackageName = null;
+        }
+
     }
 
     public void cleanup() {
+        if (DEBUG)
+            Log.v(TAG, "cleanup");
         cleanupNative();
     }
 
@@ -253,7 +757,81 @@ public final class Avrcp {
         }
     }
 
-    /** Handles Avrcp messages. */
+    private static class AvrcpRemoteControllerWeak implements
+            RemoteController.OnClientAvrcpUpdateListener {
+        private final WeakReference<Handler> mLocalHandler;
+
+        public AvrcpRemoteControllerWeak(Handler handler) {
+            mLocalHandler = new WeakReference<Handler>(handler);
+        }
+
+        @Override
+        public void onClientFolderInfoBrowsedPlayer(String stringUri) {
+            Log.v(TAG, "onClientFolderInfoBrowsedPlayer: stringUri: " + stringUri);
+            Handler handler = mLocalHandler.get();
+            if (stringUri != null) {
+                String[] ExternalPath = stringUri.split("/");
+                if (ExternalPath.length < 4) {
+                    Log.d(TAG, "Wrong entries.");
+                    handler.obtainMessage(MSG_UPDATE_BROWSED_PLAYER_FOLDER, 0, INTERNAL_ERROR,
+                                                                  null).sendToTarget();
+                    return;
+                }
+                Uri uri = Uri.parse(stringUri);
+                Log.v(TAG, "URI received: " + uri);
+                String[] SplitPath = new String[ExternalPath.length - 3];
+                for (int count = 2; count < (ExternalPath.length - 1); count++) {
+                    SplitPath[count - 2] = ExternalPath[count];
+                    Log.d(TAG, "SplitPath[" + (count - 2) + "] = " + SplitPath[count - 2]);
+                }
+                Log.v(TAG, "folderDepth: " + SplitPath.length);
+                for (int count = 0; count < SplitPath.length; count++) {
+                    Log.v(TAG, "folderName: " + SplitPath[count]);
+                }
+                mMediaUriStatic = uri;
+                if (handler != null) {
+                    // Don't send the complete path to CK as few gets confused by that
+                    // Send only the name of the root folder
+                    handler.obtainMessage(MSG_UPDATE_BROWSED_PLAYER_FOLDER, NUM_ROOT_ELEMENTS,
+                                                OPERATION_SUCCESSFUL, SplitPath).sendToTarget();
+                }
+            } else {
+                handler.obtainMessage(MSG_UPDATE_BROWSED_PLAYER_FOLDER, 0, INTERNAL_ERROR,
+                                                                  null).sendToTarget();
+            }
+        }
+
+        @Override
+        public void onClientUpdateNowPlayingEntries(long[] playList) {
+            Log.v(TAG, "onClientUpdateNowPlayingEntries");
+            Handler handler = mLocalHandler.get();
+            if (handler != null) {
+                handler.obtainMessage(MSG_NOW_PLAYING_ENTRIES_RECEIVED, 0, 0,
+                                                            playList).sendToTarget();
+            }
+        }
+
+        @Override
+        public void onClientNowPlayingContentChange() {
+            Log.v(TAG, "onClientNowPlayingContentChange");
+            Handler handler = mLocalHandler.get();
+            if (handler != null) {
+                handler.obtainMessage(MSG_UPDATE_NOW_PLAYING_CONTENT_CHANGED).sendToTarget();
+            }
+        }
+
+        @Override
+        public void onClientPlayItemResponse(boolean success) {
+            Log.v(TAG, "onClientPlayItemResponse");
+            Handler handler = mLocalHandler.get();
+            if (handler != null) {
+                handler.obtainMessage(MSG_PLAY_ITEM_RESPONSE, 0, 0, new Boolean(success))
+                                                                            .sendToTarget();
+            }
+        }
+    }
+
+    /* Handles Avrcp messages. */
     private final class AvrcpMessageHandler extends Handler {
         private AvrcpMessageHandler(Looper looper) {
             super(looper);
@@ -261,137 +839,409 @@ public final class Avrcp {
 
         @Override
         public void handleMessage(Message msg) {
+            int deviceIndex  = INVALID_DEVICE_INDEX;
             switch (msg.what) {
+                case MESSAGE_PLAYERSETTINGS_TIMEOUT:
+                    Log.e(TAG, "**MESSAGE_PLAYSTATUS_TIMEOUT: Addr: " +
+                                (String)msg.obj + " Msg: " + msg.arg1);
+                    synchronized (mPendingCmds) {
+                        Integer val = new Integer(msg.arg1);
+                        if (!mPendingCmds.contains(val)) {
+                            break;
+                        }
+                        mPendingCmds.remove(val);
+                    }
+                    switch (msg.arg1) {
+                    case GET_ATTRIBUTE_IDS:
+                        getListPlayerappAttrRspNative((byte)def_attrib.length ,
+                                def_attrib, getByteAddress(
+                                mAdapter.getRemoteDevice((String) msg.obj)));
+                    break;
+                    case GET_VALUE_IDS:
+                        switch (mPlayerSettings.attr) {
+                            case ATTRIBUTE_REPEATMODE:
+                                getPlayerAppValueRspNative((byte)value_repmode.length,
+                                        value_repmode,
+                                        getByteAddress(mAdapter.getRemoteDevice(
+                                        (String) msg.obj)));
+                            break;
+                            case ATTRIBUTE_SHUFFLEMODE:
+                                getPlayerAppValueRspNative((byte)value_shufmode.length,
+                                        value_shufmode,
+                                        getByteAddress(mAdapter.getRemoteDevice(
+                                        (String) msg.obj)));
+                            break;
+                            default:
+                                getPlayerAppValueRspNative((byte)value_default.length,
+                                        value_default,
+                                        getByteAddress(mAdapter.getRemoteDevice(
+                                        (String) msg.obj)));
+                            break;
+                        }
+                    break;
+                    case GET_ATTRIBUTE_VALUES:
+                        int j = 0;
+                        byte [] retVal = new byte [mPlayerSettings.attrIds.length*2];
+                        for (int i = 0; i < mPlayerSettings.attrIds.length; i++) {
+                            retVal[j++] = mPlayerSettings.attrIds[i];
+                            if (mPlayerSettings.attrIds[i] == ATTRIBUTE_REPEATMODE) {
+                                retVal[j++] = settingValues.repeat_value;
+                            } else if (mPlayerSettings.attrIds[i] == ATTRIBUTE_SHUFFLEMODE) {
+                                retVal[j++] = settingValues.shuffle_value;
+                             } else {
+                                retVal[j++] = 0x0;
+                             }
+                        }
+                        SendCurrentPlayerValueRspNative((byte)retVal.length ,
+                                retVal, getByteAddress(mAdapter.getRemoteDevice(
+                                (String) msg.obj)));
+                    break;
+                    case SET_ATTRIBUTE_VALUES :
+                        SendSetPlayerAppRspNative(INTERNAL_ERROR, getByteAddress(
+                                mAdapter.getRemoteDevice((String) msg.obj)));
+                    break;
+                    case GET_ATTRIBUTE_TEXT:
+                        String [] attribText = new String [mPlayerSettings.attrIds.length];
+                        for (int i = 0; i < mPlayerSettings.attrIds.length; i++) {
+                            attribText[i] = "";
+                        }
+                        sendSettingsTextRspNative(mPlayerSettings.attrIds.length ,
+                                mPlayerSettings.attrIds, attribText.length,
+                                attribText, getByteAddress(mAdapter.getRemoteDevice(
+                                (String) msg.obj)));
+                    break;
+                    case GET_VALUE_TEXT:
+                        String [] valueText = new String [mPlayerSettings.attrIds.length];
+                        for (int i = 0; i < mPlayerSettings.attrIds.length; i++) {
+                            valueText[i] = "";
+                        }
+                        sendValueTextRspNative(mPlayerSettings.attrIds.length ,
+                                mPlayerSettings.attrIds, valueText.length,
+                                valueText,getByteAddress(mAdapter.getRemoteDevice(
+                                (String) msg.obj)));
+                    break;
+                    default :
+                        Log.e(TAG,"in default case");
+                    break;
+                }
+                break;
             case MSG_UPDATE_STATE:
-                    updatePlayPauseState(msg.arg2, ((Long) msg.obj).longValue());
+                    /* since we get this from music app we need to update
+                     * current playing start time */
+                    Log.i(TAG,"State change for music app");
+                    updatePlayPauseState(msg.arg2, ((Long) msg.obj).longValue(),
+                            null);
                 break;
 
             case MSG_SET_METADATA:
-                    updateMetadata((MetadataEditor) msg.obj);
+                updateMetadata((MetadataEditor) msg.obj);
+                break;
+
+            case MSG_UPDATE_AVAILABLE_PLAYERS:
+                updateAvailableMediaPlayers();
+                break;
+
+            case MSG_UPDATE_ADDRESSED_PLAYER:
+                updateAddressedMediaPlayer(msg.arg1);
+                break;
+
+            case MSG_UPDATE_BROWSED_PLAYER_FOLDER:
+                Log.v(TAG, "MSG_UPDATE_BROWSED_PLAYER_FOLDER");
+                updateBrowsedPlayerFolder(msg.arg1, msg.arg2, (String [])msg.obj);
+                break;
+
+            case MSG_UPDATE_NOW_PLAYING_CONTENT_CHANGED:
+                Log.v(TAG, "MSG_UPDATE_NOW_PLAYING_CONTENT_CHANGED");
+                updateNowPlayingContentChanged();
+                break;
+
+            case MSG_PLAY_ITEM_RESPONSE:
+                Log.v(TAG, "MSG_PLAY_ITEM_RESPONSE");
+                boolean success = ((Boolean)msg.obj).booleanValue();
+                Log.v(TAG, "success: " + success);
+                updatePlayItemResponse(success);
+                break;
+
+            case MSG_NOW_PLAYING_ENTRIES_RECEIVED:
+                Log.v(TAG, "MSG_NOW_PLAYING_ENTRIES_RECEIVED");
+                updateNowPlayingEntriesReceived((long [])msg.obj);
                 break;
 
             case MSG_SET_TRANSPORT_CONTROLS:
-                    updateTransportControls(msg.arg2);
+                updateTransportControls(msg.arg2);
                 break;
 
             case MSG_SET_GENERATION_ID:
-                if (DEBUG) Log.v(TAG, "New genId = " + msg.arg1 + ", clearing = " + msg.arg2);
+                if (DEBUG)
+                    Log.v(TAG, "New genId = " + msg.arg1 +
+                            ", clearing = " + msg.arg2);
                 break;
 
             case MESSAGE_GET_RC_FEATURES:
+            {
                 String address = (String) msg.obj;
-                if (DEBUG) Log.v(TAG, "MESSAGE_GET_RC_FEATURES: address="+address+
-                                                             ", features="+msg.arg1);
-                mFeatures = msg.arg1;
-                mAudioManager.avrcpSupportsAbsoluteVolume(address, isAbsoluteVolumeSupported());
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_GET_RC_FEATURES: address="+address+
+                            ", features="+msg.arg1);
+                BluetoothDevice device = mAdapter.getRemoteDevice(address);
+                deviceIndex = getIndexForDevice(device);
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.v(TAG,"device entry not present, bailing out");
+                    return;
+                }
+                deviceFeatures[deviceIndex].mFeatures = msg.arg1;
+                deviceFeatures[deviceIndex].isAbsoluteVolumeSupportingDevice =
+                        ((deviceFeatures[deviceIndex].mFeatures &
+                        BTRC_FEAT_ABSOLUTE_VOLUME) != 0);
+                mAudioManager.avrcpSupportsAbsoluteVolume(device.getAddress(),
+                        isAbsoluteVolumeSupported());
+                Log.v(TAG," update audio manager for abs vol state = "
+                        + isAbsoluteVolumeSupported());
+                if ((deviceFeatures[deviceIndex].mFeatures &
+                        BTRC_FEAT_AVRC_UI_UPDATE) != 0)
+                {
+                    int NOTIFICATION_ID = android.R.drawable.stat_sys_data_bluetooth;
+                    Notification notification = new Notification.Builder(mContext)
+                        .setContentTitle("Bluetooth Media Browsing")
+                        .setContentText("Peer supports advanced feature")
+                        .setSubText("Re-pair from peer to enable it")
+                        .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth)
+                        .setDefaults(Notification.DEFAULT_ALL)
+                        .build();
+                    NotificationManager manager = (NotificationManager)
+                        mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+                    manager.notify(NOTIFICATION_ID, notification);
+                    Log.v(TAG," update notification manager on remote repair request");
+                }
                 break;
-
+            }
             case MESSAGE_GET_PLAY_STATUS:
-                if (DEBUG) Log.v(TAG, "MESSAGE_GET_PLAY_STATUS");
-                getPlayStatusRspNative(convertPlayStateToPlayStatus(mCurrentPlayState),
-                                       (int)mSongLengthMs, (int)getPlayPosition());
-                break;
+            {
+                BluetoothDevice device;
+                int playState, position;
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_GET_PLAY_STATUS");
+                Log.v(TAG, "Event for device address " + (String)msg.obj);
+
+                device = mAdapter.getRemoteDevice((String) msg.obj);
+                deviceIndex = getIndexForDevice(device);
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"Invalid device index for play status");
+                    break;
+                }
+                playState = convertPlayStateToPlayStatus(deviceFeatures[deviceIndex].mCurrentPlayState);
+                position = (int)getPlayPosition(device);
+                Log.v(TAG, "Play Status for : " + device.getName() +
+                    " state: " + playState + " position: " + position);
+                if (position == -1) {
+                    Log.v(TAG, "Force play postion to 0, for getPlayStatus Rsp");
+                    position = 0;
+                }
 
+                getPlayStatusRspNative(playState, (int)mSongLengthMs, position,
+                        getByteAddress(device));
+                break;
+            }
             case MESSAGE_GET_ELEM_ATTRS:
             {
                 String[] textArray;
                 int[] attrIds;
                 byte numAttr = (byte) msg.arg1;
-                ArrayList<Integer> attrList = (ArrayList<Integer>) msg.obj;
-                if (DEBUG) Log.v(TAG, "MESSAGE_GET_ELEM_ATTRS:numAttr=" + numAttr);
+                ItemAttr itemAttr = (ItemAttr)msg.obj;
+                Log.v(TAG, "event for device address " + itemAttr.mAddress);
+                ArrayList<Integer> attrList = itemAttr.mAttrList;
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_GET_ELEM_ATTRS:numAttr=" + numAttr);
                 attrIds = new int[numAttr];
                 textArray = new String[numAttr];
                 for (int i = 0; i < numAttr; ++i) {
                     attrIds[i] = attrList.get(i).intValue();
                     textArray[i] = getAttributeString(attrIds[i]);
                 }
-                getElementAttrRspNative(numAttr, attrIds, textArray);
+                getElementAttrRspNative(numAttr ,attrIds ,textArray ,
+                        getByteAddress(mAdapter.getRemoteDevice(itemAttr.mAddress)));
                 break;
             }
             case MESSAGE_REGISTER_NOTIFICATION:
-                if (DEBUG) Log.v(TAG, "MESSAGE_REGISTER_NOTIFICATION:event=" + msg.arg1 +
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_REGISTER_NOTIFICATION:event=" + msg.arg1 +
                                       " param=" + msg.arg2);
-                processRegisterNotification(msg.arg1, msg.arg2);
+                processRegisterNotification(msg.arg1, msg.arg2, (String) msg.obj);
                 break;
 
             case MESSAGE_PLAY_INTERVAL_TIMEOUT:
-                if (DEBUG) Log.v(TAG, "MESSAGE_PLAY_INTERVAL_TIMEOUT");
-                mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
-                registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int)getPlayPosition());
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_PLAY_INTERVAL_TIMEOUT");
+                Log.v(TAG, "event for device address " + (BluetoothDevice)msg.obj);
+                deviceIndex = getIndexForDevice((BluetoothDevice) msg.obj);
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"invalid index for device");
+                    break;
+                }
+                deviceFeatures[deviceIndex].mPlayPosChangedNT =
+                         NOTIFICATION_TYPE_CHANGED;
+                Log.v(TAG, "event for device address " + (BluetoothDevice) msg.obj);
+                registerNotificationRspPlayPosNative(deviceFeatures[deviceIndex].mPlayPosChangedNT,
+                        (int)getPlayPosition((BluetoothDevice) msg.obj) ,
+                        getByteAddress((BluetoothDevice) msg.obj));
+                break;
+
+            case MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT:
+                if (DEBUG)
+                    Log.v(TAG, "setAddressedPlayer fails, Times out");
+                deviceIndex = getIndexForDevice(mAdapter.getRemoteDevice((String) msg.obj));
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"invalid device index");
+                    break;
+                }
+                Log.v(TAG, "event for device address " + (String)msg.obj);
+                setAdressedPlayerRspNative((byte)PLAYER_NOT_ADDRESSED,
+                            getByteAddress(mAdapter.getRemoteDevice((String) msg.obj)));
+                deviceFeatures[deviceIndex].mRequestedAddressedPlayerPackageName = null;
                 break;
 
             case MESSAGE_VOLUME_CHANGED:
-                if (DEBUG) Log.v(TAG, "MESSAGE_VOLUME_CHANGED: volume=" + ((byte)msg.arg1 & 0x7f)
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_VOLUME_CHANGED: volume=" + ((byte)msg.arg1 & 0x7f)
                                                         + " ctype=" + msg.arg2);
-
+                Log.v(TAG, "event for device address " + (String)msg.obj);
+                deviceIndex = getIndexForDevice(mAdapter.getRemoteDevice((String) msg.obj));
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"invalid index for device");
+                    break;
+                }
                 if (msg.arg2 == AVRC_RSP_ACCEPT || msg.arg2 == AVRC_RSP_REJ) {
-                    if (mVolCmdInProgress == false) {
+                    if (deviceFeatures[deviceIndex].mVolCmdInProgress == false) {
                         Log.e(TAG, "Unsolicited response, ignored");
                         break;
                     }
                     removeMessages(MESSAGE_ABS_VOL_TIMEOUT);
-                    mVolCmdInProgress = false;
-                    mAbsVolRetryTimes = 0;
+                    deviceFeatures[deviceIndex].mVolCmdInProgress = false;
+                    deviceFeatures[deviceIndex].mAbsVolRetryTimes = 0;
                 }
-                if (mAbsoluteVolume != msg.arg1 && (msg.arg2 == AVRC_RSP_ACCEPT ||
-                                                    msg.arg2 == AVRC_RSP_CHANGED ||
-                                                    msg.arg2 == AVRC_RSP_INTERIM)) {
+                if (deviceFeatures[deviceIndex].mAbsoluteVolume != msg.arg1 &&
+                        (msg.arg2 == AVRC_RSP_ACCEPT ||
+                        msg.arg2 == AVRC_RSP_CHANGED ||
+                        msg.arg2 == AVRC_RSP_INTERIM)) {
                     byte absVol = (byte)((byte)msg.arg1 & 0x7f); // discard MSB as it is RFD
-                    notifyVolumeChanged(absVol);
-                    mAbsoluteVolume = absVol;
+                    deviceFeatures[deviceIndex].mAbsoluteVolume = absVol;
                     long pecentVolChanged = ((long)absVol * 100) / 0x7f;
-                    Log.e(TAG, "percent volume changed: " + pecentVolChanged + "%");
+                    Log.v(TAG, "Absolute Volume change received as: " + absVol);
+                    Log.v(TAG, "Percent volume changed: " + pecentVolChanged + "%");
+                    if (isAbsoluteVolumeSupported() &&
+                            deviceFeatures[deviceIndex].mAbsoluteVolume != -1) {
+                        Log.v(TAG," update audio manager for absolute volume = "
+                                + deviceFeatures[deviceIndex].mAbsoluteVolume);
+                        notifyVolumeChanged(deviceFeatures[deviceIndex].mAbsoluteVolume,
+                                    deviceFeatures[deviceIndex].mCurrentDevice);
+                    }
                 } else if (msg.arg2 == AVRC_RSP_REJ) {
-                    Log.e(TAG, "setAbsoluteVolume call rejected");
+                    if (DEBUG)
+                        Log.v(TAG, "setAbsoluteVolume call rejected");
                 }
                 break;
 
             case MESSAGE_ADJUST_VOLUME:
-                if (DEBUG) Log.d(TAG, "MESSAGE_ADJUST_VOLUME: direction=" + msg.arg1);
-                if (mVolCmdInProgress) {
-                    if (DEBUG) Log.w(TAG, "There is already a volume command in progress.");
-                    break;
-                }
-                // Wait on verification on volume from device, before changing the volume.
-                if (mAbsoluteVolume != -1 && (msg.arg1 == -1 || msg.arg1 == 1)) {
-                    int setVol = Math.min(AVRCP_MAX_VOL,
-                                 Math.max(0, mAbsoluteVolume + msg.arg1*mVolumeStep));
-                    if (setVolumeNative(setVol)) {
-                        sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT),
-                                           CMD_TIMEOUT_DELAY);
-                        mVolCmdInProgress = true;
-                        mLastDirection = msg.arg1;
-                        mLastSetVolume = setVol;
+            {
+                List<BluetoothDevice> playingDevice = mA2dpService.getA2dpPlayingDevice();
+                if (DEBUG)
+                    Log.d(TAG, "MESSAGE_ADJUST_VOLUME: direction=" + msg.arg1);
+                for (int i = 0; i < playingDevice.size(); i++) {
+                    Log.v(TAG, "event for device address " +
+                            playingDevice.get(i).getAddress());
+                    deviceIndex = getIndexForDevice(playingDevice.get(i));
+                    if (deviceIndex == INVALID_DEVICE_INDEX) {
+                        Log.e(TAG,"Unkown playing device");
+                        sendAdjustVolume(msg.arg1);
+                        continue;
+                    }
+                    if (deviceFeatures[deviceIndex].mVolCmdInProgress) {
+                        if (DEBUG)
+                            Log.w(TAG, "already a volume command in progress" +
+                                    "for this device.");
+                        continue;
+                    }
+                    // Wait on verification on volume from device, before changing the volume.
+                    if (deviceFeatures[deviceIndex].mAbsoluteVolume != -1 &&
+                            (msg.arg1 == -1 || msg.arg1 == 1)) {
+                        int setVol = Math.min(AVRCP_MAX_VOL,
+                                     Math.max(0, deviceFeatures[deviceIndex].mAbsoluteVolume +
+                                     msg.arg1*mVolumeStep));
+                        boolean isSetVol = setVolumeNative(setVol ,
+                                getByteAddress(playingDevice.get(i)));
+                        if (isSetVol) {
+                            sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT,
+                            0, 0, deviceFeatures[deviceIndex].mCurrentDevice),
+                                               CMD_TIMEOUT_DELAY);
+                            deviceFeatures[deviceIndex].mVolCmdInProgress = true;
+                            deviceFeatures[deviceIndex].mLastDirection = msg.arg1;
+                            deviceFeatures[deviceIndex].mLastSetVolume = setVol;
+                        }
+                    } else {
+                        Log.e(TAG, "Unknown direction in MESSAGE_ADJUST_VOLUME");
                     }
-                } else {
-                    Log.e(TAG, "Unknown direction in MESSAGE_ADJUST_VOLUME");
                 }
                 break;
-
+            }
             case MESSAGE_SET_ABSOLUTE_VOLUME:
-                if (DEBUG) Log.v(TAG, "MESSAGE_SET_ABSOLUTE_VOLUME");
-                if (mVolCmdInProgress) {
-                    if (DEBUG) Log.w(TAG, "There is already a volume command in progress.");
-                    break;
+            {
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_SET_ABSOLUTE_VOLUME");
+                List<BluetoothDevice> playingDevice = mA2dpService.getA2dpPlayingDevice();
+                if (playingDevice.size() == 0) {
+                    Log.e(TAG,"Volume cmd without a2dp playing");
                 }
-                if (setVolumeNative(msg.arg1)) {
-                    sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT), CMD_TIMEOUT_DELAY);
-                    mVolCmdInProgress = true;
-                    mLastSetVolume = msg.arg1;
+                for (int i = 0; i < playingDevice.size(); i++) {
+                    deviceIndex = getIndexForDevice(playingDevice.get(i));
+                    if (deviceIndex == INVALID_DEVICE_INDEX) {
+                        Log.e(TAG,"Unkown playing device");
+                        sendSetAbsoluteVolume(msg.arg1);
+                        continue;
+                    }
+                    Log.v(TAG, "event for device address " +
+                            playingDevice.get(i).getAddress());
+                    if (deviceFeatures[deviceIndex].mVolCmdInProgress) {
+                        if (DEBUG)
+                            Log.w(TAG, "There is already a volume command in progress.");
+                        continue;
+                    }
+                    Log.v(TAG, "event for device address " + (String)msg.obj);
+                    boolean isSetVol = setVolumeNative(msg.arg1 ,
+                            getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    if (isSetVol) {
+                        sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT,
+                                0, 0, deviceFeatures[deviceIndex].mCurrentDevice),
+                                CMD_TIMEOUT_DELAY);
+                        deviceFeatures[deviceIndex].mVolCmdInProgress = true;
+                        deviceFeatures[deviceIndex].mLastSetVolume = msg.arg1;
+                    }
                 }
                 break;
-
+            }
             case MESSAGE_ABS_VOL_TIMEOUT:
-                if (DEBUG) Log.v(TAG, "MESSAGE_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
-                mVolCmdInProgress = false;
-                if (mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
-                    mAbsVolRetryTimes = 0;
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_ABS_VOL_TIMEOUT: Volume change cmd timed out.");
+                deviceIndex = getIndexForDevice((BluetoothDevice) msg.obj);
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"invalid device index for abs vol timeout");
+                    for (int i = 0; i < maxAvrcpConnections; i++) {
+                        if (deviceFeatures[i].mVolCmdInProgress == true)
+                            deviceFeatures[i].mVolCmdInProgress = false;
+                    }
+                    break;
+                }
+                deviceFeatures[deviceIndex].mVolCmdInProgress = false;
+                Log.v(TAG, "event for device address " + (BluetoothDevice)msg.obj);
+                if (deviceFeatures[deviceIndex].mAbsVolRetryTimes >= MAX_ERROR_RETRY_TIMES) {
+                    deviceFeatures[deviceIndex].mAbsVolRetryTimes = 0;
                 } else {
-                    mAbsVolRetryTimes += 1;
-                    if (setVolumeNative(mLastSetVolume)) {
-                        sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT),
-                                           CMD_TIMEOUT_DELAY);
-                        mVolCmdInProgress = true;
+                    deviceFeatures[deviceIndex].mAbsVolRetryTimes += 1;
+                    boolean isSetVol = setVolumeNative(deviceFeatures[deviceIndex].mLastSetVolume ,
+                            getByteAddress((BluetoothDevice) msg.obj));
+                    if (isSetVol) {
+                        sendMessageDelayed(obtainMessage(MESSAGE_ABS_VOL_TIMEOUT,
+                                0, 0, msg.obj), CMD_TIMEOUT_DELAY);
+                        deviceFeatures[deviceIndex].mVolCmdInProgress = true;
                     }
                 }
                 break;
@@ -420,11 +1270,13 @@ public final class Avrcp {
 
                 int skipAmount;
                 if (msg.what == MESSAGE_FAST_FORWARD) {
-                    if (DEBUG) Log.v(TAG, "MESSAGE_FAST_FORWARD");
+                    if (DEBUG)
+                        Log.v(TAG, "MESSAGE_FAST_FORWARD");
                     removeMessages(MESSAGE_FAST_FORWARD);
                     skipAmount = BASE_SKIP_AMOUNT;
                 } else {
-                    if (DEBUG) Log.v(TAG, "MESSAGE_REWIND");
+                    if (DEBUG)
+                        Log.v(TAG, "MESSAGE_REWIND");
                     removeMessages(MESSAGE_REWIND);
                     skipAmount = -BASE_SKIP_AMOUNT;
                 }
@@ -442,8 +1294,10 @@ public final class Avrcp {
                 removeMessages(MESSAGE_CHANGE_PLAY_POS);
                 if (msg.arg1 == KEY_STATE_PRESS) {
                     mSkipAmount = skipAmount;
-                    changePositionBy(mSkipAmount * getSkipMultiplier());
-                    Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS);
+                    changePositionBy(mSkipAmount * getSkipMultiplier(),
+                            (String)msg.obj);
+                    Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS,
+                            0, 0, msg.obj);
                     posMsg.arg1 = 1;
                     sendMessageDelayed(posMsg, SKIP_PERIOD);
                 }
@@ -451,133 +1305,752 @@ public final class Avrcp {
                 break;
 
             case MESSAGE_CHANGE_PLAY_POS:
-                if (DEBUG) Log.v(TAG, "MESSAGE_CHANGE_PLAY_POS:" + msg.arg1);
-                changePositionBy(mSkipAmount * getSkipMultiplier());
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_CHANGE_PLAY_POS:" + msg.arg1);
+                changePositionBy(mSkipAmount * getSkipMultiplier(),
+                        (String)msg.obj);
                 if (msg.arg1 * SKIP_PERIOD < BUTTON_TIMEOUT_TIME) {
-                    Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS);
+                    Message posMsg = obtainMessage(MESSAGE_CHANGE_PLAY_POS,
+                            0, 0, msg.obj);
                     posMsg.arg1 = msg.arg1 + 1;
                     sendMessageDelayed(posMsg, SKIP_PERIOD);
                 }
                 break;
 
             case MESSAGE_SET_A2DP_AUDIO_STATE:
-                if (DEBUG) Log.v(TAG, "MESSAGE_SET_A2DP_AUDIO_STATE:" + msg.arg1);
-                updateA2dpAudioState(msg.arg1);
+                if (DEBUG)
+                    Log.v(TAG, "MESSAGE_SET_A2DP_AUDIO_STATE:" + msg.arg1);
+                BluetoothDevice playStateChangeDevice =
+                        (BluetoothDevice)msg.obj;
+                Log.v(TAG, "event for device address " +
+                        playStateChangeDevice.getAddress());
+                deviceIndex = getIndexForDevice(playStateChangeDevice);
+                if (deviceIndex == INVALID_DEVICE_INDEX) {
+                    Log.e(TAG,"in valid index for device");
+                    break;
+                }
+                updateA2dpAudioState(msg.arg1, (BluetoothDevice)msg.obj);
+                break;
+
+            case MSG_UPDATE_RCC_CHANGE:
+                Log.v(TAG, "MSG_UPDATE_RCC_CHANGE");
+                String callingPackageName = (String)msg.obj;
+                int isFocussed = msg.arg1;
+                int isAvailable = msg.arg2;
+                processRCCStateChange(callingPackageName, isFocussed, isAvailable);
+                break;
+
+            case MESSAGE_SET_ADDR_PLAYER:
+                processSetAddressedPlayer(msg.arg1, (String) msg.obj);
+                break;
+            case MESSAGE_SET_BROWSED_PLAYER:
+                processSetBrowsedPlayer(msg.arg1, (String) msg.obj);
+                break;
+            case MESSAGE_CHANGE_PATH:
+                ItemAttr itemAttr = (ItemAttr)msg.obj;
+                processChangePath(msg.arg1, itemAttr.mUid, itemAttr.mAddress);
+                break;
+            case MESSAGE_PLAY_ITEM:
+                itemAttr = (ItemAttr)msg.obj;
+                processPlayItem(msg.arg1, itemAttr.mUid, itemAttr.mAddress);
+                break;
+            case MESSAGE_GET_ITEM_ATTRS:
+                int[] attrIds;
+                itemAttr = (ItemAttr)msg.obj;
+                attrIds = new int[msg.arg1];
+                for (int i = 0; i < msg.arg1; ++i) {
+                    attrIds[i] = itemAttr.mAttrList.get(i).intValue();
+                }
+                processGetItemAttr((byte)msg.arg2, itemAttr.mUid, (byte)msg.arg1,
+                        attrIds, itemAttr.mAddress);
+                break;
+            case MESSAGE_GET_FOLDER_ITEMS:
+                FolderListEntries folderListEntries = (FolderListEntries)msg.obj;
+                attrIds = new int[folderListEntries.mNumAttr];
+                for (int i = 0; i < folderListEntries.mNumAttr; ++i) {
+                    attrIds[i] = folderListEntries.mAttrList.get(i).intValue();
+                }
+                processGetFolderItems(folderListEntries.mScope, folderListEntries.mStart,
+                    folderListEntries.mEnd, folderListEntries.mAttrCnt,
+                    folderListEntries.mNumAttr, attrIds, folderListEntries.mAddress);
                 break;
             }
         }
     }
 
-    private void updateA2dpAudioState(int state) {
+    private void sendAdjustVolume(int val) {
+        Log.v(TAG, "in sendAdjustVolume" + " " + val);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mCurrentDevice != null &&
+                    ((deviceFeatures[i].mFeatures &
+                    BTRC_FEAT_ABSOLUTE_VOLUME) != 0)) {
+                if (deviceFeatures[i].mAbsoluteVolume != -1 &&
+                        (val == -1 || val == 1)) {
+                    int setVol = Math.min(AVRCP_MAX_VOL,
+                                 Math.max(0, deviceFeatures[i].mAbsoluteVolume +
+                                 val*mVolumeStep));
+                    boolean isSetVol = setVolumeNative(setVol ,
+                            getByteAddress((deviceFeatures[i].mCurrentDevice)));
+                    if (isSetVol) {
+                        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_ABS_VOL_TIMEOUT,
+                        0, 0, deviceFeatures[i].mCurrentDevice),
+                                CMD_TIMEOUT_DELAY);
+                        deviceFeatures[i].mVolCmdInProgress = true;
+                        deviceFeatures[i].mLastDirection = val;
+                        deviceFeatures[i].mLastSetVolume = setVol;
+                    }
+                } else {
+                    Log.e(TAG, "Unknown direction in MESSAGE_ADJUST_VOLUME");
+                }
+            }
+        }
+    }
+
+    private void sendSetAbsoluteVolume(int val) {
+        Log.v(TAG, "in sendSetAbsoluteVolume " + " " + val);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mCurrentDevice != null &&
+                    ((deviceFeatures[i].mFeatures &
+                    BTRC_FEAT_ABSOLUTE_VOLUME) != 0)) {
+                Log.v(TAG, "in sending for device " + deviceFeatures[i].mCurrentDevice);
+                boolean isSetVol = setVolumeNative(val ,
+                        getByteAddress((deviceFeatures[i].mCurrentDevice)));
+                if (isSetVol) {
+                    mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_ABS_VOL_TIMEOUT,
+                            0, 0, deviceFeatures[i].mCurrentDevice),
+                            CMD_TIMEOUT_DELAY);
+                    deviceFeatures[i].mVolCmdInProgress = true;
+                    deviceFeatures[i].mLastSetVolume = val;
+                }
+            }
+        }
+    }
+
+    private void updateA2dpAudioState(int state, BluetoothDevice device) {
         boolean isPlaying = (state == BluetoothA2dp.STATE_PLAYING);
-        if (isPlaying != isPlayingState(mCurrentPlayState)) {
-            /* if a2dp is streaming, check to make sure music is active */
-            if ( (isPlaying) && !mAudioManager.isMusicActive())
-                return;
-            updatePlayPauseState(isPlaying ? RemoteControlClient.PLAYSTATE_PLAYING :
-                                 RemoteControlClient.PLAYSTATE_PAUSED,
-                                 RemoteControlClient.PLAYBACK_POSITION_INVALID);
+
+        Log.v(TAG,"updateA2dpAudioState");
+        if ((isPlaying) && !mAudioManager.isMusicActive()) {
+            /* Play state to be updated only for music streaming, not touchtone */
+            Log.v(TAG,"updateA2dpAudioState: Stream state not active ");
+            return;
+        }
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if ((isPlaying != isPlayingState(deviceFeatures[i].mCurrentPlayState)) &&
+                    (device.equals(deviceFeatures[i].mCurrentDevice))) {
+                updatePlayPauseState(isPlaying ? RemoteControlClient.PLAYSTATE_PLAYING :
+                        RemoteControlClient.PLAYSTATE_PAUSED,
+                        RemoteControlClient.PLAYBACK_POSITION_INVALID,
+                        device);
+                break;
+            }
+        }
+    }
+
+    private void updateResetNotificationForDevice(BluetoothDevice device, int index) {
+        Log.i(TAG,"in updateResetNotificationForDevice " + device + " index " +
+                index);
+        if (deviceFeatures[index].mPlayPosChangedNT ==
+                NOTIFICATION_TYPE_INTERIM) {
+            if (DEBUG)
+                Log.v(TAG, "send Play Position reject to stack");
+            deviceFeatures[index].mPlayPosChangedNT =
+                    NOTIFICATION_TYPE_REJECT;
+            registerNotificationRspPlayPosNative(deviceFeatures[index].mPlayPosChangedNT,
+                    -1 ,getByteAddress(device));
+            mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
+        } else {
+            Log.v(TAG,"index " + index + " status is"+
+                    deviceFeatures[index].mPlayPosChangedNT);
+        }
+    }
+
+    private void updatePlayPauseState(int state, long currentPosMs,
+                                                    BluetoothDevice device) {
+        Log.v(TAG,"updatePlayPauseState, state: " + state + " device: " + device);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            Log.v(TAG,"Device: " + ((deviceFeatures[i].mCurrentDevice == null) ?
+                "no name: " : deviceFeatures[i].mCurrentDevice.getName() +
+                " : old state: " + deviceFeatures[i].mCurrentPlayState));
+        }
+        if (device == null) {
+            /*Called because of player state change*/
+            updatePlayerStateAndPosition(state, currentPosMs);
+            return;
+        } else {
+            int deviceIndex = getIndexForDevice(device);
+            if (deviceIndex == INVALID_DEVICE_INDEX) {
+                Log.w(TAG,"invalid device index" +
+                        "Play status change for not connected device");
+            } else {
+                Log.v(TAG, "old state: " + deviceFeatures[deviceIndex].mCurrentPlayState
+                            + " new state: " + state + " device: " +
+                            device + " index: " + deviceIndex);
+                updatePlayStatusForDevice(deviceIndex, state);
+            }
+        }
+    }
+
+    private void updatePlayStatusForDevice(int deviceIndex,int state) {
+        Log.i(TAG,"updatePlayStatusForDevice: device: " +
+                    deviceFeatures[deviceIndex].mCurrentDevice);
+        int oldPlayStatus = convertPlayStateToPlayStatus(
+                    deviceFeatures[deviceIndex].mCurrentPlayState);
+        int newPlayStatus = convertPlayStateToPlayStatus(state);
+        if (DEBUG)
+            Log.v(TAG, "oldPlayStatus " + oldPlayStatus);
+        if (DEBUG)
+            Log.v(TAG, "newPlayStatus " + newPlayStatus);
+
+        deviceFeatures[deviceIndex].mCurrentPlayState = state;
+
+        if ((deviceFeatures[deviceIndex].mPlayStatusChangedNT ==
+                NOTIFICATION_TYPE_INTERIM) && (oldPlayStatus != newPlayStatus)) {
+            deviceFeatures[deviceIndex].mPlayStatusChangedNT = NOTIFICATION_TYPE_CHANGED;
+            registerNotificationRspPlayStatusNative(
+                    deviceFeatures[deviceIndex].mPlayStatusChangedNT,
+                    newPlayStatus,
+                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
         }
     }
 
-    private void updatePlayPauseState(int state, long currentPosMs) {
-        if (DEBUG) Log.v(TAG,
-                "updatePlayPauseState, old=" + mCurrentPlayState + ", state=" + state);
+    private void updatePlayerStateAndPosition(int state, long currentPosMs) {
+        if (DEBUG) Log.v(TAG, "updatePlayerPlayPauseState, old=" +
+                            mCurrentPlayerState + ", state=" + state);
         boolean oldPosValid = (mCurrentPosMs !=
                                RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN);
-        int oldPlayStatus = convertPlayStateToPlayStatus(mCurrentPlayState);
+
+        if (DEBUG) Log.v(TAG, "old state = " + mCurrentPlayerState + ", new state= " + state);
+        int oldPlayStatus = convertPlayStateToPlayStatus(mCurrentPlayerState);
         int newPlayStatus = convertPlayStateToPlayStatus(state);
 
-        if ((mCurrentPlayState == RemoteControlClient.PLAYSTATE_PLAYING) &&
-            (mCurrentPlayState != state) && oldPosValid) {
-            mCurrentPosMs = getPlayPosition();
+        if ((mCurrentPlayerState == RemoteControlClient.PLAYSTATE_PLAYING) &&
+            (mCurrentPlayerState != state) && oldPosValid) {
+            mCurrentPosMs = getPlayPosition(null);
+            Log.d(TAG, "Update mCurrentPosMs to " + mCurrentPosMs);
         }
 
-        if (currentPosMs != RemoteControlClient.PLAYBACK_POSITION_INVALID) {
-            mCurrentPosMs = currentPosMs;
-        }
-        if ((state == RemoteControlClient.PLAYSTATE_PLAYING) &&
-            ((currentPosMs != RemoteControlClient.PLAYBACK_POSITION_INVALID) ||
-            (mCurrentPlayState != RemoteControlClient.PLAYSTATE_PLAYING))) {
+        if ((state == RemoteControlClient.PLAYSTATE_PLAYING) && (mCurrentPlayerState != state)) {
             mPlayStartTimeMs = SystemClock.elapsedRealtime();
+            Log.d(TAG, "Update mPlayStartTimeMs to " + mPlayStartTimeMs);
+        }
+
+        mCurrentPlayerState = state;
+
+        if (!(RemoteControlClient.PLAYSTATE_PLAYING == mCurrentPlayerState
+                                             && mCurrentPosMs == currentPosMs)) {
+            if (currentPosMs != RemoteControlClient.PLAYBACK_POSITION_INVALID) {
+                mCurrentPosMs = currentPosMs;
+                mPlayStartTimeMs = SystemClock.elapsedRealtime();
+                Log.d(TAG, "Update mPlayStartTimeMs: " + mPlayStartTimeMs +
+                                            " mCurrentPosMs: " + mCurrentPosMs);
+            }
         }
-        mCurrentPlayState = state;
 
         boolean newPosValid = (mCurrentPosMs !=
                                RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN);
-        long playPosition = getPlayPosition();
+        long playPosition = getPlayPosition(null);
         mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
-        /* need send play position changed notification when play status is changed */
-        if ((mPlayPosChangedNT == NOTIFICATION_TYPE_INTERIM) &&
-            ((oldPlayStatus != newPlayStatus) || (oldPosValid != newPosValid) ||
-             (newPosValid && ((playPosition >= mNextPosMs) || (playPosition <= mPrevPosMs))))) {
-            mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
-            registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int)playPosition);
+        for (int deviceIndex = 0; deviceIndex < maxAvrcpConnections; deviceIndex++) {
+            if (deviceFeatures[deviceIndex].mCurrentDevice != null &&
+                    ((deviceFeatures[deviceIndex].mPlayPosChangedNT == NOTIFICATION_TYPE_INTERIM) &&
+                    ((oldPlayStatus != newPlayStatus) || (oldPosValid != newPosValid) ||
+                    (newPosValid && ((playPosition >= deviceFeatures[deviceIndex].mNextPosMs) ||
+                    (playPosition <= deviceFeatures[deviceIndex].mPrevPosMs)))))) {
+                deviceFeatures[deviceIndex].mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
+                registerNotificationRspPlayPosNative(deviceFeatures[deviceIndex].mPlayPosChangedNT,
+                        (int)playPosition,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+            }
+            if (deviceFeatures[deviceIndex].mCurrentDevice != null &&
+                    ((deviceFeatures[deviceIndex].mPlayPosChangedNT ==
+                    NOTIFICATION_TYPE_INTERIM) && newPosValid &&
+                    (state == RemoteControlClient.PLAYSTATE_PLAYING))) {
+                Message msg = mHandler.obtainMessage(MESSAGE_PLAY_INTERVAL_TIMEOUT,
+                    0, 0, deviceFeatures[deviceIndex].mCurrentDevice);
+                mHandler.sendMessageDelayed(msg, deviceFeatures[deviceIndex].mNextPosMs
+                                                                            - playPosition);
+            }
+            /*Discretion is required only when updating play state changed as playing*/
+            if ((state != RemoteControlClient.PLAYSTATE_PLAYING) ||
+                                isPlayStateToBeUpdated(deviceIndex)) {
+                updatePlayStatusForDevice(deviceIndex, state);
+            }
         }
-        if ((mPlayPosChangedNT == NOTIFICATION_TYPE_INTERIM) && newPosValid &&
-            (state == RemoteControlClient.PLAYSTATE_PLAYING)) {
-            Message msg = mHandler.obtainMessage(MESSAGE_PLAY_INTERVAL_TIMEOUT);
-            mHandler.sendMessageDelayed(msg, mNextPosMs - playPosition);
+    }
+
+    private boolean isPlayStateToBeUpdated(int deviceIndex) {
+        Log.v(TAG, "isPlayStateTobeUpdated: device: "  +
+                    deviceFeatures[deviceIndex].mCurrentDevice);
+        if (maxAvrcpConnections < 2) {
+            Log.v(TAG, "maxAvrcpConnections: " + maxAvrcpConnections);
+            return true;
+        } else if(mA2dpService.isMulticastFeatureEnabled()) {
+            if (!areMultipleDevicesConnected()) {
+                Log.v(TAG, "Single connection exists");
+                return true;
+            } else if (mA2dpService.isMulticastEnabled()) {
+                Log.v(TAG, "Multicast is Enabled");
+                return true;
+            } else {
+                Log.v(TAG, "Multiple connection exists, Multicast not enabled");
+                if(isDeviceActiveInHandOffNative(getByteAddress(
+                            deviceFeatures[deviceIndex].mCurrentDevice))) {
+                    Log.v(TAG, "Device Active in handoff scenario");
+                    return true;
+                } else {
+                    Log.v(TAG, "Device Not Active in handoff scenario");
+                    return false;
+                }
+            }
+        } else {
+            if (!areMultipleDevicesConnected()) {
+                Log.v(TAG, "Single connection exists");
+                return true;
+            } else {
+                Log.v(TAG, "Multiple connection exists in handoff");
+                if(isDeviceActiveInHandOffNative(getByteAddress(
+                            deviceFeatures[deviceIndex].mCurrentDevice))) {
+                    Log.v(TAG, "Device Active in handoff scenario");
+                    return true;
+                } else {
+                    Log.v(TAG, "Device Not Active in handoff scenario");
+                    return false;
+                }
+            }
         }
+    }
 
-        if ((mPlayStatusChangedNT == NOTIFICATION_TYPE_INTERIM) && (oldPlayStatus != newPlayStatus)) {
-            mPlayStatusChangedNT = NOTIFICATION_TYPE_CHANGED;
-            registerNotificationRspPlayStatusNative(mPlayStatusChangedNT, newPlayStatus);
+    private boolean areMultipleDevicesConnected() {
+        for (int deviceIndex = 0; deviceIndex < maxAvrcpConnections; deviceIndex++) {
+            if (deviceFeatures[deviceIndex].mCurrentDevice == null) {
+                return false;
+            }
         }
+        return true;
     }
 
     private void updateTransportControls(int transportControlFlags) {
         mTransportControlFlags = transportControlFlags;
     }
 
-    class Metadata {
-        private String artist;
-        private String trackTitle;
-        private String albumTitle;
-
-        public Metadata() {
-            artist = null;
-            trackTitle = null;
-            albumTitle = null;
+    private void updateAvailableMediaPlayers() {
+        /* for registerged notification check for all devices which has
+         * registered for change notification */
+        if (DEBUG)
+            Log.v(TAG, "updateAvailableMediaPlayers");
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mAvailablePlayersChangedNT ==
+                    NOTIFICATION_TYPE_INTERIM) {
+                deviceFeatures[i].mAvailablePlayersChangedNT = NOTIFICATION_TYPE_CHANGED;
+                if (DEBUG)
+                    Log.v(TAG, "send AvailableMediaPlayers to stack");
+                registerNotificationRspAvailablePlayersChangedNative(
+                        deviceFeatures[i].mAvailablePlayersChangedNT,
+                        getByteAddress(deviceFeatures[i].mCurrentDevice));
+            }
         }
+    }
+    private void updateAddressedMediaPlayer(int playerId) {
+        Log.v(TAG, "updateAddressedMediaPlayer");
+        Log.v(TAG, "current Player: " + mAddressedPlayerId);
+        Log.v(TAG, "Requested Player: " + playerId);
 
-        public String toString() {
+        int previousAddressedPlayerId;
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if ((deviceFeatures[i].mAddressedPlayerChangedNT ==
+                    NOTIFICATION_TYPE_INTERIM) &&
+                    (mAddressedPlayerId != playerId)) {
+                if (DEBUG)
+                    Log.v(TAG, "send AddressedMediaPlayer to stack: playerId" + playerId);
+                previousAddressedPlayerId = mAddressedPlayerId;
+                deviceFeatures[i].mAddressedPlayerChangedNT = NOTIFICATION_TYPE_CHANGED;
+                registerNotificationRspAddressedPlayerChangedNative(
+                        deviceFeatures[i].mAddressedPlayerChangedNT,
+                        playerId, getByteAddress(deviceFeatures[i].mCurrentDevice));
+                if (previousAddressedPlayerId != INVALID_ADDRESSED_PLAYER_ID) {
+                    resetAndSendPlayerStatusReject();
+                }
+            } else {
+                if (DEBUG)
+                    Log.v(TAG, "Do not reset notifications, ADDR_PLAYR_CHNGD not registered");
+            }
+        }
+        mAddressedPlayerId = playerId;
+    }
+
+    public void updateResetNotification(int notificationType) {
+        Log.v(TAG,"notificationType " + notificationType);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            switch (notificationType) {
+                case PLAY_STATUS_CHANGE_NOTIFICATION:
+                    if (deviceFeatures[i].mPlayStatusChangedNT ==
+                            NOTIFICATION_TYPE_INTERIM) {
+                        deviceFeatures[i].mPlayStatusChangedNT =
+                                NOTIFICATION_TYPE_REJECT;
+                        registerNotificationRspPlayStatusNative(
+                                deviceFeatures[i].mPlayStatusChangedNT,
+                                PLAYSTATUS_STOPPED,
+                                getByteAddress(deviceFeatures[i].mCurrentDevice));
+                    } else {
+                        Log.v(TAG,"i " + i + " status is"+
+                            deviceFeatures[i].mPlayStatusChangedNT);
+                    }
+                    break;
+                case PLAY_POSITION_CHANGE_NOTIFICATION:
+                    if (deviceFeatures[i].mPlayPosChangedNT ==
+                            NOTIFICATION_TYPE_INTERIM) {
+                        if (DEBUG)
+                            Log.v(TAG, "send Play Position reject to stack");
+                        deviceFeatures[i].mPlayPosChangedNT =
+                                NOTIFICATION_TYPE_REJECT;
+                        registerNotificationRspPlayPosNative(
+                                deviceFeatures[i].mPlayPosChangedNT,
+                                -1 ,getByteAddress(deviceFeatures[i].mCurrentDevice));
+                        mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
+                    } else {
+                        Log.v(TAG,"i " + i + " status is"+
+                            deviceFeatures[i].mPlayPosChangedNT);
+                    }
+
+                    break;
+                case TRACK_CHANGE_NOTIFICATION:
+                    if (deviceFeatures[i].mTrackChangedNT ==
+                            NOTIFICATION_TYPE_INTERIM) {
+                             if (DEBUG)
+                                Log.v(TAG, "send Track Changed reject to stack");
+                             deviceFeatures[i].mTrackChangedNT =
+                                    NOTIFICATION_TYPE_REJECT;
+                             byte[] track = new byte[TRACK_ID_SIZE];
+                             /* track is stored in big endian format */
+                             for (int j = 0; j < TRACK_ID_SIZE; ++j) {
+                                 track[j] = (byte) (mTrackNumber >> (56 - 8 * j));
+                             }
+                             registerNotificationRspTrackChangeNative(
+                                     deviceFeatures[i].mTrackChangedNT ,
+                                     track ,getByteAddress(deviceFeatures[i].mCurrentDevice));
+                    } else {
+                        Log.v(TAG,"i " + i + " status is"+
+                            deviceFeatures[i].mTrackChangedNT);
+                    }
+
+                    break;
+                case NOW_PALYING_CONTENT_CHANGED_NOTIFICATION:
+                    if (deviceFeatures[i].mNowPlayingContentChangedNT ==
+                            NOTIFICATION_TYPE_INTERIM) {
+                        if (DEBUG)
+                            Log.v(TAG, "send Now playing changed reject to stack");
+                        deviceFeatures[i].mNowPlayingContentChangedNT =
+                                NOTIFICATION_TYPE_REJECT;
+                        registerNotificationRspNowPlayingContentChangedNative(
+                                deviceFeatures[i].mNowPlayingContentChangedNT ,
+                                getByteAddress(deviceFeatures[i].mCurrentDevice));
+                    } else {
+                        Log.v(TAG,"i " + i + " status is"+
+                            deviceFeatures[i].mNowPlayingContentChangedNT);
+                    }
+
+                    break;
+                default :
+                    Log.e(TAG,"Invalid Notification type ");
+            }
+        }
+    }
+
+    private void resetAndSendPlayerStatusReject() {
+        if (DEBUG)
+            Log.v(TAG, "resetAndSendPlayerStatusReject");
+        updateResetNotification(PLAY_STATUS_CHANGE_NOTIFICATION);
+        updateResetNotification(PLAY_POSITION_CHANGE_NOTIFICATION);
+        updateResetNotification(TRACK_CHANGE_NOTIFICATION);
+        updateResetNotification(NOW_PALYING_CONTENT_CHANGED_NOTIFICATION);
+    }
+
+    void updateBrowsedPlayerFolder(int numOfItems, int status, String[] folderNames) {
+        Log.v(TAG, "updateBrowsedPlayerFolder: numOfItems =  " + numOfItems
+              + " status = " + status);
+        if (mBrowserDevice == null) {
+            Log.e(TAG,"mBrowserDevice is null for music player called api");
+        }
+        BluetoothDevice device = mBrowserDevice;
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        deviceFeatures[deviceIndex].mCurrentPath = PATH_ROOT;
+        deviceFeatures[deviceIndex].mCurrentPathUid = null;
+        deviceFeatures[deviceIndex].mMediaUri = mMediaUriStatic;
+        mMediaUriStatic = null;
+
+        setBrowsedPlayerRspNative((byte)status, 0x0, numOfItems, 0x0, CHAR_SET_UTF8,
+                                   folderNames, getByteAddress(device));
+        mBrowserDevice = null;
+    }
+
+    void updateNowPlayingContentChanged() {
+        Log.v(TAG, "updateNowPlayingContentChanged");
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mNowPlayingContentChangedNT ==
+                    NOTIFICATION_TYPE_INTERIM) {
+                Log.v(TAG, "Notify peer on updateNowPlayingContentChanged");
+                deviceFeatures[i].mNowPlayingContentChangedNT = NOTIFICATION_TYPE_CHANGED;
+                registerNotificationRspNowPlayingContentChangedNative(
+                        deviceFeatures[i].mNowPlayingContentChangedNT ,
+                        getByteAddress(deviceFeatures[i].mCurrentDevice));
+            }
+        }
+    }
+
+    void updatePlayItemResponse(boolean success) {
+        Log.v(TAG, "updatePlayItemResponse: success: " + success);
+        BluetoothDevice device = mBrowserDevice;
+        if (mBrowserDevice == null) {
+            Log.e(TAG, "mBrowserDevice is null for music app called API");
+        }
+        /* add member for getting current setting get play item pending rsp
+         * and clear it when this is recieved */
+        if (success) {
+            playItemRspNative(OPERATION_SUCCESSFUL ,
+                    getByteAddress(device));
+
+        } else {
+            playItemRspNative(INTERNAL_ERROR ,
+                    getByteAddress(device));
+        }
+        mBrowserDevice = null;
+    }
+
+    void updateNowPlayingEntriesReceived(long[] playList) {
+        Log.e(TAG,"updateNowPlayingEntriesReceived called");
+        int status = OPERATION_SUCCESSFUL;
+        int numItems = 0;
+        long reqItems = (mCachedRequest.mEnd - mCachedRequest.mStart) + 1;
+        long availableItems = 0;
+        Cursor cursor = null;
+        int[] itemType = new int[MAX_BROWSE_ITEM_TO_SEND];
+        long[] uid = new long[MAX_BROWSE_ITEM_TO_SEND];
+        int[] type = new int[MAX_BROWSE_ITEM_TO_SEND];
+        byte[] playable = new byte[MAX_BROWSE_ITEM_TO_SEND];
+        String[] displayName = new String[MAX_BROWSE_ITEM_TO_SEND];
+        byte[] numAtt = new byte[MAX_BROWSE_ITEM_TO_SEND];
+        String[] attValues = new String[MAX_BROWSE_ITEM_TO_SEND * 7];
+        int[] attIds = new int[MAX_BROWSE_ITEM_TO_SEND * 7];
+        int index;
+        if (mBrowserDevice == null) {
+            Log.e(TAG,"mBrowserDevice is null for music app called API");
+        }
+        BluetoothDevice device = mBrowserDevice;
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid device index");
+            return;
+        }
+
+        Log.v(TAG, "updateNowPlayingEntriesReceived");
+
+        // Item specific attribute's entry starts from index*7, reset all such entries to 0 for now
+        for (int count = 0; count < (MAX_BROWSE_ITEM_TO_SEND * 7); count++) {
+            attValues[count] = "";
+            attIds[count] = 0;
+        }
+
+        availableItems = playList.length;
+        if ((mCachedRequest.mStart + 1) > availableItems) {
+            Log.i(TAG, "startIteam exceeds the available item index");
+            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                    numItems, itemType, uid, type,
+                    playable, displayName, numAtt, attValues, attIds,
+                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+            return;
+        }
+
+        if ((mCachedRequest.mStart < 0) || (mCachedRequest.mEnd < 0) ||
+                            (mCachedRequest.mStart > mCachedRequest.mEnd)) {
+            Log.i(TAG, "wrong start / end index");
+            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                    numItems, itemType, uid, type,
+                    playable, displayName, numAtt, attValues, attIds,
+                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+            return;
+        }
+
+        availableItems = availableItems - mCachedRequest.mStart;
+        Log.i(TAG, "start Index: " + mCachedRequest.mStart);
+        Log.i(TAG, "end Index: " + mCachedRequest.mEnd);
+        Log.i(TAG, "availableItems: " + availableItems);
+        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+        if (reqItems > availableItems)
+            reqItems = availableItems;
+        Log.i(TAG, "reqItems: " + reqItems);
+
+        for (index = 0; index < reqItems; index++) {
+            try {
+                cursor = mContext.getContentResolver().query(
+                     deviceFeatures[deviceIndex].mMediaUri, mCursorCols,
+                     MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" +
+                         playList[index + (int)mCachedRequest.mStart], null, null);
+                if (cursor != null) {
+                    int validAttrib = 0;
+                    cursor.moveToFirst();
+                    itemType[index] = TYPE_MEDIA_ELEMENT_ITEM;
+                    uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow("_id"));
+                    type[index] = MEDIA_TYPE_AUDIO;
+                    playable[index] = 0;
+                    displayName[index] = cursor.getString(cursor.getColumnIndexOrThrow(
+                                                            MediaStore.Audio.Media.TITLE));
+                    for (int attIndex = 0; attIndex < mCachedRequest.mAttrCnt; attIndex++) {
+                        int attr = mCachedRequest.mAttrList.get(attIndex).intValue();
+                        if ((attr <= MEDIA_ATTR_MAX) && (attr >= MEDIA_ATTR_MIN)) {
+                            attValues[(7 * index) + attIndex] = getAttributeStringFromCursor(
+                                    cursor, attr, deviceIndex);
+                            attIds[(7 * index) + attIndex] = attr;
+                            validAttrib ++;
+                        }
+                    }
+                    numAtt[index] = (byte)validAttrib;
+                }
+            } catch(Exception e) {
+                Log.i(TAG, "Exception e"+ e);
+                getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                        numItems, itemType, uid, type,
+                        playable, displayName, numAtt, attValues, attIds,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }
+        numItems = index;
+        getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                numItems, itemType, uid, type,
+                playable, displayName, numAtt, attValues, attIds,
+                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+        mBrowserDevice = null;
+    }
+
+    class CachedRequest {
+        long mStart;
+        long mEnd;
+        byte mAttrCnt;
+        ArrayList<Integer> mAttrList;
+        public CachedRequest(long start, long end, byte attrCnt, int[] attrs) {
+            mStart = start;
+            mEnd = end;
+            mAttrCnt = attrCnt;
+            mAttrList = new ArrayList<Integer>();
+            for (int i = 0; i < attrCnt; ++i) {
+                mAttrList.add(new Integer(attrs[i]));
+            }
+        }
+    }
+
+    class FolderListEntries {
+        byte mScope;
+        long mStart;
+        long mEnd;
+        int mAttrCnt;
+        int mNumAttr;
+        String mAddress;
+        ArrayList<Integer> mAttrList;
+        public FolderListEntries(byte scope, long start, long end, int attrCnt, int numAttr,
+                int[] attrs, String deviceAddress) {
+            mScope = scope;
+            mStart = start;
+            mEnd = end;
+            mAttrCnt = attrCnt;
+            mNumAttr = numAttr;
+            mAddress = deviceAddress;
+            int i;
+            mAttrList = new ArrayList<Integer>();
+            for (i = 0; i < numAttr; ++i) {
+                mAttrList.add(new Integer(attrs[i]));
+            }
+        }
+    }
+
+    class Metadata {
+        private String artist;
+        private String trackTitle;
+        private String albumTitle;
+        private String genre;
+        private long tracknum;
+
+        public Metadata() {
+            artist = null;
+            trackTitle = null;
+            albumTitle = null;
+            genre = null;
+            tracknum = -1L;
+        }
+
+        public String toString() {
             return "Metadata[artist=" + artist + " trackTitle=" + trackTitle + " albumTitle=" +
-                   albumTitle + "]";
+                   albumTitle + " genre=" + genre + " tracknum=" + Long.toString(tracknum) + "]";
         }
     }
 
     private void updateMetadata(MetadataEditor data) {
+        if (DEBUG)
+            Log.v(TAG, "updateMetadata");
+
         String oldMetadata = mMetadata.toString();
         mMetadata.artist = data.getString(MediaMetadataRetriever.METADATA_KEY_ARTIST, null);
         mMetadata.trackTitle = data.getString(MediaMetadataRetriever.METADATA_KEY_TITLE, null);
         mMetadata.albumTitle = data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUM, null);
+        mMetadata.genre = data.getString(MediaMetadataRetriever.METADATA_KEY_GENRE, null);
+        mTrackNumber = data.getLong(MediaMetadataRetriever.METADATA_KEY_NUM_TRACKS, 0L);
+        mMetadata.tracknum = data.getLong(MediaMetadataRetriever.METADATA_KEY_CD_TRACK_NUMBER, 0L);
+
+        Log.v(TAG,"old Metadata = " + oldMetadata);
+        Log.v(TAG,"new MetaData " + mMetadata.toString());
+
         if (!oldMetadata.equals(mMetadata.toString())) {
-            mTrackNumber++;
-            if (mTrackChangedNT == NOTIFICATION_TYPE_INTERIM) {
-                mTrackChangedNT = NOTIFICATION_TYPE_CHANGED;
-                sendTrackChangedRsp();
+            Log.v(TAG,"new mMetadata, mTrackNumber update to " + mTrackNumber);
+            for (int i = 0; i < maxAvrcpConnections; i++) {
+                if ((deviceFeatures[i].mCurrentDevice != null) &&
+                    (deviceFeatures[i].mTrackChangedNT == NOTIFICATION_TYPE_INTERIM)) {
+                    deviceFeatures[i].mTrackChangedNT = NOTIFICATION_TYPE_CHANGED;
+                    Log.v(TAG,"sending track change for device " + i);
+                    sendTrackChangedRsp(deviceFeatures[i].mCurrentDevice);
+                }
             }
-
             if (mCurrentPosMs != RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN) {
                 mCurrentPosMs = 0L;
-                if (mCurrentPlayState == RemoteControlClient.PLAYSTATE_PLAYING) {
-                    mPlayStartTimeMs = SystemClock.elapsedRealtime();
+                for (int i = 0; i < maxAvrcpConnections; i++) {
+                    if ((deviceFeatures[i].mCurrentDevice != null) &&
+                        (deviceFeatures[i].mCurrentPlayState ==
+                                RemoteControlClient.PLAYSTATE_PLAYING)) {
+                        Log.i(TAG,"updated mPlayStartTimeMs");
+                        mPlayStartTimeMs = SystemClock.elapsedRealtime();
+                        break;
+                    }
                 }
             }
             /* need send play position changed notification when track is changed */
-            if (mPlayPosChangedNT == NOTIFICATION_TYPE_INTERIM) {
-                mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
-                registerNotificationRspPlayPosNative(mPlayPosChangedNT,
-                                                     (int)getPlayPosition());
-                mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
+            for (int i = 0; i < maxAvrcpConnections; i++) {
+                Log.v(TAG,i + " mCurrentPlayState " + deviceFeatures[i].mCurrentPlayState);
+                if (deviceFeatures[i].mPlayPosChangedNT == NOTIFICATION_TYPE_INTERIM &&
+                        deviceFeatures[i].mCurrentPlayState ==
+                        RemoteControlClient.PLAYSTATE_PLAYING) {
+                    Log.v(TAG,"sending play pos change for device " + i);
+                    deviceFeatures[i].mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
+                    registerNotificationRspPlayPosNative(deviceFeatures[i].mPlayPosChangedNT,
+                            (int)getPlayPosition(deviceFeatures[i].mCurrentDevice) ,
+                            getByteAddress(deviceFeatures[i].mCurrentDevice));
+                    mHandler.removeMessages(MESSAGE_PLAY_INTERVAL_TIMEOUT);
+                }
             }
         }
-        if (DEBUG) Log.v(TAG, "mMetadata=" + mMetadata.toString());
+        if (DEBUG)
+            Log.v(TAG, "mMetadata=" + mMetadata.toString());
 
         mSongLengthMs = data.getLong(MediaMetadataRetriever.METADATA_KEY_DURATION,
                 RemoteControlClient.PLAYBACK_POSITION_INVALID);
-        if (DEBUG) Log.v(TAG, "duration=" + mSongLengthMs);
+        if (DEBUG)
+            Log.v(TAG, "duration=" + mSongLengthMs);
     }
 
     private void getRcFeatures(byte[] address, int features) {
@@ -586,80 +2059,1979 @@ public final class Avrcp {
         mHandler.sendMessage(msg);
     }
 
-    private void getPlayStatus() {
-        Message msg = mHandler.obtainMessage(MESSAGE_GET_PLAY_STATUS);
+    private void getPlayStatus(byte[] address) {
+        Message msg = mHandler.obtainMessage(MESSAGE_GET_PLAY_STATUS, 0, 0,
+                Utils.getAddressStringFromByte(address));
         mHandler.sendMessage(msg);
     }
 
-    private void getElementAttr(byte numAttr, int[] attrs) {
+    private void getElementAttr(byte numAttr, int[] attrs, byte[] address) {
         int i;
         ArrayList<Integer> attrList = new ArrayList<Integer>();
         for (i = 0; i < numAttr; ++i) {
             attrList.add(attrs[i]);
         }
-        Message msg = mHandler.obtainMessage(MESSAGE_GET_ELEM_ATTRS, numAttr, 0, attrList);
+        ItemAttr itemAttr = new ItemAttr(attrList, 0,
+                Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_GET_ELEM_ATTRS, (int)numAttr, 0,
+                itemAttr);
         mHandler.sendMessage(msg);
     }
 
-    private void registerNotification(int eventId, int param) {
-        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_NOTIFICATION, eventId, param);
+    private void setBrowsedPlayer(int playerId, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "setBrowsedPlayer: PlayerID: " + playerId);
+        Message msg = mHandler.obtainMessage(MESSAGE_SET_BROWSED_PLAYER, playerId, 0,
+                Utils.getAddressStringFromByte(address));
         mHandler.sendMessage(msg);
     }
 
-    private void processRegisterNotification(int eventId, int param) {
+    private void processSetBrowsedPlayer(int playerId, String deviceAddress) {
+        String packageName = null;
+        byte retError = INVALID_PLAYER_ID;
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        /* Following gets updated if SetBrowsed Player succeeds */
+        deviceFeatures[deviceIndex].mCurrentPath = PATH_INVALID;
+        deviceFeatures[deviceIndex].mMediaUri = Uri.EMPTY;
+        deviceFeatures[deviceIndex].mCurrentPathUid = null;
+        if (DEBUG)
+            Log.v(TAG, "processSetBrowsedPlayer: PlayerID: " + playerId);
+        if (mMediaPlayers.size() > 0) {
+            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+            while (rccIterator.hasNext()) {
+                final MediaPlayerInfo di = rccIterator.next();
+                if (di.RetrievePlayerId() == playerId) {
+                    if (di.GetPlayerAvailablility()) {
+                        if (DEBUG)
+                            Log.v(TAG, "player found and available");
+                        if (di.IsPlayerBrowsable()) {
+                            if (di.IsPlayerBrowsableWhenAddressed()) {
+                                if (di.GetPlayerFocus()) {
+                                    packageName = di.RetrievePlayerPackageName();
+                                    if (DEBUG)
+                                        Log.v(TAG, "player addressed hence browsable");
+                                } else {
+                                    if (DEBUG)
+                                        Log.v(TAG, "Reject: player browsable only" +
+                                                                            "when addressed");
+                                    retError = PLAYER_NOT_ADDRESSED;
+                                }
+                            } else {
+                                packageName = di.RetrievePlayerPackageName();
+                            }
+                        } else {
+                            retError = PLAYER_NOT_BROWSABLE;
+                        }
+                    }
+                }
+            }
+        }
+        if (packageName != null) {
+            mRemoteController.setRemoteControlClientBrowsedPlayer();
+            mBrowserDevice = device;
+        } else {
+            if (DEBUG)
+                Log.v(TAG, "player not available for browse");
+            setBrowsedPlayerRspNative(retError ,
+                    0x0, 0x0, 0x0, 0x0,
+                    null, getByteAddress(device));
+        }
+    }
+
+    private void fastForward(int keyState, String deviceAddress) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        if ((keyState == deviceFeatures[deviceIndex].keyPressState) &&
+                (keyState == KEY_STATE_RELEASE)) {
+            Log.e(TAG, "Ignore key release event");
+        } else {
+            Message msg = mHandler.obtainMessage(MESSAGE_FAST_FORWARD, keyState,
+                    0, deviceAddress);
+            mHandler.sendMessage(msg);
+            deviceFeatures[deviceIndex].keyPressState = keyState;
+        }
+    }
+
+    private void rewind(int keyState, String deviceAddress) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        if ((keyState == deviceFeatures[deviceIndex].keyPressState) &&
+                (keyState == KEY_STATE_RELEASE)) {
+            Log.e(TAG, "Ignore key release event");
+        } else {
+            Message msg = mHandler.obtainMessage(MESSAGE_REWIND, keyState, 0,
+                    deviceAddress);
+            mHandler.sendMessage(msg);
+            deviceFeatures[deviceIndex].keyPressState = keyState;
+        }
+    }
+
+    private void changePath(byte direction, long uid, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "changePath: direction: " + direction + " uid:" + uid);
+        ItemAttr itemAttr = new ItemAttr(null, uid,
+                Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_CHANGE_PATH, direction, 0, itemAttr);
+        mHandler.sendMessage(msg);
+    }
+
+    private void processChangePath(int direction, long folderUid,
+            String deviceAddress) {
+        if (DEBUG)
+            Log.v(TAG, "processChangePath: direction: " + direction +
+                    " uid:" + folderUid);
+        long numberOfItems = 0;
+        int status = OPERATION_SUCCESSFUL;
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ROOT)){
+            switch (direction) {
+                case FOLDER_UP:
+                    status = DOES_NOT_EXIST;
+                    break;
+                case FOLDER_DOWN:
+                    if (folderUid == UID_TITLES) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_TITLES;
+                        numberOfItems = getNumItems(PATH_TITLES,
+                            MediaStore.Audio.Media.TITLE, deviceIndex);
+                    } else if (folderUid == UID_ALBUM) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ALBUMS;
+                        numberOfItems = getNumItems(PATH_ALBUMS,
+                            MediaStore.Audio.Media.ALBUM_ID, deviceIndex);
+                    } else if (folderUid == UID_ARTIST) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ARTISTS;
+                        numberOfItems = getNumItems(PATH_ARTISTS,
+                            MediaStore.Audio.Media.ARTIST_ID, deviceIndex);
+                    } else if (folderUid == UID_PLAYLIST) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_PLAYLISTS;
+                        numberOfItems = getNumPlaylistItems();
+                    } else {
+                        status = DOES_NOT_EXIST;
+                    }
+                    break;
+                default:
+                    status = INVALID_DIRECTION;
+                    break;
+            }
+        } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_TITLES)) {
+            switch (direction) {
+                case FOLDER_UP:
+                    deviceFeatures[deviceIndex].mCurrentPath = PATH_ROOT;
+                    numberOfItems = NUM_ROOT_ELEMENTS;
+                    break;
+                case FOLDER_DOWN:
+                    Cursor cursor = null;
+                    try {
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            new String[] {MediaStore.Audio.Media.TITLE},
+                            MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id="
+                            + folderUid, null, null);
+                        if (cursor != null)
+                            status = NOT_A_DIRECTORY;
+                        else
+                            status = DOES_NOT_EXIST;
+                    } catch (Exception e) {
+                        Log.e(TAG, "Exception " + e);
+                        changePathRspNative(INTERNAL_ERROR ,
+                                numberOfItems ,
+                                getByteAddress(device));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                    break;
+                default:
+                    status = INVALID_DIRECTION;
+                    break;
+            }
+        } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ALBUMS)) {
+            switch (direction) {
+                case FOLDER_UP:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) { // Path @ Album
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ROOT;
+                        numberOfItems = NUM_ROOT_ELEMENTS;
+                    } else { // Path @ individual album id
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ALBUMS;
+                        deviceFeatures[deviceIndex].mCurrentPathUid = null;
+                        numberOfItems = getNumItems(PATH_ALBUMS,
+                            MediaStore.Audio.Media.ALBUM_ID, deviceIndex);
+                    }
+                    break;
+                case FOLDER_DOWN:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) { // Path @ Album
+                        Cursor cursor = null;
+                        try {
+                            cursor = mContext.getContentResolver().query(
+                                deviceFeatures[deviceIndex].mMediaUri,
+                                new String[] {MediaStore.Audio.Media.ALBUM},
+                                MediaStore.Audio.Media.IS_MUSIC + "=1 AND " +
+                                MediaStore.Audio.Media.ALBUM_ID + "=" + folderUid,
+                                null, null);
+                            if ((cursor == null) || (cursor.getCount() == 0)) {
+                                status = DOES_NOT_EXIST;
+                            } else{
+                                numberOfItems = cursor.getCount();
+                                deviceFeatures[deviceIndex].mCurrentPathUid =
+                                        String.valueOf(folderUid);
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG, "Exception " + e);
+                            changePathRspNative(INTERNAL_ERROR ,
+                                    numberOfItems ,
+                                    getByteAddress(device));
+                        } finally {
+                            if (cursor != null) {
+                                cursor.close();
+                            }
+                        }
+                    } else { // Path @ Individual Album id
+                        Cursor cursor = null;
+                        try {
+                            cursor = mContext.getContentResolver().query(
+                                deviceFeatures[deviceIndex].mMediaUri,
+                                new String[] {MediaStore.Audio.Media.TITLE},
+                                MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" + folderUid,
+                                null, null);
+                            /* As Individual Album path can not have any folder in it hence return
+                             * the error as applicable, depending on whether uid passed
+                             * exists. */
+                            if (cursor != null)
+                                status = NOT_A_DIRECTORY;
+                            else
+                                status = DOES_NOT_EXIST;
+                        } catch (Exception e) {
+                            Log.e(TAG, "Exception " + e);
+                            changePathRspNative(INTERNAL_ERROR ,
+                                    numberOfItems ,
+                                    getByteAddress(device));
+                        } finally {
+                            if (cursor != null) {
+                                cursor.close();
+                            }
+                        }
+                    }
+                    break;
+                default:
+                    status = INVALID_DIRECTION;
+                    break;
+            }
+        } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ARTISTS)) {
+            switch(direction) {
+                case FOLDER_UP:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ROOT;
+                        numberOfItems = NUM_ROOT_ELEMENTS;
+                    } else {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ARTISTS;
+                        deviceFeatures[deviceIndex].mCurrentPathUid = null;
+                        numberOfItems = getNumItems(PATH_ARTISTS,
+                            MediaStore.Audio.Media.ARTIST_ID, deviceIndex);
+                    }
+                    break;
+                case FOLDER_DOWN:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                        Cursor cursor = null;
+                        try {
+                            cursor = mContext.getContentResolver().query(
+                                deviceFeatures[deviceIndex].mMediaUri,
+                                new String[] {MediaStore.Audio.Media.ARTIST},
+                                MediaStore.Audio.Media.IS_MUSIC + "=1 AND " +
+                                MediaStore.Audio.Media.ARTIST_ID + "=" + folderUid,
+                                null, null);
+                            if ((cursor == null) || (cursor.getCount() == 0)) {
+                                status = DOES_NOT_EXIST;
+                            } else{
+                                numberOfItems = cursor.getCount();
+                                deviceFeatures[deviceIndex].mCurrentPathUid =
+                                        String.valueOf(folderUid);
+                                deviceFeatures[deviceIndex].mCurrentPath = PATH_ARTISTS;
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG, "Exception " + e);
+                            changePathRspNative(INTERNAL_ERROR ,
+                                    numberOfItems ,
+                                    getByteAddress(device));
+                        } finally {
+                            if (cursor != null) {
+                                cursor.close();
+                            }
+                        }
+                    } else {
+                        Cursor cursor = null;
+                        try {
+                            cursor = mContext.getContentResolver().query(
+                                deviceFeatures[deviceIndex].mMediaUri,
+                                new String[] {MediaStore.Audio.Media.TITLE},
+                                MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id="
+                                + folderUid, null, null);
+                            if (cursor != null)
+                                status = NOT_A_DIRECTORY;
+                            else
+                                status = DOES_NOT_EXIST;
+                        } catch (Exception e) {
+                            Log.e(TAG, "Exception " + e);
+                            changePathRspNative(INTERNAL_ERROR ,
+                                    numberOfItems ,
+                                    getByteAddress(device));
+                        } finally {
+                            if (cursor != null) {
+                                cursor.close();
+                            }
+                        }
+                    }
+                    break;
+                default:
+                    status = INVALID_DIRECTION;
+                    break;
+            }
+        } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_PLAYLISTS)) {
+            switch(direction) {
+                case FOLDER_UP:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_ROOT;
+                        numberOfItems = NUM_ROOT_ELEMENTS;
+                    } else {
+                        deviceFeatures[deviceIndex].mCurrentPath = PATH_PLAYLISTS;
+                        deviceFeatures[deviceIndex].mCurrentPathUid = null;
+                        numberOfItems = getNumPlaylistItems();
+                    }
+                    break;
+                case FOLDER_DOWN:
+                    if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                        Cursor cursor = null;
+                        String[] playlistMemberCols = new String[] {
+                            MediaStore.Audio.Playlists.Members._ID,
+                            MediaStore.Audio.Media.TITLE,
+                            MediaStore.Audio.Media.DATA,
+                            MediaStore.Audio.Media.ALBUM,
+                            MediaStore.Audio.Media.ARTIST,
+                            MediaStore.Audio.Media.DURATION,
+                            MediaStore.Audio.Playlists.Members.PLAY_ORDER,
+                            MediaStore.Audio.Playlists.Members.AUDIO_ID,
+                            MediaStore.Audio.Media.IS_MUSIC
+                        };
+                        try {
+                            Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external",
+                                               folderUid);
+                            StringBuilder where = new StringBuilder();
+                            where.append(MediaStore.Audio.Media.TITLE + " != ''");
+                            cursor = mContext.getContentResolver().query(uri, playlistMemberCols,
+                                            where.toString(), null,
+                                            MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);
+                            if (cursor != null) {
+                                numberOfItems =  cursor.getCount();
+                                deviceFeatures[deviceIndex].mCurrentPathUid =
+                                        String.valueOf(folderUid);
+                                deviceFeatures[deviceIndex].mCurrentPath =
+                                        PATH_PLAYLISTS;
+                            } else {
+                                status = DOES_NOT_EXIST;
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG, "Exception " + e);
+                            changePathRspNative(INTERNAL_ERROR ,
+                                    numberOfItems ,
+                                    getByteAddress(device));
+                        } finally {
+                            if (cursor != null) {
+                                cursor.close();
+                            }
+                        }
+                    } else {
+                        numberOfItems = 0;
+                        status = DOES_NOT_EXIST;
+                    }
+                    break;
+                default:
+                    status = INVALID_DIRECTION;
+                    break;
+            }
+        } else {
+            Log.i(TAG, "Current Path not set");
+            status = DOES_NOT_EXIST;
+        }
+        Log.i(TAG, "Number of items " + numberOfItems + ", status: " + status);
+        changePathRspNative(status ,
+                numberOfItems ,
+                getByteAddress(device));
+    }
+
+    private long getNumPlaylistItems() {
+        Cursor cursor = null;
+        String[] cols = new String[] {
+                MediaStore.Audio.Playlists._ID,
+                MediaStore.Audio.Playlists.NAME
+        };
+        try {
+            cursor = mContext.getContentResolver().query(
+                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                cols, MediaStore.Audio.Playlists.NAME + " != ''", null,
+                MediaStore.Audio.Playlists.NAME);
+
+            if ((cursor == null) || (cursor.getCount() == 0)) {
+                return 0;
+            } else {
+                long count = cursor.getCount();
+                return count;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Exception " + e);
+            return 0;
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+    }
+
+    private long getNumItems(String path, String element, int deviceIndex) {
+        if (path == null || element == null)
+            return 0;
+        Cursor cursor = null;
+        try {
+            cursor = mContext.getContentResolver().query(
+                deviceFeatures[deviceIndex].mMediaUri,
+                new String[] {element},
+                MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                element);
+            if ((cursor == null) || (cursor.getCount() == 0)) {
+                return 0;
+            } else if (path.equals(PATH_TITLES)) {
+                long count = cursor.getCount();
+                return count;
+            } else if (path.equals(PATH_ALBUMS) || path.equals(PATH_ARTISTS)){
+                long elemCount = 0;
+                cursor.moveToFirst();
+                long count = cursor.getCount();
+                long prevElem = 0;
+                long curElem = 0;
+                while (count > 0) {
+                    curElem = cursor.getLong(cursor.getColumnIndexOrThrow(element));
+                    Log.i(TAG, "curElem "+ curElem + "preElem " + prevElem);
+                    if (curElem != prevElem) {
+                        elemCount++;
+                    }
+                    prevElem = curElem;
+                    cursor.moveToNext();
+                    count--;
+                }
+                Log.i(TAG, "element Count is "+ elemCount);
+                return elemCount;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Exception " + e);
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+        return 0;
+    }
+
+    private void playItem(byte scope, long uid, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "playItem: scope: " + scope + " uid:" + uid);
+        ItemAttr itemAttr = new ItemAttr(null, uid,
+                Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_PLAY_ITEM, scope, 0, itemAttr);
+        mHandler.sendMessage(msg);
+    }
+
+    private void processPlayItem(int scope, long uid,
+            String deviceAddress) {
+        if (DEBUG)
+            Log.v(TAG, "processPlayItem: scope: " + scope + " uid:" + uid);
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        mBrowserDevice = device;
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        if (uid < 0) {
+            if (DEBUG)
+                Log.v(TAG, "invalid uid");
+            playItemRspNative(DOES_NOT_EXIST ,
+                    getByteAddress(device));
+            return;
+        }
+        if (mMediaPlayers.size() > 0) {
+            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+            while (rccIterator.hasNext()) {
+                final MediaPlayerInfo di = rccIterator.next();
+                if (di.GetPlayerFocus()) {
+                    if (!di.IsRemoteAddressable()) {
+                        playItemRspNative(INTERNAL_ERROR ,
+                                getByteAddress(device));
+                        if (DEBUG)
+                            Log.v(TAG, "Play Item fails: Player not remote" +
+                                    "addressable");
+                        return;
+                    }
+                }
+            }
+        }
+        if (scope == SCOPE_VIRTUAL_FILE_SYS) {
+            if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ROOT)) {
+                playItemRspNative(UID_A_DIRECTORY ,
+                        getByteAddress(device));
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_TITLES)) {
+                Cursor cursor = null;
+                try {
+                    cursor = mContext.getContentResolver().query(
+                        deviceFeatures[deviceIndex].mMediaUri,
+                        new String[] {MediaStore.Audio.Media.TITLE},
+                        MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" + uid,
+                        null, null);
+                    if ((cursor == null) || (cursor.getCount() == 0)) {
+                        Log.i(TAG, "No such track");
+                        playItemRspNative(DOES_NOT_EXIST ,
+                                getByteAddress(device));
+                    } else {
+                        Log.i(TAG, "Play uid:" + uid);
+                        mRemoteController.setRemoteControlClientPlayItem(uid, scope);
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG, "Exception " + e);
+                    playItemRspNative(INTERNAL_ERROR ,
+                            getByteAddress(device));
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ALBUMS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    playItemRspNative(UID_A_DIRECTORY ,
+                            getByteAddress(device));
+                } else {
+                    Cursor cursor = null;
+                    try {
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            new String[] {MediaStore.Audio.Media.TITLE},
+                            MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" + uid + " AND " +
+                            MediaStore.Audio.Media.ALBUM_ID + "=" +
+                            deviceFeatures[deviceIndex].mCurrentPathUid,
+                            null, null);
+                        if ((cursor == null) || (cursor.getCount() == 0)) {
+                            Log.i(TAG, "No such track");
+                            playItemRspNative(DOES_NOT_EXIST ,
+                                    getByteAddress(device));
+                        } else {
+                            Log.i(TAG, "Play uid:" + uid);
+                            mRemoteController.setRemoteControlClientPlayItem(uid, scope);
+                        }
+                    } catch (Exception e) {
+                        Log.e(TAG, "Exception " + e);
+                        playItemRspNative(INTERNAL_ERROR ,
+                                getByteAddress(device));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ARTISTS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    playItemRspNative(UID_A_DIRECTORY ,
+                            getByteAddress(device));
+                } else {
+                    Cursor cursor = null;
+                    try {
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            new String[] {MediaStore.Audio.Media.TITLE},
+                            MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" + uid + " AND " +
+                            MediaStore.Audio.Media.ARTIST_ID + "=" +
+                            deviceFeatures[deviceIndex].mCurrentPathUid,
+                            null, null);
+                        if ((cursor == null) || (cursor.getCount() == 0)) {
+                            Log.i(TAG, "No such track");
+                            playItemRspNative(DOES_NOT_EXIST ,
+                                    getByteAddress(device));
+                        } else {
+                            Log.i(TAG, "Play uid:" + uid);
+                            mRemoteController.setRemoteControlClientPlayItem(uid, scope);
+                        }
+                    } catch (Exception e) {
+                        Log.e(TAG, "Exception " + e);
+                        playItemRspNative(INTERNAL_ERROR ,
+                                getByteAddress(device));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_PLAYLISTS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    playItemRspNative(UID_A_DIRECTORY ,
+                            getByteAddress(device));
+                } else {
+                    Cursor cursor = null;
+                    try {
+                        String[] playlistMemberCols = new String[] {
+                                MediaStore.Audio.Playlists.Members._ID,
+                                MediaStore.Audio.Media.TITLE,
+                                MediaStore.Audio.Media.DATA,
+                                MediaStore.Audio.Media.ALBUM,
+                                MediaStore.Audio.Media.ARTIST,
+                                MediaStore.Audio.Media.DURATION,
+                                MediaStore.Audio.Playlists.Members.PLAY_ORDER,
+                                MediaStore.Audio.Playlists.Members.AUDIO_ID,
+                                MediaStore.Audio.Media.IS_MUSIC
+                        };
+                        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external",
+                                Long.parseLong(deviceFeatures[deviceIndex].mCurrentPathUid));
+                        StringBuilder where = new StringBuilder();
+                        where.append(MediaStore.Audio.Playlists.Members.AUDIO_ID + "=" + uid);
+                        cursor = mContext.getContentResolver().query(uri, playlistMemberCols,
+                                    where.toString(), null, MediaStore.Audio.Playlists.Members.
+                                                                            DEFAULT_SORT_ORDER);
+
+                        if ((cursor == null) || (cursor.getCount() == 0)) {
+                            Log.i(TAG, "No such track");
+                            playItemRspNative(DOES_NOT_EXIST ,
+                                    getByteAddress(device));
+                        } else {
+                            Log.i(TAG, "Play uid:" + uid);
+                            mRemoteController.setRemoteControlClientPlayItem(uid, scope);
+                        }
+                    } catch (Exception e) {
+                        Log.e(TAG, "Exception " + e);
+                        playItemRspNative(INTERNAL_ERROR ,
+                                getByteAddress(device));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else {
+                playItemRspNative(DOES_NOT_EXIST ,
+                        getByteAddress(device));
+
+            }
+        } else if (scope == SCOPE_NOW_PLAYING) {
+            mRemoteController.setRemoteControlClientPlayItem(uid, scope);
+        } else {
+            playItemRspNative(DOES_NOT_EXIST ,
+                    getByteAddress(device));
+            Log.v(TAG, "Play Item fails: Invalid scope");
+        }
+    }
+
+    private void getItemAttr(byte scope, long uid, byte numAttr, int[] attrs, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "getItemAttr: scope: " + scope + " uid:" + uid +
+                    " numAttr:" + numAttr);
+        int i;
+        ArrayList<Integer> attrList = new ArrayList<Integer>();
+        for (i = 0; i < numAttr; ++i) {
+            attrList.add(attrs[i]);
+            if (DEBUG)
+                Log.v(TAG, "attrs[" + i + "] = " + attrs[i]);
+        }
+        ItemAttr itemAttr = new ItemAttr(attrList, uid,
+                Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_GET_ITEM_ATTRS, (int)numAttr,
+                                                                (int)scope, itemAttr);
+        mHandler.sendMessage(msg);
+    }
+
+    private String[] mCursorCols = new String[] {
+                    "audio._id AS _id",
+                    MediaStore.Audio.Media.ARTIST,
+                    MediaStore.Audio.Media.ALBUM,
+                    MediaStore.Audio.Media.TITLE,
+                    MediaStore.Audio.Media.DURATION,
+                    MediaStore.Audio.Media.DATA,
+                    MediaStore.Audio.Media.MIME_TYPE,
+                    MediaStore.Audio.Media.ALBUM_ID,
+                    MediaStore.Audio.Media.ARTIST_ID,
+                    MediaStore.Audio.Media.IS_PODCAST,
+                    MediaStore.Audio.Media.BOOKMARK
+    };
+
+    private void processGetItemAttr(byte scope, long uid, byte numAttr, int[] attrs,
+                String deviceAddress) {
+        if (DEBUG)
+            Log.v(TAG, "processGetItemAttr: scope: " + scope + " uid:" + uid +
+                    " numAttr:" + numAttr);
+        String[] textArray;
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        textArray = new String[numAttr];
+        if ((scope == SCOPE_VIRTUAL_FILE_SYS) || (scope == SCOPE_NOW_PLAYING)) {
+            Cursor cursor = null;
+            try {
+                if ((deviceFeatures[deviceIndex].mMediaUri == Uri.EMPTY) ||
+                        (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_INVALID))) {
+                    if (DEBUG)
+                        Log.v(TAG, "Browsed player not set, getItemAttr can not be processed");
+                    getItemAttrRspNative((byte)0 ,attrs ,
+                            textArray ,getByteAddress(device));
+                    return;
+                }
+                cursor = mContext.getContentResolver().query(
+                     deviceFeatures[deviceIndex].mMediaUri, mCursorCols,
+                     MediaStore.Audio.Media.IS_MUSIC + "=1 AND _id=" + uid, null, null);
+                if ((cursor == null) || (cursor.getCount() == 0)) {
+                    Log.i(TAG, "Invalid track UID");
+                    Log.i(TAG, "cursor is " + cursor);
+                    if (cursor != null)
+                        Log.i(TAG, "cursor.getCount() " + cursor.getCount());
+                    getItemAttrRspNative((byte)0 ,attrs ,
+                            textArray ,getByteAddress(device));
+                } else {
+                    int validAttrib = 0;
+                    cursor.moveToFirst();
+                    for (int i = 0; i < numAttr; ++i) {
+                        if ((attrs[i] <= MEDIA_ATTR_MAX) && (attrs[i] >= MEDIA_ATTR_MIN)) {
+                            textArray[i] = getAttributeStringFromCursor(
+                                    cursor, attrs[i], deviceIndex);
+                            validAttrib ++;
+                        }
+                    }
+                    getItemAttrRspNative(numAttr ,attrs ,
+                            textArray ,getByteAddress(device));
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "Exception " + e);
+                getItemAttrRspNative((byte)0 ,attrs ,
+                        textArray ,getByteAddress(device));
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        } else {
+            Log.i(TAG, "Invalid scope");
+            getItemAttrRspNative((byte)0 ,attrs ,
+                    textArray ,getByteAddress(device));
+        }
+    }
+
+    private class ItemAttr {
+        ArrayList<Integer> mAttrList;
+        long mUid;
+        String mAddress;
+        public ItemAttr (ArrayList<Integer> attrList, long uid,
+                String deviceAddress) {
+            mAttrList = attrList;
+            mUid = uid;
+            mAddress = deviceAddress;
+        }
+    }
+
+    private void setAddressedPlayer(int playerId, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "setAddressedPlayer: PlayerID: " + playerId);
+        Message msg = mHandler.obtainMessage(MESSAGE_SET_ADDR_PLAYER, playerId, 0,
+                Utils.getAddressStringFromByte(address));
+        mHandler.sendMessage(msg);
+    }
+
+    private void processSetAddressedPlayer(int playerId, String deviceAddress) {
+        if (DEBUG)
+            Log.v(TAG, "processSetAddressedPlayer: PlayerID: " + playerId);
+        String packageName = null;
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        if (deviceFeatures[deviceIndex].mRequestedAddressedPlayerPackageName !=
+                null) {
+            if (DEBUG)
+                Log.v(TAG, "setAddressedPlayer: Request in progress, Reject this Request");
+            setAdressedPlayerRspNative((byte)PLAYER_NOT_ADDRESSED,
+                        getByteAddress(mAdapter.getRemoteDevice(deviceAddress)));
+            return;
+        }
+        if (mMediaPlayers.size() > 0) {
+            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+            while (rccIterator.hasNext()) {
+                final MediaPlayerInfo di = rccIterator.next();
+                if (di.RetrievePlayerId() == playerId) {
+                    packageName = di.RetrievePlayerPackageName();
+                }
+            }
+        }
+        if(packageName != null) {
+            if (playerId == mAddressedPlayerId) {
+                if (DEBUG)
+                    Log.v(TAG, "setAddressedPlayer: Already addressed, sending success");
+                setAdressedPlayerRspNative((byte)OPERATION_SUCCESSFUL,
+                            getByteAddress(mAdapter.getRemoteDevice(deviceAddress)));
+                return;
+            }
+            String newPackageName = packageName.replace("com.android", "org.codeaurora");
+            Intent mediaIntent = new Intent(newPackageName + ".setaddressedplayer");
+            mediaIntent.setPackage(packageName);
+            // This needs to be caught in respective media players
+            mContext.sendBroadcast(mediaIntent);
+            if (DEBUG)
+                Log.v(TAG, "Intent Broadcasted: " + newPackageName +
+                    ".setaddressedplayer");
+            deviceFeatures[deviceIndex].mRequestedAddressedPlayerPackageName = packageName;
+            deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+            Message msg = mHandler.obtainMessage(MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT,
+                    0, 0, deviceAddress);
+            mHandler.sendMessageDelayed(msg, AVRCP_BR_RSP_TIMEOUT);
+            Log.v(TAG, "Post MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT");
+        } else {
+            if (DEBUG)
+                Log.v(TAG, "setAddressedPlayer fails: No such media player available");
+            setAdressedPlayerRspNative((byte)INVALID_PLAYER_ID,
+                        getByteAddress(mAdapter.getRemoteDevice(deviceAddress)));
+        }
+    }
+
+    private void getFolderItems(byte scope, long start, long end, int attrCnt,
+            int numAttr, int[] attrs, byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "getFolderItems");
+        if (DEBUG)
+            Log.v(TAG, "scope: " + scope + " attrCnt: " + attrCnt);
+        if (DEBUG)
+            Log.v(TAG, "start: " + start + " end: " + end);
+        for (int i = 0; i < numAttr; ++i) {
+            if (DEBUG)
+                Log.v(TAG, "attrs[" + i + "] = " + attrs[i]);
+        }
+
+        FolderListEntries folderListEntries = new FolderListEntries (scope, start, end, attrCnt,
+                numAttr, attrs, Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_GET_FOLDER_ITEMS, 0, 0, folderListEntries);
+        mHandler.sendMessage(msg);
+    }
+
+    private void processGetFolderItems(byte scope, long start, long end, int size,
+            int numAttr, int[] attrs, String deviceAddress) {
+        if (DEBUG)
+            Log.v(TAG, "processGetFolderItems");
+        if (DEBUG)
+            Log.v(TAG, "scope: " + scope + " size: " + size);
+        if (DEBUG)
+            Log.v(TAG, "start: " + start + " end: " + end + " numAttr: " + numAttr);
+        if (scope == SCOPE_PLAYER_LIST) { // populate mediaplayer item list here
+            processGetMediaPlayerItems(scope, start, end, size, numAttr, attrs,
+                    deviceAddress);
+        } else if ((scope == SCOPE_VIRTUAL_FILE_SYS) || (scope == SCOPE_NOW_PLAYING)) {
+            for (int i = 0; i < numAttr; ++i) {
+                if (DEBUG)
+                    Log.v(TAG, "attrs[" + i + "] = " + attrs[i]);
+            }
+            processGetFolderItemsInternal(scope, start, end, size, (byte)numAttr,
+                    attrs, deviceAddress);
+        }
+    }
+
+    private void processGetMediaPlayerItems(byte scope, long start, long end, int size,
+            int numAttr, int[] attrs, String deviceAddress) {
+        byte[] folderItems = new byte[size];
+        int[] folderItemLengths = new int[32];
+        int availableMediaPlayers = 0;
+        int count = 0;
+        int positionItemStart = 0;
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        if (mMediaPlayers.size() > 0) {
+            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+            while (rccIterator.hasNext()) {
+                final MediaPlayerInfo di = rccIterator.next();
+                if (di.GetPlayerAvailablility()) {
+                    if (start == 0) {
+                        byte[] playerEntry = di.RetrievePlayerItemEntry();
+                        int length = di.RetrievePlayerEntryLength();
+                        folderItemLengths[availableMediaPlayers ++] = length;
+                        for (count = 0; count < length; count ++) {
+                            folderItems[positionItemStart + count] = playerEntry[count];
+                        }
+                        positionItemStart += length; // move start to next item start
+                    } else if (start > 0) {
+                        --start;
+                    }
+                }
+            }
+        }
+        if (DEBUG)
+            Log.v(TAG, "Number of available MediaPlayers = " +
+                    availableMediaPlayers);
+        getMediaPlayerListRspNative((byte)OPERATION_SUCCESSFUL, 0x1357,
+                availableMediaPlayers, folderItems,
+                folderItemLengths, getByteAddress(device));
+    }
+
+    private boolean isCurrentPathValid (int deviceIndex) {
+        if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ROOT) ||
+            deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_TITLES) ||
+            deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ALBUMS) ||
+            deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ARTISTS) ||
+            deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_PLAYLISTS)) {
+            return true;
+        }
+        return false;
+    }
+
+    private void processGetFolderItemsInternal(byte scope, long start, long end, int size,
+            byte numAttr, int[] attrs, String deviceAddress) {
+        int status = OPERATION_SUCCESSFUL;
+        long numItems = 0;
+        long reqItems = (end - start) + 1;
+        int[] itemType = new int[MAX_BROWSE_ITEM_TO_SEND];
+        long[] uid = new long[MAX_BROWSE_ITEM_TO_SEND];
+        int[] type = new int[MAX_BROWSE_ITEM_TO_SEND];
+        byte[] playable = new byte[MAX_BROWSE_ITEM_TO_SEND];
+        String[] displayName = new String[MAX_BROWSE_ITEM_TO_SEND];
+        byte[] numAtt = new byte[MAX_BROWSE_ITEM_TO_SEND];
+        String[] attValues = new String[MAX_BROWSE_ITEM_TO_SEND * 7];
+        int[] attIds = new int[MAX_BROWSE_ITEM_TO_SEND * 7];
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        mBrowserDevice = device;
+
+        int deviceIndex = getIndexForDevice(device);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
+        if (DEBUG)
+            Log.v(TAG, "processGetFolderItemsInternal");
+        if (DEBUG)
+            Log.v(TAG, "requested attribute count" + numAttr);
+        for (int count = 0; count < numAttr; count++) {
+            if (DEBUG)
+                Log.v(TAG, "attr[" + count + "] = " + attrs[count]);
+        }
+
+        if (scope == SCOPE_VIRTUAL_FILE_SYS) {
+            // Item specific attribute's entry starts from index*7
+            for (int count = 0; count < (MAX_BROWSE_ITEM_TO_SEND * 7); count++) {
+                attValues[count] = "";
+                attIds[count] = 0;
+            }
+
+            if (DEBUG)
+                Log.v(TAG, "mCurrentPath: " +
+                    deviceFeatures[deviceIndex].mCurrentPath);
+            if (DEBUG)
+                Log.v(TAG, "mCurrentPathUID: " +
+                    deviceFeatures[deviceIndex].mCurrentPathUid);
+            if (!isCurrentPathValid(deviceIndex)) {
+                getFolderItemsRspNative((byte)DOES_NOT_EXIST ,
+                        numItems, itemType, uid, type,
+                        playable, displayName, numAtt, attValues, attIds,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                Log.v(TAG, "Current path not set");
+                return;
+            }
+
+            if ((start < 0) || (end < 0) || (start > end)) {
+                getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                        numItems, itemType, uid, type,
+                        playable, displayName, numAtt, attValues, attIds,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                Log.e(TAG, "Wrong start/end index");
+                return;
+            }
+
+            if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ROOT)) {
+                long availableItems = NUM_ROOT_ELEMENTS;
+                if (start >= availableItems) {
+                    Log.i(TAG, "startIteam exceeds the available item index");
+                    getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                            numItems, itemType, uid, type,
+                            playable, displayName, numAtt, attValues, attIds,
+                            getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    return;
+                }
+                if (DEBUG)
+                    Log.v(TAG, "availableItems: " + availableItems);
+                if (DEBUG)
+                    Log.v(TAG, "reqItems: " + reqItems);
+                availableItems = availableItems - start;
+                if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                    availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                if (reqItems > availableItems)
+                    reqItems = availableItems;
+                if (DEBUG)
+                    Log.v(TAG, "revised reqItems: " + reqItems);
+
+                numItems = reqItems;
+
+                for (int count = 0; count < reqItems; count ++) {
+                    long index = start + count;
+                    switch ((int)index) {
+                        case ALBUMS_ITEM_INDEX:
+                            itemType[count] = TYPE_FOLDER_ITEM;
+                            uid[count] = UID_ALBUM;
+                            type[count] = FOLDER_TYPE_ALBUMS;
+                            playable[count] = 0;
+                            displayName[count] = PATH_ALBUMS;
+                            numAtt[count] = 0;
+                            break;
+                        case ARTISTS_ITEM_INDEX:
+                            itemType[count] = TYPE_FOLDER_ITEM;
+                            uid[count] = UID_ARTIST;
+                            type[count] = FOLDER_TYPE_ARTISTS;
+                            playable[count] = 0;
+                            displayName[count] = PATH_ARTISTS;
+                            numAtt[count] = 0;
+                            break;
+                        case PLAYLISTS_ITEM_INDEX:
+                            itemType[count] = TYPE_FOLDER_ITEM;
+                            uid[count] = UID_PLAYLIST;
+                            type[count] = FOLDER_TYPE_PLAYLISTS;
+                            playable[count] = 0;
+                            displayName[count] = PATH_PLAYLISTS;
+                            numAtt[count] = 0;
+                            break;
+                        case TITLES_ITEM_INDEX:
+                            itemType[count] = TYPE_FOLDER_ITEM;
+                            uid[count] = UID_TITLES;
+                            type[count] = FOLDER_TYPE_TITLES;
+                            playable[count] = 0;
+                            displayName[count] = PATH_TITLES;
+                            numAtt[count] = 0;
+                            break;
+                        default:
+                            Log.i(TAG, "wrong index");
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    }
+                }
+
+                for (int count = 0; count < numItems; count++) {
+                    Log.v(TAG, itemType[count] + "," + uid[count] + "," + type[count]);
+                }
+                getFolderItemsRspNative((byte)status ,
+                        numItems, itemType, uid, type,
+                        playable, displayName, numAtt, attValues, attIds,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_TITLES)) {
+                long availableItems = 0;
+                Cursor cursor = null;
+                try {
+                    cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            mCursorCols, MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                            MediaStore.Audio.Media.DEFAULT_SORT_ORDER);
+                    if (cursor != null) {
+                        availableItems = cursor.getCount();
+                        if (start >= availableItems) {
+                            Log.i(TAG, "startIteam exceeds the available item index");
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        cursor.moveToFirst();
+                        for (int i = 0; i < start; i++) {
+                            cursor.moveToNext();
+                        }
+                    } else {
+                        Log.i(TAG, "Error: could not fetch the elements");
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        return;
+                    }
+                    if (DEBUG)
+                        Log.v(TAG, "availableItems: " + availableItems);
+                    if (DEBUG)
+                        Log.v(TAG, "reqItems: " + reqItems);
+                    availableItems = availableItems - start;
+                    if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                        availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                    if (reqItems > availableItems)
+                        reqItems = availableItems;
+                    if (DEBUG)
+                        Log.v(TAG, "revised reqItems: " + reqItems);
+                    int attIndex;
+                    int index;
+                    for (index = 0; index < reqItems; index++) {
+                        itemType[index] = TYPE_MEDIA_ELEMENT_ITEM;
+                        uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow("_id"));
+                        type[index] = MEDIA_TYPE_AUDIO;
+                        playable[index] = 0;
+                        displayName[index] =
+                            cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.
+                                                                    Audio.Media.TITLE));
+                        int validAttrib = 0;
+                        for (attIndex = 0; attIndex < numAttr; attIndex++) {
+                            if ((attrs[attIndex] <= MEDIA_ATTR_MAX) &&
+                                        (attrs[attIndex] >= MEDIA_ATTR_MIN)) {
+                                attValues[(7 * index) + attIndex] =
+                                        getAttributeStringFromCursor(
+                                        cursor, attrs[attIndex], deviceIndex);
+                                attIds[(7 * index) + attIndex] = attrs[attIndex];
+                                validAttrib ++;
+                            }
+                        }
+                        numAtt[index] = (byte)validAttrib;
+                        cursor.moveToNext();
+                    }
+                    numItems = index;
+                    getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                            numItems, itemType, uid, type,
+                            playable, displayName, numAtt, attValues, attIds,
+                            getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                } catch(Exception e) {
+                    Log.i(TAG, "Exception e" + e);
+                    getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                            numItems, itemType, uid, type,
+                            playable, displayName, numAtt, attValues, attIds,
+                            getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ALBUMS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    long availableItems = 0;
+                    Cursor cursor = null;
+                    try {
+                        availableItems = getNumItems(PATH_ALBUMS,
+                                MediaStore.Audio.Media.ALBUM_ID, deviceIndex);
+                        if (start >= availableItems) {
+                            Log.i(TAG, "startIteam exceeds the available item index");
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = (int)availableItems;
+                        Log.i(TAG, "revised reqItems: " + reqItems);
+
+                        cursor = mContext.getContentResolver().query(
+                                            deviceFeatures[deviceIndex].mMediaUri, mCursorCols,
+                                            MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                                            MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
+
+                        int count = 0;
+                        if (cursor != null) {
+                            count = cursor.getCount();
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        if (count < reqItems) {
+                            reqItems = count;
+                        }
+                        cursor.moveToFirst();
+                        int index = 0;
+                        long prevElem = -1;
+                        long curElem = -1;
+                        while ((reqItems > 0) && (count > 0)) {
+                            curElem = cursor.getLong(cursor.getColumnIndexOrThrow(
+                                                    MediaStore.Audio.Media.ALBUM_ID));
+                            if (curElem != prevElem) {
+                                if (start > 0) {
+                                    --start;
+                                } else {
+                                    itemType[index] = TYPE_FOLDER_ITEM;
+                                    uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow(
+                                                        MediaStore.Audio.Media.ALBUM_ID));
+                                    type[index] = FOLDER_TYPE_ALBUMS;
+                                    playable[index] = 0;
+                                    displayName[index] = cursor.getString(
+                                                cursor.getColumnIndexOrThrow(
+                                                MediaStore.Audio.Media.ALBUM));
+                                    numAtt[index] = 0;
+                                    index++;
+                                    reqItems--;
+                                }
+                            }
+                            prevElem = curElem;
+                            cursor.moveToNext();
+                            count--;
+                        }
+                        if (index > 0) {
+                            numItems = index;
+                            getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        } else {
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        }
+                    } catch(Exception e) {
+                        Log.i(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                } else {
+                    long folderUid = Long.valueOf(deviceFeatures[deviceIndex].mCurrentPathUid);
+                    long availableItems = 0;
+                    Cursor cursor = null;
+                    try {
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            mCursorCols, MediaStore.Audio.Media.IS_MUSIC + "=1 AND " +
+                            MediaStore.Audio.Media.ALBUM_ID + "=" + folderUid, null,
+                                            MediaStore.Audio.Albums.DEFAULT_SORT_ORDER);
+
+                        if (cursor != null) {
+                            availableItems = cursor.getCount();
+                            if (start >= availableItems) {
+                                Log.i(TAG, "startIteam exceeds the available item index");
+                                getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                        numItems, itemType, uid, type,
+                                        playable, displayName, numAtt, attValues, attIds,
+                                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                                return;
+                            }
+                            cursor.moveToFirst();
+                            for (int i = 0; i < start; i++) {
+                                cursor.moveToNext();
+                            }
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = availableItems;
+                        if (DEBUG)
+                            Log.v(TAG, "revised reqItems: " + reqItems);
+
+                        int attIndex;
+                        int index;
+                        for (index = 0; index < reqItems; index++) {
+                            itemType[index] = TYPE_MEDIA_ELEMENT_ITEM;
+                            uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow("_id"));
+                            type[index] = MEDIA_TYPE_AUDIO;
+                            playable[index] = 0;
+                            displayName[index] =
+                                cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.
+                                                                        Audio.Media.TITLE));                            
+                            int validAttrib = 0;
+                            for (attIndex = 0; attIndex < numAttr; attIndex++) {
+                                if ((attrs[attIndex] <= MEDIA_ATTR_MAX) &&
+                                            (attrs[attIndex] >= MEDIA_ATTR_MIN)) {
+                                    attValues[(7 * index) + attIndex] =
+                                            getAttributeStringFromCursor(
+                                            cursor, attrs[attIndex], deviceIndex);
+                                    attIds[(7 * index) + attIndex] = attrs[attIndex];
+                                    validAttrib ++;
+                                }
+                            }
+                            numAtt[index] = (byte)validAttrib;
+                            cursor.moveToNext();
+                        }
+                        numItems = index;
+                        getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } catch(Exception e) {
+                        Log.i(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_ARTISTS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    long availableItems = 0;
+                    Cursor cursor = null;
+                    try {
+                        availableItems = getNumItems(PATH_ARTISTS,
+                                    MediaStore.Audio.Media.ARTIST_ID, deviceIndex);
+                        if (start >= availableItems) {
+                            Log.i(TAG, "startIteam exceeds the available item index");
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = (int)availableItems;
+                        if (DEBUG)
+                            Log.v(TAG, "revised reqItems: " + reqItems);
+
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri, mCursorCols,
+                            MediaStore.Audio.Media.IS_MUSIC + "=1", null,
+                            MediaStore.Audio.Artists.DEFAULT_SORT_ORDER);
+
+                        int count = 0;
+                        if (cursor != null) {
+                            count = cursor.getCount();
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        if (count < reqItems) {
+                            reqItems = count;
+                        }
+                        cursor.moveToFirst();
+                        int index = 0;
+                        long prevElem = -1;
+                        long curElem = -1;
+                        while ((reqItems > 0) && (count > 0)) {
+                            curElem = cursor.getLong(cursor.getColumnIndexOrThrow(
+                                                    MediaStore.Audio.Media.ARTIST_ID));
+                            if (curElem != prevElem) {
+                                if (start > 0) {
+                                    --start;
+                                } else {
+                                    itemType[index] = TYPE_FOLDER_ITEM;
+                                    uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow(
+                                                        MediaStore.Audio.Media.ARTIST_ID));
+                                    type[index] = FOLDER_TYPE_ARTISTS;
+                                    playable[index] = 0;
+                                    displayName[index] = cursor.getString(
+                                        cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.ARTIST));
+                                    numAtt[index] = 0;
+                                    index++;
+                                    reqItems--;
+                                }
+                            }
+                            prevElem = curElem;
+                            cursor.moveToNext();
+                            count--;
+                        }
+                        if (index > 0) {
+                            numItems = index;
+                            getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        } else {
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        }
+                    } catch(Exception e) {
+                        Log.i(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                } else {
+                    long folderUid = Long.valueOf(deviceFeatures[deviceIndex].mCurrentPathUid);
+                    long availableItems = 0;
+                    Cursor cursor = null;
+                    try {
+                        cursor = mContext.getContentResolver().query(
+                            deviceFeatures[deviceIndex].mMediaUri,
+                            mCursorCols, MediaStore.Audio.Media.IS_MUSIC + "=1 AND " +
+                            MediaStore.Audio.Media.ARTIST_ID + "=" + folderUid, null,
+                            MediaStore.Audio.Artists.DEFAULT_SORT_ORDER);
+
+                        if (cursor != null) {
+                            availableItems = cursor.getCount();
+                            if (start >= availableItems) {
+                                Log.i(TAG, "startIteam exceeds the available item index");
+                                getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                        numItems, itemType, uid, type,
+                                        playable, displayName, numAtt, attValues, attIds,
+                                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                                return;
+                            }
+                            cursor.moveToFirst();
+                            for (int i = 0; i < start; i++) {
+                                cursor.moveToNext();
+                            }
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = availableItems;
+                        if (DEBUG)
+                            Log.v(TAG, "revised reqItems: " + reqItems);
+
+                        int attIndex;
+                        int index;
+                        for (index = 0; index < reqItems; index++) {
+                            itemType[index] = TYPE_MEDIA_ELEMENT_ITEM;
+                            uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow("_id"));
+                            type[index] = MEDIA_TYPE_AUDIO;
+                            playable[index] = 0;
+                            displayName[index] =
+                                cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.
+                                                                        Audio.Media.TITLE));
+                            int validAttrib = 0;
+                            for (attIndex = 0; attIndex < numAttr; attIndex++) {
+                                if ((attrs[attIndex] <= MEDIA_ATTR_MAX) &&
+                                            (attrs[attIndex] >= MEDIA_ATTR_MIN)) {
+                                    attValues[(7 * index) + attIndex] =
+                                                getAttributeStringFromCursor(
+                                                cursor, attrs[attIndex], deviceIndex);
+                                    attIds[(7 * index) + attIndex] = attrs[attIndex];
+                                    validAttrib ++;
+                                }
+                            }
+                            numAtt[index] = (byte)validAttrib;
+                            cursor.moveToNext();
+                        }
+                        numItems = index;
+                        getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } catch(Exception e) {
+                        Log.i(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_PLAYLISTS)) {
+                if (deviceFeatures[deviceIndex].mCurrentPathUid == null) {
+                    long availableItems = 0;
+                    Cursor cursor = null;
+                    try {
+                        availableItems = getNumPlaylistItems();
+                        if (start >= availableItems) {
+                            Log.i(TAG, "startIteam exceeds the available item index");
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = (int)availableItems;
+                        if (DEBUG)
+                            Log.v(TAG, "revised reqItems: " + reqItems);
+
+                        String[] cols = new String[] {
+                                MediaStore.Audio.Playlists._ID,
+                                MediaStore.Audio.Playlists.NAME
+                        };
+
+                        cursor = mContext.getContentResolver().query(
+                            MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI,
+                            cols, MediaStore.Audio.Playlists.NAME + " != ''", null,
+                            MediaStore.Audio.Playlists.DEFAULT_SORT_ORDER);
+
+                        int count = 0;
+                        if (cursor != null) {
+                            count = cursor.getCount();
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+                        if (count < reqItems) {
+                            reqItems = count;
+                        }
+                        cursor.moveToFirst();
+                        for (int i = 0; i < start; i++) {
+                            cursor.moveToNext();
+                        }
+                        int index = 0;
+                        for (index = 0; index < reqItems; index++) {
+                            itemType[index] = TYPE_FOLDER_ITEM;
+                            uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow(
+                                                        MediaStore.Audio.Playlists._ID));
+                            type[index] = FOLDER_TYPE_PLAYLISTS;
+                            playable[index] = 0;
+                            displayName[index] =
+                                cursor.getString(cursor.getColumnIndexOrThrow(
+                                                MediaStore.Audio.Playlists.NAME));
+                            cursor.moveToNext();
+                        }
+                        numItems = index;
+
+                        if (index > 0) {
+                            numItems = index;
+                            getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        } else {
+                            getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                        }
+                    } catch(Exception e) {
+                        Log.i(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                } else {
+                    long folderUid = Long.valueOf(deviceFeatures[deviceIndex].mCurrentPathUid);
+                    long availableItems = 0;
+                    Cursor cursor = null;
+
+                    String[] playlistMemberCols = new String[] {
+                            MediaStore.Audio.Playlists.Members._ID,
+                            MediaStore.Audio.Media.TITLE,
+                            MediaStore.Audio.Media.DATA,
+                            MediaStore.Audio.Media.ALBUM,
+                            MediaStore.Audio.Media.ARTIST,
+                            MediaStore.Audio.Media.DURATION,
+                            MediaStore.Audio.Playlists.Members.PLAY_ORDER,
+                            MediaStore.Audio.Playlists.Members.AUDIO_ID,
+                            MediaStore.Audio.Media.IS_MUSIC
+                    };
+
+                    try {
+                        Uri uri = MediaStore.Audio.Playlists.Members.getContentUri("external",
+                                                                                    folderUid);
+                        StringBuilder where = new StringBuilder();
+                        where.append(MediaStore.Audio.Media.TITLE + " != ''");
+                        cursor = mContext.getContentResolver().query(uri, playlistMemberCols,
+                                        where.toString(), null,
+                                        MediaStore.Audio.Playlists.Members.DEFAULT_SORT_ORDER);
+
+                        if (cursor != null) {
+                            availableItems = cursor.getCount();
+                            if (start >= availableItems) {
+                                Log.i(TAG, "startIteam exceeds the available item index");
+                                getFolderItemsRspNative((byte)RANGE_OUT_OF_BOUNDS ,
+                                        numItems, itemType, uid, type,
+                                        playable, displayName, numAtt, attValues, attIds,
+                                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                                return;
+                            }
+                            cursor.moveToFirst();
+                            for (int i = 0; i < start; i++) {
+                                cursor.moveToNext();
+                            }
+                        } else {
+                            Log.i(TAG, "Error: could not fetch the elements");
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            return;
+                        }
+
+                        if (DEBUG)
+                            Log.v(TAG, "availableItems: " + availableItems);
+                        if (DEBUG)
+                            Log.v(TAG, "reqItems: " + reqItems);
+                        availableItems = availableItems - start;
+                        if (availableItems > MAX_BROWSE_ITEM_TO_SEND)
+                            availableItems = MAX_BROWSE_ITEM_TO_SEND;
+                        if (reqItems > availableItems)
+                            reqItems = availableItems;
+                        if (DEBUG)
+                            Log.v(TAG, "revised reqItems: " + reqItems);
+
+                        int attIndex;
+                        int index;
+                        for (index = 0; index < reqItems; index++) {
+                            itemType[index] = TYPE_MEDIA_ELEMENT_ITEM;
+                            uid[index] = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.
+                                                                Audio.Playlists.Members.AUDIO_ID));
+                            type[index] = MEDIA_TYPE_AUDIO;
+                            playable[index] = 0;
+                            displayName[index] =
+                                cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.
+                                                                        Audio.Media.TITLE));
+                            int validAttrib = 0;
+                            for (attIndex = 0; attIndex < numAttr; attIndex++) {
+                                if ((attrs[attIndex] <= MEDIA_ATTR_MAX) &&
+                                            (attrs[attIndex] >= MEDIA_ATTR_MIN)) {
+                                    attValues[(7 * index) + attIndex] =
+                                            getAttributeStringFromCursor(
+                                            cursor, attrs[attIndex], deviceIndex);
+                                    attIds[(7 * index) + attIndex] = attrs[attIndex];
+                                    validAttrib ++;
+                                }
+                            }
+                            numAtt[index] = (byte)validAttrib;
+                            cursor.moveToNext();
+                        }
+                        numItems = index;
+                        getFolderItemsRspNative((byte)OPERATION_SUCCESSFUL ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } catch(Exception e) {
+                        Log.e(TAG, "Exception e" + e);
+                        getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                numItems, itemType, uid, type,
+                                playable, displayName, numAtt, attValues, attIds,
+                                getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                    } finally {
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                }
+            } else {
+                getFolderItemsRspNative((byte)DOES_NOT_EXIST ,
+                        numItems, itemType, uid, type,
+                        playable, displayName, numAtt, attValues, attIds,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                Log.v(TAG, "GetFolderItems fail as player is not browsable");
+            }
+        } else if (scope == SCOPE_NOW_PLAYING) {
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo di = rccIterator.next();
+                    if (di.GetPlayerFocus()) {
+                        if (!di.IsRemoteAddressable() ||
+                             deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_INVALID)) {
+                            getFolderItemsRspNative((byte)INTERNAL_ERROR ,
+                                    numItems, itemType, uid, type,
+                                    playable, displayName, numAtt, attValues, attIds,
+                                    getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                            Log.e(TAG, "GetFolderItems fails: addressed player is not browsable");
+                            return;
+                        }
+                    }
+                }
+            }
+            mRemoteController.getRemoteControlClientNowPlayingEntries();
+            mCachedRequest = new CachedRequest(start, end, numAttr, attrs);
+        }
+    }
+
+    private void registerNotification(int eventId, int param, byte[] address) {
+        Message msg = mHandler.obtainMessage(MESSAGE_REGISTER_NOTIFICATION, eventId,
+                param, Utils.getAddressStringFromByte(address));
+        mHandler.sendMessage(msg);
+    }
+
+    private void processRCCStateChange(String callingPackageName, int isFocussed, int isAvailable) {
+        Log.v(TAG, "processRCCStateChange: " + callingPackageName);
+        boolean available = false;
+        boolean focussed = false;
+        boolean isResetFocusRequired = false;
+        BluetoothDevice device = null;
+        if (isFocussed == 1)
+            focussed = true;
+        if (isAvailable == 1)
+            available = true;
+
+        if (focussed) {
+            isResetFocusRequired = true;
+            for (int i = 0; i < maxAvrcpConnections; i++) {
+                if (deviceFeatures[i].mRequestedAddressedPlayerPackageName != null) {
+                    if (callingPackageName.equals(
+                            deviceFeatures[i].mRequestedAddressedPlayerPackageName)) {
+                        mHandler.removeMessages(MESSAGE_SET_ADDR_PLAYER_REQ_TIMEOUT);
+                        if (deviceFeatures[i].isMusicAppResponsePending ==
+                                true) {
+                            device = deviceFeatures[i].mCurrentDevice;
+                            deviceFeatures[i].isMusicAppResponsePending = false;
+                        }
+                        if (device == null) {
+                            Log.e(TAG,"ERROR!!!! device is null");
+                            return;
+                        }
+
+                        if (DEBUG)
+                            Log.v(TAG, "SetAddressedPlayer succeeds for: "
+                                + deviceFeatures[i].mRequestedAddressedPlayerPackageName);
+                        deviceFeatures[i].mRequestedAddressedPlayerPackageName = null;
+                        setAdressedPlayerRspNative((byte)OPERATION_SUCCESSFUL,
+                                    getByteAddress(deviceFeatures[i].mCurrentDevice));
+
+                    } else {
+                        if (DEBUG)
+                            Log.v(TAG, "SetaddressedPlayer package mismatch with: "
+                                + deviceFeatures[i].mRequestedAddressedPlayerPackageName);
+                    }
+                } else {
+                    if (DEBUG)
+                        Log.v(TAG, "SetaddressedPlayer request is not in progress");
+                }
+            }
+        }
+
+        if (mMediaPlayers.size() > 0) {
+            final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+            while (rccIterator.hasNext()) {
+                final MediaPlayerInfo di = rccIterator.next();
+                if (di.RetrievePlayerPackageName().equals(callingPackageName)) {
+                    isResetFocusRequired = false;
+                    if (di.GetPlayerAvailablility() != available) {
+                        di.SetPlayerAvailablility(available);
+                        if (DEBUG)
+                            Log.v(TAG, "setting " + callingPackageName +
+                                    " availability: " + available);
+                        if (mHandler != null) {
+                            if (DEBUG)
+                                Log.v(TAG, "Send MSG_UPDATE_AVAILABLE_PLAYERS");
+                            mHandler.obtainMessage(MSG_UPDATE_AVAILABLE_PLAYERS,
+                                    0, 0, 0).sendToTarget();
+                        }
+                    }
+                    if (di.GetPlayerFocus() != focussed) {
+                        di.SetPlayerFocus(focussed);
+                        if (DEBUG)
+                            Log.v(TAG, "setting " + callingPackageName + " focus: " + focussed);
+                        if(focussed) {
+                            if (mHandler != null) {
+                                if (DEBUG)
+                                    Log.v(TAG, "Send MSG_UPDATE_ADDRESSED_PLAYER: " +
+                                    di.RetrievePlayerId());
+                                mHandler.obtainMessage(MSG_UPDATE_ADDRESSED_PLAYER,
+                                        di.RetrievePlayerId(), 0, 0).sendToTarget();
+                            }
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+
+        if (DEBUG)
+            Log.v(TAG, "isResetFocusRequired: " + isResetFocusRequired);
+
+        if (focussed) {
+            // this is applicable only if list contains more than one media players
+            if (mMediaPlayers.size() > 0) {
+                final Iterator<MediaPlayerInfo> rccIterator = mMediaPlayers.iterator();
+                while (rccIterator.hasNext()) {
+                    final MediaPlayerInfo di = rccIterator.next();
+                    if (!(di.RetrievePlayerPackageName().equals(callingPackageName))) {
+                        if (DEBUG)
+                            Log.v(TAG, "setting " +
+                                    callingPackageName + " focus: false");
+                        di.SetPlayerFocus(false); // reset focus for all other players
+                    }
+                }
+            }
+        }
+
+        if(isResetFocusRequired) {
+            for (int i = 0; i < maxAvrcpConnections; i++) {
+                if (mHandler != null) {
+                    if (DEBUG)
+                        Log.v(TAG, "Send MSG_UPDATE_ADDRESSED_PLAYER: 0");
+                    mHandler.obtainMessage(MSG_UPDATE_ADDRESSED_PLAYER,
+                            0, 0, 0).sendToTarget();
+                }
+            }
+        }
+    }
+
+    private void processRegisterNotification(int eventId, int param,
+            String deviceAddress) {
+        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
+        int deviceIndex = getIndexForDevice(device);
+        Log.v(TAG,"processRegisterNotification: eventId" + eventId);
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.v(TAG,"device entry not present, bailing out");
+            return;
+        }
         switch (eventId) {
             case EVT_PLAY_STATUS_CHANGED:
-                mPlayStatusChangedNT = NOTIFICATION_TYPE_INTERIM;
-                registerNotificationRspPlayStatusNative(mPlayStatusChangedNT,
-                                       convertPlayStateToPlayStatus(mCurrentPlayState));
+                deviceFeatures[deviceIndex].mPlayStatusChangedNT =
+                        NOTIFICATION_TYPE_INTERIM;
+                registerNotificationRspPlayStatusNative(
+                        deviceFeatures[deviceIndex].mPlayStatusChangedNT,
+                        convertPlayStateToPlayStatus(
+                        deviceFeatures[deviceIndex].mCurrentPlayState),
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
                 break;
 
             case EVT_TRACK_CHANGED:
-                mTrackChangedNT = NOTIFICATION_TYPE_INTERIM;
-                sendTrackChangedRsp();
+                deviceFeatures[deviceIndex].mTrackChangedNT =
+                        NOTIFICATION_TYPE_INTERIM;
+                sendTrackChangedRsp(device);
                 break;
 
             case EVT_PLAY_POS_CHANGED:
-                long songPosition = getPlayPosition();
-                mPlayPosChangedNT = NOTIFICATION_TYPE_INTERIM;
-                mPlaybackIntervalMs = (long)param * 1000L;
+                long songPosition = getPlayPosition(deviceFeatures[deviceIndex].mCurrentDevice);
+                deviceFeatures[deviceIndex].mPlayPosChangedNT = NOTIFICATION_TYPE_INTERIM;
+                deviceFeatures[deviceIndex].mPlaybackIntervalMs = (long)param * 1000L;
                 if (mCurrentPosMs != RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN) {
-                    mNextPosMs = songPosition + mPlaybackIntervalMs;
-                    mPrevPosMs = songPosition - mPlaybackIntervalMs;
-                    if (mCurrentPlayState == RemoteControlClient.PLAYSTATE_PLAYING) {
-                        Message msg = mHandler.obtainMessage(MESSAGE_PLAY_INTERVAL_TIMEOUT);
-                        mHandler.sendMessageDelayed(msg, mPlaybackIntervalMs);
+                    deviceFeatures[deviceIndex].mNextPosMs = songPosition +
+                                deviceFeatures[deviceIndex].mPlaybackIntervalMs;
+                    deviceFeatures[deviceIndex].mPrevPosMs = songPosition -
+                                deviceFeatures[deviceIndex].mPlaybackIntervalMs;
+                    if (deviceFeatures[deviceIndex].mCurrentPlayState ==
+                            RemoteControlClient.PLAYSTATE_PLAYING) {
+                        Message msg = mHandler.obtainMessage(MESSAGE_PLAY_INTERVAL_TIMEOUT,
+                                0, 0, deviceFeatures[deviceIndex].mCurrentDevice);
+                        mHandler.sendMessageDelayed(msg,
+                                deviceFeatures[deviceIndex].mPlaybackIntervalMs);
                     }
                 }
-                registerNotificationRspPlayPosNative(mPlayPosChangedNT, (int)songPosition);
+                registerNotificationRspPlayPosNative(deviceFeatures[deviceIndex].mPlayPosChangedNT,
+                        (int)getPlayPosition(deviceFeatures[deviceIndex].mCurrentDevice) ,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                if (DEBUG)
+                    Log.v(TAG,"mPlayPosChangedNT updated for index " +
+                        deviceFeatures[deviceIndex].mPlayPosChangedNT +
+                        " index " + deviceIndex);
                 break;
 
-        }
-    }
+            case EVT_APP_SETTINGS_CHANGED:
+                deviceFeatures[deviceIndex].mPlayerStatusChangeNT = NOTIFICATION_TYPE_INTERIM;
+                sendPlayerAppChangedRsp(deviceFeatures[deviceIndex].mPlayerStatusChangeNT,
+                        device);
+                break;
 
-    private void handlePassthroughCmd(int id, int keyState) {
-        switch (id) {
-            case BluetoothAvrcp.PASSTHROUGH_ID_REWIND:
-                rewind(keyState);
+            case EVT_ADDRESSED_PLAYER_CHANGED:
+                if (DEBUG)
+                    Log.v(TAG, "Process EVT_ADDRESSED_PLAYER_CHANGED Interim: Player ID: "
+                            + mAddressedPlayerId);
+                deviceFeatures[deviceIndex].mAddressedPlayerChangedNT = NOTIFICATION_TYPE_INTERIM;
+                registerNotificationRspAddressedPlayerChangedNative(
+                        deviceFeatures[deviceIndex].mAddressedPlayerChangedNT ,
+                        mAddressedPlayerId ,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
                 break;
-            case BluetoothAvrcp.PASSTHROUGH_ID_FAST_FOR:
-                fastForward(keyState);
+
+            case EVT_AVAILABLE_PLAYERS_CHANGED:
+                deviceFeatures[deviceIndex].mAvailablePlayersChangedNT = NOTIFICATION_TYPE_INTERIM;
+                registerNotificationRspAvailablePlayersChangedNative(
+                        deviceFeatures[deviceIndex].mAvailablePlayersChangedNT,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
                 break;
-        }
-    }
 
-    private void fastForward(int keyState) {
-        Message msg = mHandler.obtainMessage(MESSAGE_FAST_FORWARD, keyState, 0);
-        mHandler.sendMessage(msg);
+            case EVT_NOW_PLAYING_CONTENT_CHANGED:
+                deviceFeatures[deviceIndex].mNowPlayingContentChangedNT = NOTIFICATION_TYPE_INTERIM;
+                registerNotificationRspNowPlayingContentChangedNative(
+                        deviceFeatures[deviceIndex].mNowPlayingContentChangedNT ,
+                        getByteAddress(deviceFeatures[deviceIndex].mCurrentDevice));
+                break;
+
+            default:
+                Log.v(TAG, "processRegisterNotification: Unhandled Type: " + eventId);
+                break;
+        }
     }
 
-    private void rewind(int keyState) {
-        Message msg = mHandler.obtainMessage(MESSAGE_REWIND, keyState, 0);
-        mHandler.sendMessage(msg);
+    private void handlePassthroughCmd(int id, int keyState,
+                byte[] address) {
+        switch (id) {
+            case BluetoothAvrcp.PASSTHROUGH_ID_REWIND:
+                rewind(keyState, Utils.getAddressStringFromByte(address));
+                break;
+            case BluetoothAvrcp.PASSTHROUGH_ID_FAST_FOR:
+                fastForward(keyState, Utils.getAddressStringFromByte(address));
+                break;
+        }
     }
 
-    private void changePositionBy(long amount) {
-        long currentPosMs = getPlayPosition();
+    private void changePositionBy(long amount, String deviceAddress) {
+        long currentPosMs = getPlayPosition(mAdapter.getRemoteDevice(deviceAddress));
         if (currentPosMs == -1L) return;
         long newPosMs = Math.max(0L, currentPosMs + amount);
         mRemoteController.seekTo(newPosMs);
@@ -671,38 +4043,118 @@ public final class Avrcp {
         return (int) Math.min(MAX_MULTIPLIER_VALUE, multi);
     }
 
-    private void sendTrackChangedRsp() {
+    private void sendTrackChangedRsp(BluetoothDevice device) {
         byte[] track = new byte[TRACK_ID_SIZE];
+        long TrackNumberRsp = -1L;
+        int deviceIndex = getIndexForDevice(device);
+        if(DEBUG) Log.v(TAG,"mCurrentPlayState" +
+                deviceFeatures[deviceIndex].mCurrentPlayState );
 
-        /* If no track is currently selected, then return
-           0xFFFFFFFFFFFFFFFF in the interim response */
-        long trackNumberRsp = -1L;
-
-        if (mCurrentPlayState == RemoteControlClient.PLAYSTATE_PLAYING) {
-            trackNumberRsp = mTrackNumber;
-        }
+        TrackNumberRsp = mMetadata.tracknum ;
 
         /* track is stored in big endian format */
         for (int i = 0; i < TRACK_ID_SIZE; ++i) {
-            track[i] = (byte) (trackNumberRsp >> (56 - 8 * i));
+            track[i] = (byte) (TrackNumberRsp >> (56 - 8 * i));
         }
-        registerNotificationRspTrackChangeNative(mTrackChangedNT, track);
+        registerNotificationRspTrackChangeNative(deviceFeatures[deviceIndex].mTrackChangedNT ,
+                track ,getByteAddress(device));
+
     }
 
-    private long getPlayPosition() {
+    private void sendPlayerAppChangedRsp(int rsptype, BluetoothDevice device) {
+        int j = 0;
+        byte i = NUMPLAYER_ATTRIBUTE*2;
+        byte [] retVal = new byte [i];
+        retVal[j++] = ATTRIBUTE_REPEATMODE;
+        retVal[j++] = settingValues.repeat_value;
+        retVal[j++] = ATTRIBUTE_SHUFFLEMODE;
+        retVal[j++] = settingValues.shuffle_value;
+        registerNotificationPlayerAppRspNative(rsptype,
+                i, retVal,
+                getByteAddress(device));
+    }
+
+    private long getPlayPosition(BluetoothDevice device) {
         long songPosition = -1L;
-        if (mCurrentPosMs != RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN) {
-            if (mCurrentPlayState == RemoteControlClient.PLAYSTATE_PLAYING) {
-                songPosition = SystemClock.elapsedRealtime() -
-                               mPlayStartTimeMs + mCurrentPosMs;
-            } else {
-                songPosition = mCurrentPosMs;
+        if (device != null) {
+            int deviceIndex = getIndexForDevice(device);
+            if (deviceIndex == INVALID_DEVICE_INDEX) {
+                Log.e(TAG,"Device index is not valid in getPlayPosition");
+                return songPosition;
+            }
+            if (mCurrentPosMs != RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN) {
+                if (deviceFeatures[deviceIndex].mCurrentPlayState ==
+                        RemoteControlClient.PLAYSTATE_PLAYING) {
+                    songPosition = SystemClock.elapsedRealtime() - mPlayStartTimeMs +
+                                            mCurrentPosMs;
+                } else {
+                    songPosition = mCurrentPosMs;
+                }
+            }
+        } else {
+            if (mCurrentPosMs != RemoteControlClient.PLAYBACK_POSITION_ALWAYS_UNKNOWN) {
+                if (mCurrentPlayerState == RemoteControlClient.PLAYSTATE_PLAYING) {
+                    songPosition = SystemClock.elapsedRealtime() -
+                                   mPlayStartTimeMs + mCurrentPosMs;
+                } else {
+                    songPosition = mCurrentPosMs;
+                }
             }
         }
-        if (DEBUG) Log.v(TAG, "position=" + songPosition);
+        if (DEBUG) Log.v(TAG, "getPlayPosition position: " + songPosition + " Device:"
+                                                                                + device);
         return songPosition;
     }
 
+    private String getAttributeStringFromCursor(Cursor cursor, int attrId, int deviceIndex) {
+        String attrStr = "<unknown>";
+        switch (attrId) {
+            case MEDIA_ATTR_TITLE:
+                attrStr = cursor.getString(cursor.getColumnIndexOrThrow(
+                                        MediaStore.Audio.Media.TITLE));
+                break;
+            case MEDIA_ATTR_ARTIST:
+                attrStr = cursor.getString(cursor.getColumnIndexOrThrow(
+                                        MediaStore.Audio.Media.ARTIST));
+                break;
+            case MEDIA_ATTR_ALBUM:
+                attrStr = cursor.getString(cursor.getColumnIndexOrThrow(
+                                        MediaStore.Audio.Media.ALBUM));
+                break;
+            case MEDIA_ATTR_PLAYING_TIME:
+                attrStr = cursor.getString(cursor.getColumnIndexOrThrow(
+                                        MediaStore.Audio.Media.DURATION));
+                break;
+            case MEDIA_ATTR_TRACK_NUM:
+                if (deviceFeatures[deviceIndex].mCurrentPath.equals(PATH_PLAYLISTS)) {
+                    attrStr = cursor.getString(cursor.getColumnIndexOrThrow(
+                                    MediaStore.Audio.Playlists.Members._ID));
+                } else {
+                    attrStr = String.valueOf(cursor.getLong(
+                                cursor.getColumnIndexOrThrow("_id")));
+                }
+                break;
+            case MEDIA_ATTR_NUM_TRACKS:
+                attrStr = String.valueOf(cursor.getCount());
+                break;
+            case MEDIA_ATTR_GENRE:
+                attrStr = "<unknown>"; // GENRE is not supported
+                break;
+            default:
+                Log.v(TAG, "getAttributeStringFromCursor: wrong attribute: attrId = "
+                                                                            + attrId);
+                break;
+        }
+        if (attrStr == null) {
+            attrStr = new String();
+        }
+        if (DEBUG)
+            Log.v(TAG, "getAttributeStringFromCursor: attrId = "
+                    + attrId + " str = " + attrStr);
+        return attrStr;
+    }
+
+
     private String getAttributeString(int attrId) {
         String attrStr = null;
         switch (attrId) {
@@ -724,11 +4176,23 @@ public final class Avrcp {
                 }
                 break;
 
+            case MEDIA_ATTR_TRACK_NUM:
+                attrStr = Long.toString(mMetadata.tracknum);
+                break;
+
+            case MEDIA_ATTR_NUM_TRACKS:
+                attrStr = Long.toString(mTrackNumber);
+                break;
+
+             case MEDIA_ATTR_GENRE:
+                attrStr = mMetadata.genre;
+                break;
         }
         if (attrStr == null) {
             attrStr = new String();
         }
-        if (DEBUG) Log.v(TAG, "getAttributeString:attrId=" + attrId + " str=" + attrStr);
+        if (DEBUG)
+            Log.v(TAG, "getAttributeString:attrId=" + attrId + " str=" + attrStr);
         return attrStr;
     }
 
@@ -784,9 +4248,25 @@ public final class Avrcp {
     /**
      * This is called from AudioService. It will return whether this device supports abs volume.
      * NOT USED AT THE MOMENT.
+     * returns true only when both playing devices support absolute volume
      */
     public boolean isAbsoluteVolumeSupported() {
-        return ((mFeatures & BTRC_FEAT_ABSOLUTE_VOLUME) != 0);
+        List<Byte> absVolumeSupported = new ArrayList<Byte>();
+        for (int i = 0; i < maxAvrcpConnections; i++ ) {
+            if (deviceFeatures[i].mCurrentDevice != null) {
+                // add 1 in byte list if absolute volume is supported
+                // add 0 in byte list if absolute volume not supported
+                if ((deviceFeatures[i].mFeatures &
+                        BTRC_FEAT_ABSOLUTE_VOLUME) != 0) {
+                    Log.v(TAG, "isAbsoluteVolumeSupported: yes, for dev: " + i);
+                    absVolumeSupported.add((byte)1);
+                } else {
+                    Log.v(TAG, "isAbsoluteVolumeSupported: no, for dev: " + i);
+                    absVolumeSupported.add((byte)0);
+                }
+            }
+        }
+        return !(absVolumeSupported.contains((byte)0) || absVolumeSupported.isEmpty());
     }
 
     /**
@@ -813,12 +4293,13 @@ public final class Avrcp {
      * This method will send a message to our handler to change the local stored volume and notify
      * AudioService to update the UI
      */
-    private void volumeChangeCallback(int volume, int ctype) {
-        Message msg = mHandler.obtainMessage(MESSAGE_VOLUME_CHANGED, volume, ctype);
+    private void volumeChangeCallback(int volume, int ctype, byte[] address) {
+        Message msg = mHandler.obtainMessage(MESSAGE_VOLUME_CHANGED, volume,
+                ctype, Utils.getAddressStringFromByte(address));
         mHandler.sendMessage(msg);
     }
 
-    private void notifyVolumeChanged(int volume) {
+    private void notifyVolumeChanged(int volume, BluetoothDevice device) {
         volume = convertToAudioStreamVolume(volume);
         mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, volume,
                       AudioManager.FLAG_SHOW_UI | AudioManager.FLAG_BLUETOOTH_ABS_VOLUME);
@@ -833,52 +4314,439 @@ public final class Avrcp {
         return (int) Math.ceil((double) volume*AVRCP_MAX_VOL/mAudioStreamMax);
     }
 
+    private void updateLocalPlayerSettings( byte[] data) {
+        if (DEBUG) Log.v(TAG, "updateLocalPlayerSettings");
+        for (int i = 0; i < data.length; i += 2) {
+            if (DEBUG) Log.v(TAG, "ID: " + data[i] + " Value: " + data[i+1]);
+            switch (data[i]) {
+                case ATTRIBUTE_EQUALIZER:
+                    settingValues.eq_value = data[i+1];
+                break;
+                case ATTRIBUTE_REPEATMODE:
+                    settingValues.repeat_value = data[i+1];
+                break;
+                case ATTRIBUTE_SHUFFLEMODE:
+                    settingValues.shuffle_value = data[i+1];
+                break;
+                case ATTRIBUTE_SCANMODE:
+                    settingValues.scan_value = data[i+1];
+                break;
+            }
+        }
+    }
+
+    private boolean checkPlayerAttributeResponse( byte[] data) {
+        boolean ret = false;
+        if (DEBUG) Log.v(TAG, "checkPlayerAttributeResponse");
+        for (int i = 0; i < data.length; i += 2) {
+            if (DEBUG) Log.v(TAG, "ID: " + data[i] + " Value: " + data[i+1]);
+            switch (data[i]) {
+                case ATTRIBUTE_EQUALIZER:
+                    if (mPendingSetAttributes.contains(new Integer(ATTRIBUTE_EQUALIZER))) {
+                        Log.v(TAG, "Pending SetAttribute contains Equalizer");
+                        if(data[i+1] == ATTRIBUTE_NOTSUPPORTED) {
+                            ret = false;
+                        } else {
+                            ret = true;
+                        }
+                    }
+                break;
+                case ATTRIBUTE_REPEATMODE:
+                    if (mPendingSetAttributes.contains(new Integer(ATTRIBUTE_REPEATMODE))) {
+                        Log.v(TAG, "Pending SetAttribute contains Repeat");
+                        if(data[i+1] == ATTRIBUTE_NOTSUPPORTED) {
+                            ret = false;
+                        } else {
+                            ret = true;
+                        }
+                    }
+                break;
+                case ATTRIBUTE_SHUFFLEMODE:
+                    if (mPendingSetAttributes.contains(new Integer(ATTRIBUTE_SHUFFLEMODE))) {
+                        Log.v(TAG, "Pending SetAttribute contains Shuffle");
+                        if(data[i+1] == ATTRIBUTE_NOTSUPPORTED) {
+                            ret = false;
+                        } else {
+                            ret = true;
+                        }
+                    }
+                break;
+            }
+        }
+        return ret;
+    }
+
+    //PDU ID 0x11
+    private void onListPlayerAttributeRequest(byte[] address) {
+        if (DEBUG)
+            Log.v(TAG, "onListPlayerAttributeRequest");
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_IDS);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                        Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+        Message msg = mHandler.obtainMessage(MESSAGE_PLAYERSETTINGS_TIMEOUT,
+                GET_ATTRIBUTE_IDS,0 ,
+                Utils.getAddressStringFromByte(address));
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+    }
+
+    //PDU ID 0x12
+    private void onListPlayerAttributeValues (byte attr, byte[] address) {
+        if (DEBUG)Log.v(TAG, "onListPlayerAttributeValues");
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_VALUE_IDS);
+        intent.putExtra(EXTRA_ATTRIBUTE_ID, attr);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        mPlayerSettings.attr = attr;
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+
+        Message msg = mHandler.obtainMessage();
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_VALUE_IDS;
+        msg.arg2 = 0;
+        msg.obj = Utils.getAddressStringFromByte(address);
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+    }
+
+
+    //PDU ID 0x13
+    private void onGetPlayerAttributeValues (byte attr ,int[] arr ,
+            byte[] address)
+    {
+        if (DEBUG)
+            Log.v(TAG, "onGetPlayerAttributeValues: num of attrib " + attr );
+        int i ;
+        byte[] barray = new byte[attr];
+        for(i =0 ; i<attr ; ++i)
+            barray[i] = (byte)arr[i];
+        mPlayerSettings.attrIds = new byte [attr];
+        for ( i = 0; i < attr; i++)
+            mPlayerSettings.attrIds[i] = barray[i];
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_VALUES);
+        intent.putExtra(EXTRA_ATTIBUTE_ID_ARRAY, barray);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+
+        Message msg = mHandler.obtainMessage();
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_ATTRIBUTE_VALUES;
+        msg.arg2 = 0;
+        msg.obj = Utils.getAddressStringFromByte(address);
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+    }
+
+    //PDU 0x14
+    private void setPlayerAppSetting( byte num, byte [] attr_id, byte [] attr_val,
+            byte[] address)
+    {
+        if (DEBUG)
+            Log.v(TAG, "setPlayerAppSetting: number of attributes" + num );
+        byte[] array = new byte[num*2];
+        for ( int i = 0; i < num; i++)
+        {
+            array[i] = attr_id[i] ;
+            array[i+1] = attr_val[i];
+            mPendingSetAttributes.add(new Integer(attr_id[i]));
+        }
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        intent.putExtra(COMMAND, CMDSET);
+        intent.putExtra(EXTRA_ATTRIB_VALUE_PAIRS, array);
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+
+        Message msg = mHandler.obtainMessage();
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = SET_ATTRIBUTE_VALUES;
+        msg.arg2 = 0;
+        msg.obj = Utils.getAddressStringFromByte(address);
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+    }
+
+    //PDU 0x15
+    private void getplayerattribute_text(byte attr , byte [] attrIds,
+            byte[] address)
+    {
+        if(DEBUG) Log.d(TAG, "getplayerattribute_text " + attr +" attrIDsNum "
+                                                        + attrIds.length);
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_ATTRIBUTE_TEXT);
+        intent.putExtra(EXTRA_ATTIBUTE_ID_ARRAY, attrIds);
+        mPlayerSettings.attrIds = new byte [attr];
+        for (int i = 0; i < attr; i++)
+            mPlayerSettings.attrIds[i] = attrIds[i];
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_ATTRIBUTE_TEXT;
+        msg.arg2 = 0;
+        msg.obj = Utils.getAddressStringFromByte(address);
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+   }
+
+    //PDU 0x15
+    private void getplayervalue_text(byte attr_id , byte num_value , byte [] value,
+            byte[] address)
+    {
+        if(DEBUG) Log.d(TAG, "getplayervalue_text id " + attr_id +" num_value " + num_value
+                                                           +" length " + value.length);
+        Intent intent = new Intent(PLAYERSETTINGS_REQUEST);
+        Message msg = mHandler.obtainMessage();
+        intent.putExtra(COMMAND, CMDGET);
+        intent.putExtra(EXTRA_GET_COMMAND, GET_VALUE_TEXT);
+        intent.putExtra(EXTRA_ATTRIBUTE_ID, attr_id);
+        intent.putExtra(EXTRA_VALUE_ID_ARRAY, value);
+        mPlayerSettings.attrIds = new byte [num_value];
+        int deviceIndex =
+                getIndexForDevice(mAdapter.getRemoteDevice(
+                Utils.getAddressStringFromByte(address)));
+        if (deviceIndex == INVALID_DEVICE_INDEX) {
+            Log.e(TAG,"invalid index for device");
+            return;
+        }
+        deviceFeatures[deviceIndex].isMusicAppResponsePending = true;
+
+        for (int i = 0; i < num_value; i++)
+            mPlayerSettings.attrIds[i] = value[i];
+        mContext.sendBroadcast(intent, BLUETOOTH_PERM);
+        msg.what = MESSAGE_PLAYERSETTINGS_TIMEOUT;
+        msg.arg1 = GET_VALUE_TEXT;
+        msg.arg2 = 0;
+        msg.obj = Utils.getAddressStringFromByte(address);
+        mPendingCmds.add(new Integer(msg.arg1));
+        mHandler.sendMessageDelayed(msg, 500);
+    }
+
     /**
      * This is called from A2dpStateMachine to set A2dp audio state.
      */
-    public void setA2dpAudioState(int state) {
-        Message msg = mHandler.obtainMessage(MESSAGE_SET_A2DP_AUDIO_STATE, state, 0);
+    public void setA2dpAudioState(int state, BluetoothDevice device) {
+        Message msg = mHandler.obtainMessage(MESSAGE_SET_A2DP_AUDIO_STATE, state,
+                0, device);
         mHandler.sendMessage(msg);
     }
 
+    public void setAvrcpConnectedDevice(BluetoothDevice device) {
+        Log.i(TAG,"Device added is " + device);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mCurrentDevice != null &&
+                    deviceFeatures[i].mCurrentDevice.equals(device)) {
+                Log.v(TAG,"device is already added in connected list, ignore now");
+                return;
+            }
+        }
+        for (int i = 0; i < maxAvrcpConnections; i++ ) {
+            if (deviceFeatures[i].mCurrentDevice == null) {
+                deviceFeatures[i].mCurrentDevice = device;
+                /*Playstate is explicitly updated here to take care of cases
+                        where play state update is missed because of that happening
+                        even before Avrcp connects*/
+                deviceFeatures[i].mCurrentPlayState = mCurrentPlayerState;
+                Log.i(TAG,"play status updated on Avrcp connection as: " +
+                                                    mCurrentPlayerState);
+                Log.i(TAG,"device added at " + i);
+                break;
+            }
+        }
+    }
+
+    public boolean isAvrcpConnected() {
+        boolean ret = false;
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mCurrentDevice != null) {
+                ret = true;
+                break;
+            }
+        }
+        Log.i(TAG,"isAvrcpConnected: " + ret);
+        return ret;
+    }
+
+    private int getIndexForDevice(BluetoothDevice device) {
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            if (deviceFeatures[i].mCurrentDevice != null &&
+                    deviceFeatures[i].mCurrentDevice.equals(device)) {
+                Log.i(TAG,"device found at index " + i);
+                return i;
+            }
+        }
+        Log.e(TAG, "returning invalid index");
+        return INVALID_DEVICE_INDEX;
+    }
+
+    public void cleanupDeviceFeaturesIndex (int index) {
+        Log.i(TAG,"cleanupDeviceFeaturesIndex index:" + index);
+        deviceFeatures[index].mCurrentDevice = null;
+        deviceFeatures[index].mCurrentPlayState = RemoteControlClient.PLAYSTATE_NONE;
+        deviceFeatures[index].mPlayStatusChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mPlayerStatusChangeNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mTrackChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mPlaybackIntervalMs = 0L;
+        deviceFeatures[index].mPlayPosChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mFeatures = 0;
+        deviceFeatures[index].mAbsoluteVolume = -1;
+        deviceFeatures[index].mLastSetVolume = -1;
+        deviceFeatures[index].mLastDirection = 0;
+        deviceFeatures[index].mVolCmdInProgress = false;
+        deviceFeatures[index].mAbsVolRetryTimes = 0;
+        deviceFeatures[index].keyPressState = KEY_STATE_RELEASE; //Key release state
+        deviceFeatures[index].mAddressedPlayerChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mAvailablePlayersChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mNowPlayingContentChangedNT = NOTIFICATION_TYPE_CHANGED;
+        deviceFeatures[index].mRequestedAddressedPlayerPackageName = null;
+        deviceFeatures[index].mCurrentPath = PATH_INVALID;
+        deviceFeatures[index].mCurrentPathUid = null;
+        deviceFeatures[index].mMediaUri = Uri.EMPTY;
+        deviceFeatures[index].isMusicAppResponsePending = false;
+        deviceFeatures[index].isBrowsingSupported = false;
+        deviceFeatures[index].isAbsoluteVolumeSupportingDevice = false;
+    }
+    /**
+     * This is called from A2dpStateMachine to set A2dp Connected device to null on disconnect.
+     */
+    public void setAvrcpDisconnectedDevice(BluetoothDevice device) {
+        for (int i = 0; i < maxAvrcpConnections; i++ ) {
+            if (deviceFeatures[i].mCurrentDevice !=null &&
+                    deviceFeatures[i].mCurrentDevice.equals(device)) {
+                // initiate cleanup for all variables;
+                Log.i(TAG,"Device removed is " + device);
+                Log.i(TAG,"removed at " + i);
+                deviceFeatures[i].mCurrentDevice = null;
+                cleanupDeviceFeaturesIndex(i);
+                /* device is disconnect and some response form music app was
+                 * pending for this device clear it.*/
+                if (mBrowserDevice != null &&
+                        mBrowserDevice.equals(device)) {
+                    Log.i(TAG,"clearing mBrowserDevice on disconnect");
+                    mBrowserDevice = null;
+                }
+                break;
+            }
+        }
+        mAudioManager.avrcpSupportsAbsoluteVolume(device.getAddress(),
+                isAbsoluteVolumeSupported());
+        Log.v(TAG," update audio manager for abs vol state = "
+                + isAbsoluteVolumeSupported());
+        for (int i = 0; i < maxAvrcpConnections; i++ ) {
+            if (deviceFeatures[i].mCurrentDevice != null) {
+                if (isAbsoluteVolumeSupported() &&
+                        deviceFeatures[i].mAbsoluteVolume != -1) {
+                    notifyVolumeChanged(deviceFeatures[i].mAbsoluteVolume,
+                            deviceFeatures[i].mCurrentDevice);
+                    Log.v(TAG," update audio manager for abs vol  = "
+                            + deviceFeatures[i].mAbsoluteVolume);
+                }
+                break;
+            }
+        }
+    }
+
+    private byte[] getByteAddress(BluetoothDevice device) {
+        return Utils.getBytesFromAddress(device.getAddress());
+    }
+
+    private void onConnectionStateChanged(boolean connected, byte[] address) {
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+            (Utils.getAddressStringFromByte(address));
+        Log.d(TAG, "onConnectionStateChanged state: " + connected + " Addr: " + device);
+        if (connected) {
+            setAvrcpConnectedDevice(device);
+        } else {
+            setAvrcpDisconnectedDevice(device);
+        }
+    }
+
     public void dump(StringBuilder sb) {
         sb.append("AVRCP:\n");
-        ProfileService.println(sb, "mMetadata: " + mMetadata);
-        ProfileService.println(sb, "mTransportControlFlags: " + mTransportControlFlags);
-        ProfileService.println(sb, "mCurrentPlayState: " + mCurrentPlayState);
-        ProfileService.println(sb, "mPlayStatusChangedNT: " + mPlayStatusChangedNT);
-        ProfileService.println(sb, "mTrackChangedNT: " + mTrackChangedNT);
-        ProfileService.println(sb, "mTrackNumber: " + mTrackNumber);
-        ProfileService.println(sb, "mCurrentPosMs: " + mCurrentPosMs);
-        ProfileService.println(sb, "mPlayStartTimeMs: " + mPlayStartTimeMs);
-        ProfileService.println(sb, "mSongLengthMs: " + mSongLengthMs);
-        ProfileService.println(sb, "mPlaybackIntervalMs: " + mPlaybackIntervalMs);
-        ProfileService.println(sb, "mPlayPosChangedNT: " + mPlayPosChangedNT);
-        ProfileService.println(sb, "mNextPosMs: " + mNextPosMs);
-        ProfileService.println(sb, "mPrevPosMs: " + mPrevPosMs);
-        ProfileService.println(sb, "mSkipStartTime: " + mSkipStartTime);
-        ProfileService.println(sb, "mFeatures: " + mFeatures);
-        ProfileService.println(sb, "mAbsoluteVolume: " + mAbsoluteVolume);
-        ProfileService.println(sb, "mLastSetVolume: " + mLastSetVolume);
-        ProfileService.println(sb, "mLastDirection: " + mLastDirection);
-        ProfileService.println(sb, "mVolumeStep: " + mVolumeStep);
-        ProfileService.println(sb, "mAudioStreamMax: " + mAudioStreamMax);
-        ProfileService.println(sb, "mVolCmdInProgress: " + mVolCmdInProgress);
-        ProfileService.println(sb, "mAbsVolRetryTimes: " + mAbsVolRetryTimes);
-        ProfileService.println(sb, "mSkipAmount: " + mSkipAmount);
+        for (int i = 0; i < maxAvrcpConnections; i++) {
+            Log.v(TAG,"for index " + i);
+            ProfileService.println(sb, "mMetadata: " + mMetadata);
+            ProfileService.println(sb, "mTransportControlFlags: " + mTransportControlFlags);
+            ProfileService.println(sb, "mCurrentPlayState: " + deviceFeatures[i].mCurrentPlayState);
+            ProfileService.println(sb, "mPlayStatusChangedNT: " + deviceFeatures[i].mPlayStatusChangedNT);
+            ProfileService.println(sb, "mTrackChangedNT: " + deviceFeatures[i].mTrackChangedNT);
+            ProfileService.println(sb, "mTrackNumber: " + mTrackNumber);
+            ProfileService.println(sb, "mCurrentPosMs: " + mCurrentPosMs);
+            ProfileService.println(sb, "mPlayStartTimeMs: " + mPlayStartTimeMs);
+            ProfileService.println(sb, "mSongLengthMs: " + mSongLengthMs);
+            ProfileService.println(sb, "mPlaybackIntervalMs: " + deviceFeatures[i].mPlaybackIntervalMs);
+            ProfileService.println(sb, "mPlayPosChangedNT: " + deviceFeatures[i].mPlayPosChangedNT);
+            ProfileService.println(sb, "mNextPosMs: " + deviceFeatures[i].mNextPosMs);
+            ProfileService.println(sb, "mPrevPosMs: " + deviceFeatures[i].mPrevPosMs);
+            ProfileService.println(sb, "mSkipStartTime: " + mSkipStartTime);
+            ProfileService.println(sb, "mFeatures: " + deviceFeatures[i].mFeatures);
+            ProfileService.println(sb, "mAbsoluteVolume: " + deviceFeatures[i].mAbsoluteVolume);
+            ProfileService.println(sb, "mLastSetVolume: " + deviceFeatures[i].mLastSetVolume);
+            ProfileService.println(sb, "mLastDirection: " + deviceFeatures[i].mLastDirection);
+            ProfileService.println(sb, "mVolumeStep: " + mVolumeStep);
+            ProfileService.println(sb, "mAudioStreamMax: " + mAudioStreamMax);
+            ProfileService.println(sb, "mVolCmdInProgress: " + deviceFeatures[i].mVolCmdInProgress);
+            ProfileService.println(sb, "mAbsVolRetryTimes: " + deviceFeatures[i].mAbsVolRetryTimes);
+            ProfileService.println(sb, "mSkipAmount: " + mSkipAmount);
+        }
     }
 
     // Do not modify without updating the HAL bt_rc.h files.
 
     // match up with btrc_play_status_t enum of bt_rc.h
-    final static int PLAYSTATUS_STOPPED = 0;
-    final static int PLAYSTATUS_PLAYING = 1;
-    final static int PLAYSTATUS_PAUSED = 2;
-    final static int PLAYSTATUS_FWD_SEEK = 3;
-    final static int PLAYSTATUS_REV_SEEK = 4;
-    final static int PLAYSTATUS_ERROR = 255;
+    final static byte PLAYSTATUS_STOPPED = 0;
+    final static byte PLAYSTATUS_PLAYING = 1;
+    final static byte PLAYSTATUS_PAUSED = 2;
+    final static byte PLAYSTATUS_FWD_SEEK = 3;
+    final static byte PLAYSTATUS_REV_SEEK = 4;
+    final static short PLAYSTATUS_ERROR = 255;
 
     // match up with btrc_media_attr_t enum of bt_rc.h
+    final static int MEDIA_ATTR_MIN = 1;
     final static int MEDIA_ATTR_TITLE = 1;
     final static int MEDIA_ATTR_ARTIST = 2;
     final static int MEDIA_ATTR_ALBUM = 3;
@@ -886,6 +4754,7 @@ public final class Avrcp {
     final static int MEDIA_ATTR_NUM_TRACKS = 5;
     final static int MEDIA_ATTR_GENRE = 6;
     final static int MEDIA_ATTR_PLAYING_TIME = 7;
+    final static int MEDIA_ATTR_MAX = 7;
 
     // match up with btrc_event_id_t enum of bt_rc.h
     final static int EVT_PLAY_STATUS_CHANGED = 1;
@@ -896,23 +4765,556 @@ public final class Avrcp {
     final static int EVT_BATT_STATUS_CHANGED = 6;
     final static int EVT_SYSTEM_STATUS_CHANGED = 7;
     final static int EVT_APP_SETTINGS_CHANGED = 8;
-
+    final static int EVT_NOW_PLAYING_CONTENT_CHANGED = 9;
+    final static int EVT_AVAILABLE_PLAYERS_CHANGED = 10; //0x0a
+    final static int EVT_ADDRESSED_PLAYER_CHANGED = 11; //0x0b
     // match up with btrc_notification_type_t enum of bt_rc.h
     final static int NOTIFICATION_TYPE_INTERIM = 0;
     final static int NOTIFICATION_TYPE_CHANGED = 1;
+    final static int NOTIFICATION_TYPE_REJECT = 2;
 
     // match up with BTRC_UID_SIZE of bt_rc.h
     final static int TRACK_ID_SIZE = 8;
 
+    final static byte ITEM_PLAYER = 0x01;
+
+    final static int SCOPE_PLAYER_LIST = 0x00;
+    final static int SCOPE_VIRTUAL_FILE_SYS = 0x01;
+    final static int SCOPE_NOW_PLAYING = 0x03;
+
+    final static int FOLDER_ITEM_COUNT_NONE = 0xFF;
+
+    final static short CHAR_SET_UTF8 = 0x006A;
+
+    // major player type
+    final static byte MAJOR_TYPE_AUDIO = 0x01;  /* Audio */
+    final static byte MAJOR_TYPE_VIDEO = 0x02;  /* Video */
+    final static byte MAJOR_TYPE_BC_AUDIO = 0x04;  /* Broadcasting Audio */
+    final static byte MAJOR_TYPE_BC_VIDEO = 0x08;  /* Broadcasting Video */
+    final static short MAJOR_TYPE_INVALID = 0xF0;
+
+    // player sub type
+    final static int SUB_TYPE_NONE = 0x0000;
+    final static int SUB_TYPE_AUDIO_BOOK = 0x0001;  /* Audio Book */
+    final static int SUB_TYPE_PODCAST = 0x0002;  /* Podcast */
+    final static int SUB_TYPE_INVALID = 0x00FC;
+
+    // supported feature-mask
+    final static int FEATURE_MASK_SELECT_BIT_NO = 0;
+    final static int FEATURE_MASK_SELECT_MASK = 0x01;
+    final static int FEATURE_MASK_SELECT_OFFSET = 0;
+
+    final static int FEATURE_MASK_UP_BIT_NO = 1;
+    final static int FEATURE_MASK_UP_MASK = 0x02;
+    final static int FEATURE_MASK_UP_OFFSET = 0;
+
+    final static int FEATURE_MASK_DOWN_BIT_NO = 2;
+    final static int FEATURE_MASK_DOWN_MASK = 0x04;
+    final static int FEATURE_MASK_DOWN_OFFSET = 0;
+
+    final static int FEATURE_MASK_LEFT_BIT_NO = 3;
+    final static int FEATURE_MASK_LEFT_MASK = 0x08;
+    final static int FEATURE_MASK_LEFT_OFFSET = 0;
+
+    final static int FEATURE_MASK_RIGHT_BIT_NO = 4;
+    final static int FEATURE_MASK_RIGHT_MASK = 0x10;
+    final static int FEATURE_MASK_RIGHT_OFFSET = 0;
+
+    final static int FEATURE_MASK_RIGHTUP_BIT_NO = 5;
+    final static int FEATURE_MASK_RIGHTUP_MASK = 0x20;
+    final static int FEATURE_MASK_RIGHTUP_OFFSET = 0;
+
+    final static int FEATURE_MASK_RIGHTDOWN_BIT_NO = 6;
+    final static int FEATURE_MASK_RIGHTDOWN_MASK = 0x40;
+    final static int FEATURE_MASK_RIGHTDOWN_OFFSET = 0;
+
+    final static int FEATURE_MASK_LEFTUP_BIT_NO = 7;
+    final static int FEATURE_MASK_LEFTUP_MASK = 0x80;
+    final static int FEATURE_MASK_LEFTUP_OFFSET = 0;
+
+    final static int FEATURE_MASK_LEFTDOWN_BIT_NO = 8;
+    final static int FEATURE_MASK_LEFTDOWN_MASK = 0x01;
+    final static int FEATURE_MASK_LEFTDOWN_OFFSET = 1;
+
+    final static int FEATURE_MASK_ROOT_MENU_BIT_NO = 9;
+    final static int FEATURE_MASK_ROOT_MENU_MASK = 0x02;
+    final static int FEATURE_MASK_ROOT_MENU_OFFSET = 1;
+
+    final static int FEATURE_MASK_SETUP_MENU_BIT_NO = 10;
+    final static int FEATURE_MASK_SETUP_MENU_MASK = 0x04;
+    final static int FEATURE_MASK_SETUP_MENU_OFFSET = 1;
+
+    final static int FEATURE_MASK_CONTENTS_MENU_BIT_NO = 11;
+    final static int FEATURE_MASK_CONTENTS_MENU_MASK = 0x08;
+    final static int FEATURE_MASK_CONTENTS_MENU_OFFSET = 1;
+
+    final static int FEATURE_MASK_FAVORITE_MENU_BIT_NO = 12;
+    final static int FEATURE_MASK_FAVORITE_MENU_MASK = 0x10;
+    final static int FEATURE_MASK_FAVORITE_MENU_OFFSET = 1;
+
+    final static int FEATURE_MASK_EXIT_BIT_NO = 13;
+    final static int FEATURE_MASK_EXIT_MASK = 0x20;
+    final static int FEATURE_MASK_EXIT_OFFSET = 1;
+
+    final static int FEATURE_MASK_0_BIT_NO = 14;
+    final static int FEATURE_MASK_0_MASK = 0x40;
+    final static int FEATURE_MASK_0_OFFSET = 1;
+
+    final static int FEATURE_MASK_1_BIT_NO = 15;
+    final static int FEATURE_MASK_1_MASK = 0x80;
+    final static int FEATURE_MASK_1_OFFSET = 1;
+
+    final static int FEATURE_MASK_2_BIT_NO = 16;
+    final static int FEATURE_MASK_2_MASK = 0x01;
+    final static int FEATURE_MASK_2_OFFSET = 2;
+
+    final static int FEATURE_MASK_3_BIT_NO = 17;
+    final static int FEATURE_MASK_3_MASK = 0x02;
+    final static int FEATURE_MASK_3_OFFSET = 2;
+
+    final static int FEATURE_MASK_4_BIT_NO = 18;
+    final static int FEATURE_MASK_4_MASK = 0x04;
+    final static int FEATURE_MASK_4_OFFSET = 2;
+
+    final static int FEATURE_MASK_5_BIT_NO = 19;
+    final static int FEATURE_MASK_5_MASK = 0x08;
+    final static int FEATURE_MASK_5_OFFSET = 2;
+
+    final static int FEATURE_MASK_6_BIT_NO = 20;
+    final static int FEATURE_MASK_6_MASK = 0x10;
+    final static int FEATURE_MASK_6_OFFSET = 2;
+
+    final static int FEATURE_MASK_7_BIT_NO = 21;
+    final static int FEATURE_MASK_7_MASK = 0x20;
+    final static int FEATURE_MASK_7_OFFSET = 2;
+
+    final static int FEATURE_MASK_8_BIT_NO = 22;
+    final static int FEATURE_MASK_8_MASK = 0x40;
+    final static int FEATURE_MASK_8_OFFSET = 2;
+
+    final static int FEATURE_MASK_9_BIT_NO = 23;
+    final static int FEATURE_MASK_9_MASK = 0x80;
+    final static int FEATURE_MASK_9_OFFSET = 2;
+
+    final static int FEATURE_MASK_DOT_BIT_NO = 24;
+    final static int FEATURE_MASK_DOT_MASK = 0x01;
+    final static int FEATURE_MASK_DOT_OFFSET = 3;
+
+    final static int FEATURE_MASK_ENTER_BIT_NO = 25;
+    final static int FEATURE_MASK_ENTER_MASK = 0x02;
+    final static int FEATURE_MASK_ENTER_OFFSET = 3;
+
+    final static int FEATURE_MASK_CLEAR_BIT_NO = 26;
+    final static int FEATURE_MASK_CLEAR_MASK = 0x04;
+    final static int FEATURE_MASK_CLEAR_OFFSET = 3;
+
+    final static int FEATURE_MASK_CHNL_UP_BIT_NO = 27;
+    final static int FEATURE_MASK_CHNL_UP_MASK = 0x08;
+    final static int FEATURE_MASK_CHNL_UP_OFFSET = 3;
+
+    final static int FEATURE_MASK_CHNL_DOWN_BIT_NO = 28;
+    final static int FEATURE_MASK_CHNL_DOWN_MASK = 0x10;
+    final static int FEATURE_MASK_CHNL_DOWN_OFFSET = 3;
+
+    final static int FEATURE_MASK_PREV_CHNL_BIT_NO = 29;
+    final static int FEATURE_MASK_PREV_CHNL_MASK = 0x20;
+    final static int FEATURE_MASK_PREV_CHNL_OFFSET = 3;
+
+    final static int FEATURE_MASK_SOUND_SEL_BIT_NO = 30;
+    final static int FEATURE_MASK_SOUND_SEL_MASK = 0x40;
+    final static int FEATURE_MASK_SOUND_SEL_OFFSET = 3;
+
+    final static int FEATURE_MASK_INPUT_SEL_BIT_NO = 31;
+    final static int FEATURE_MASK_INPUT_SEL_MASK = 0x80;
+    final static int FEATURE_MASK_INPUT_SEL_OFFSET = 3;
+
+    final static int FEATURE_MASK_DISP_INFO_BIT_NO = 32;
+    final static int FEATURE_MASK_DISP_INFO_MASK = 0x01;
+    final static int FEATURE_MASK_DISP_INFO_OFFSET = 4;
+
+    final static int FEATURE_MASK_HELP_BIT_NO = 33;
+    final static int FEATURE_MASK_HELP_MASK = 0x02;
+    final static int FEATURE_MASK_HELP_OFFSET = 4;
+
+    final static int FEATURE_MASK_PAGE_UP_BIT_NO = 34;
+    final static int FEATURE_MASK_PAGE_UP_MASK = 0x04;
+    final static int FEATURE_MASK_PAGE_UP_OFFSET = 4;
+
+    final static int FEATURE_MASK_PAGE_DOWN_BIT_NO = 35;
+    final static int FEATURE_MASK_PAGE_DOWN_MASK = 0x08;
+    final static int FEATURE_MASK_PAGE_DOWN_OFFSET = 4;
+
+    final static int FEATURE_MASK_POWER_BIT_NO = 36;
+    final static int FEATURE_MASK_POWER_MASK = 0x10;
+    final static int FEATURE_MASK_POWER_OFFSET = 4;
+
+    final static int FEATURE_MASK_VOL_UP_BIT_NO = 37;
+    final static int FEATURE_MASK_VOL_UP_MASK = 0x20;
+    final static int FEATURE_MASK_VOL_UP_OFFSET = 4;
+
+    final static int FEATURE_MASK_VOL_DOWN_BIT_NO = 38;
+    final static int FEATURE_MASK_VOL_DOWN_MASK = 0x40;
+    final static int FEATURE_MASK_VOL_DOWN_OFFSET = 4;
+
+    final static int FEATURE_MASK_MUTE_BIT_NO = 39;
+    final static int FEATURE_MASK_MUTE_MASK = 0x80;
+    final static int FEATURE_MASK_MUTE_OFFSET = 4;
+
+    final static int FEATURE_MASK_PLAY_BIT_NO = 40;
+    final static int FEATURE_MASK_PLAY_MASK = 0x01;
+    final static int FEATURE_MASK_PLAY_OFFSET = 5;
+
+    final static int FEATURE_MASK_STOP_BIT_NO = 41;
+    final static int FEATURE_MASK_STOP_MASK = 0x02;
+    final static int FEATURE_MASK_STOP_OFFSET = 5;
+
+    final static int FEATURE_MASK_PAUSE_BIT_NO = 42;
+    final static int FEATURE_MASK_PAUSE_MASK = 0x04;
+    final static int FEATURE_MASK_PAUSE_OFFSET = 5;
+
+    final static int FEATURE_MASK_RECORD_BIT_NO = 43;
+    final static int FEATURE_MASK_RECORD_MASK = 0x08;
+    final static int FEATURE_MASK_RECORD_OFFSET = 5;
+
+    final static int FEATURE_MASK_REWIND_BIT_NO = 44;
+    final static int FEATURE_MASK_REWIND_MASK = 0x10;
+    final static int FEATURE_MASK_REWIND_OFFSET = 5;
+
+    final static int FEATURE_MASK_FAST_FWD_BIT_NO = 45;
+    final static int FEATURE_MASK_FAST_FWD_MASK = 0x20;
+    final static int FEATURE_MASK_FAST_FWD_OFFSET = 5;
+
+    final static int FEATURE_MASK_EJECT_BIT_NO = 46;
+    final static int FEATURE_MASK_EJECT_MASK = 0x40;
+    final static int FEATURE_MASK_EJECT_OFFSET = 5;
+
+    final static int FEATURE_MASK_FORWARD_BIT_NO = 47;
+    final static int FEATURE_MASK_FORWARD_MASK = 0x80;
+    final static int FEATURE_MASK_FORWARD_OFFSET = 5;
+
+    final static int FEATURE_MASK_BACKWARD_BIT_NO = 48;
+    final static int FEATURE_MASK_BACKWARD_MASK = 0x01;
+    final static int FEATURE_MASK_BACKWARD_OFFSET = 6;
+
+    final static int FEATURE_MASK_ANGLE_BIT_NO = 49;
+    final static int FEATURE_MASK_ANGLE_MASK = 0x02;
+    final static int FEATURE_MASK_ANGLE_OFFSET = 6;
+
+    final static int FEATURE_MASK_SUBPICTURE_BIT_NO = 50;
+    final static int FEATURE_MASK_SUBPICTURE_MASK = 0x04;
+    final static int FEATURE_MASK_SUBPICTURE_OFFSET = 6;
+
+    final static int FEATURE_MASK_F1_BIT_NO = 51;
+    final static int FEATURE_MASK_F1_MASK = 0x08;
+    final static int FEATURE_MASK_F1_OFFSET = 6;
+
+    final static int FEATURE_MASK_F2_BIT_NO = 52;
+    final static int FEATURE_MASK_F2_MASK = 0x10;
+    final static int FEATURE_MASK_F2_OFFSET = 6;
+
+    final static int FEATURE_MASK_F3_BIT_NO = 53;
+    final static int FEATURE_MASK_F3_MASK = 0x20;
+    final static int FEATURE_MASK_F3_OFFSET = 6;
+
+    final static int FEATURE_MASK_F4_BIT_NO = 54;
+    final static int FEATURE_MASK_F4_MASK = 0x40;
+    final static int FEATURE_MASK_F4_OFFSET = 6;
+
+    final static int FEATURE_MASK_F5_BIT_NO = 55;
+    final static int FEATURE_MASK_F5_MASK = 0x80;
+    final static int FEATURE_MASK_F5_OFFSET = 6;
+
+    final static int FEATURE_MASK_VENDOR_BIT_NO = 56;
+    final static int FEATURE_MASK_VENDOR_MASK = 0x01;
+    final static int FEATURE_MASK_VENDOR_OFFSET = 7;
+
+    final static int FEATURE_MASK_GROUP_NAVI_BIT_NO = 57;
+    final static int FEATURE_MASK_GROUP_NAVI_MASK = 0x02;
+    final static int FEATURE_MASK_GROUP_NAVI_OFFSET = 7;
+
+    final static int FEATURE_MASK_ADV_CTRL_BIT_NO = 58;
+    final static int FEATURE_MASK_ADV_CTRL_MASK = 0x04;
+    final static int FEATURE_MASK_ADV_CTRL_OFFSET = 7;
+
+    final static int FEATURE_MASK_BROWSE_BIT_NO = 59;
+    final static int FEATURE_MASK_BROWSE_MASK = 0x08;
+    final static int FEATURE_MASK_BROWSE_OFFSET = 7;
+
+    final static int FEATURE_MASK_SEARCH_BIT_NO = 60;
+    final static int FEATURE_MASK_SEARCH_MASK = 0x10;
+    final static int FEATURE_MASK_SEARCH_OFFSET = 7;
+
+    final static int FEATURE_MASK_ADD2NOWPLAY_BIT_NO = 61;
+    final static int FEATURE_MASK_ADD2NOWPLAY_MASK = 0x20;
+    final static int FEATURE_MASK_ADD2NOWPLAY_OFFSET = 7;
+
+    final static int FEATURE_MASK_UID_UNIQUE_BIT_NO = 62;
+    final static int FEATURE_MASK_UID_UNIQUE_MASK = 0x40;
+    final static int FEATURE_MASK_UID_UNIQUE_OFFSET = 7;
+
+    final static int FEATURE_MASK_BR_WH_ADDR_BIT_NO = 63;
+    final static int FEATURE_MASK_BR_WH_ADDR_MASK = 0x80;
+    final static int FEATURE_MASK_BR_WH_ADDR_OFFSET = 7;
+
+    final static int FEATURE_MASK_SEARCH_WH_ADDR_BIT_NO = 64;
+    final static int FEATURE_MASK_SEARCH_WH_ADDR_MASK = 0x01;
+    final static int FEATURE_MASK_SEARCH_WH_ADDR_OFFSET = 8;
+
+    final static int FEATURE_MASK_NOW_PLAY_BIT_NO = 65;
+    final static int FEATURE_MASK_NOW_PLAY_MASK = 0x02;
+    final static int FEATURE_MASK_NOW_PLAY_OFFSET = 8;
+
+    final static int FEATURE_MASK_UID_PERSIST_BIT_NO = 66;
+    final static int FEATURE_MASK_UID_PERSIST_MASK = 0x04;
+    final static int FEATURE_MASK_UID_PERSIST_OFFSET = 8;
+
+    final static short FEATURE_BITMASK_FIELD_LENGTH = 16;
+    final static short PLAYER_ID_FIELD_LENGTH = 2;
+    final static short MAJOR_PLAYER_TYPE_FIELD_LENGTH = 1;
+    final static short PLAYER_SUBTYPE_FIELD_LENGTH = 4;
+    final static short PLAY_STATUS_FIELD_LENGTH = 1;
+    final static short CHARSET_ID_FIELD_LENGTH = 2;
+    final static short DISPLAYABLE_NAME_LENGTH_FIELD_LENGTH = 2;
+    final static short ITEM_TYPE_LENGTH = 1;
+    final static short ITEM_LENGTH_LENGTH = 2;
     private native static void classInitNative();
-    private native void initNative();
+    private native void initNative(int maxConnections);
     private native void cleanupNative();
-    private native boolean getPlayStatusRspNative(int playStatus, int songLen, int songPos);
-    private native boolean getElementAttrRspNative(byte numAttr, int[] attrIds, String[] textArray);
-    private native boolean registerNotificationRspPlayStatusNative(int type, int playStatus);
-    private native boolean registerNotificationRspTrackChangeNative(int type, byte[] track);
-    private native boolean registerNotificationRspPlayPosNative(int type, int playPos);
-    private native boolean setVolumeNative(int volume);
-    private native boolean sendPassThroughCommandNative(int keyCode, int keyState);
+    private native boolean getPlayStatusRspNative(int playStatus, int songLen, int
+            songPos, byte[] address);
+    private native boolean getElementAttrRspNative(byte numAttr, int[] attrIds, String[]
+            textArray, byte[] address);
+    private native boolean registerNotificationRspPlayStatusNative(int type, int
+            playStatus, byte[] address);
+    private native boolean registerNotificationRspTrackChangeNative(int type, byte[]
+            track, byte[] address);
+    private native boolean registerNotificationRspPlayPosNative(int type, int
+            playPos, byte[] address);
+    private native boolean setVolumeNative(int volume, byte[] address);
+    private native boolean registerNotificationRspAddressedPlayerChangedNative(
+           int type, int playerId, byte[] address);
+    private native boolean registerNotificationRspAvailablePlayersChangedNative(
+            int type, byte[] address);
+    private native boolean registerNotificationRspNowPlayingContentChangedNative(
+        int type, byte[] address);
+    private native boolean setAdressedPlayerRspNative(byte statusCode, byte[] address);
+    private native boolean getMediaPlayerListRspNative(byte statusCode, int uidCounter,
+                                    int itemCount, byte[] folderItems, int[]
+                                    folderItemLengths, byte[] address);
+    private native boolean getFolderItemsRspNative(byte statusCode, long numItems,
+        int[] itemType, long[] uid, int[] type, byte[] playable, String[] displayName,
+        byte[] numAtt, String[] attValues, int[] attIds, byte[] address);
+    private native boolean getListPlayerappAttrRspNative(byte attr,
+            byte[] attrIds, byte[] address);
+    private native boolean getPlayerAppValueRspNative(byte numberattr,
+            byte[]values, byte[] address );
+    private native boolean SendCurrentPlayerValueRspNative(byte numberattr,
+            byte[]attr, byte[] address );
+    private native boolean SendSetPlayerAppRspNative(int attr_status, byte[] address);
+    private native boolean sendSettingsTextRspNative(int num_attr, byte[] attr,
+        int length, String[]text, byte[] address);
+    private native boolean sendValueTextRspNative(int num_attr, byte[] attr,
+        int length, String[]text, byte[] address);
+    private native boolean registerNotificationPlayerAppRspNative(int type,
+        byte numberattr, byte[]attr, byte[] address);
+    private native boolean setBrowsedPlayerRspNative(byte statusCode, int uidCounter,
+            int itemCount, int folderDepth, int charId, String[] folderItems,
+            byte[] address);
+    private native boolean changePathRspNative(int status, long itemCount, byte[] address);
+    private native boolean playItemRspNative(int status, byte[] address);
+    private native boolean getItemAttrRspNative(byte numAttr, int[] attrIds,
+        String[] textArray, byte[] address);
+    private native boolean isDeviceActiveInHandOffNative(byte[] address);
+
+    /**
+      * A class to encapsulate all the information about a media player.
+      * static record will be maintained for all applicable media players
+      * only the isavailable and isFocussed field will be changed as and when applicable
+      */
+    private class MediaPlayerInfo {
+        private short mPlayerId;
+        private byte mMajorPlayerType;
+        private int mPlayerSubType;
+        private byte mPlayState;
+        private short mCharsetId;
+        private short mDisplayableNameLength;
+        private byte[] mDisplayableName;
+        private String mPlayerPackageName;
+        private boolean mIsAvailable;
+        private boolean mIsFocussed;
+        private byte mItemType;
+        private Metadata mMetadata;
+        private long mTrackNumber;
+        private boolean mIsRemoteAddressable;
+
+        // need to have the featuremask elements as int instead of byte, else MSB would be lost. Later need to take only
+        // 8 applicable bits from LSB.
+        private int[] mFeatureMask;
+        private short mItemLength;
+        private short mEntryLength;
+        public MediaPlayerInfo(short playerId, byte majorPlayerType,
+                    int playerSubType, byte playState, short charsetId,
+                    short displayableNameLength, byte[] displayableName,
+                    String playerPackageName, boolean isRemoteAddressable,
+                    int[] featureMask ) {
+            mPlayerId = playerId;
+            mMajorPlayerType = majorPlayerType;
+            mPlayerSubType = playerSubType;
+            mPlayState = playState;
+            mCharsetId = charsetId;
+            mDisplayableNameLength = displayableNameLength;
+            mPlayerPackageName = playerPackageName;
+            mIsAvailable = false; // by default it is false, its toggled whenever applicable
+            mIsFocussed = false; // by default it is false, its toggled whenever applicable
+            mItemType = ITEM_PLAYER;
+            mFeatureMask = new int[FEATURE_BITMASK_FIELD_LENGTH];
+            mMetadata = new Metadata();
+            mTrackNumber = -1L;
+            mIsRemoteAddressable = isRemoteAddressable;
+            for (int count = 0; count < FEATURE_BITMASK_FIELD_LENGTH; count ++) {
+                mFeatureMask[count] = featureMask[count];
+            }
+
+            mDisplayableName = new byte[mDisplayableNameLength];
+            for (int count = 0; count < mDisplayableNameLength; count ++) {
+                mDisplayableName[count] = displayableName[count];
+            }
+
+            mItemLength = (short)(mDisplayableNameLength + PLAYER_ID_FIELD_LENGTH +
+                MAJOR_PLAYER_TYPE_FIELD_LENGTH + PLAYER_SUBTYPE_FIELD_LENGTH +
+                PLAY_STATUS_FIELD_LENGTH + CHARSET_ID_FIELD_LENGTH +
+                DISPLAYABLE_NAME_LENGTH_FIELD_LENGTH + FEATURE_BITMASK_FIELD_LENGTH);
+            mEntryLength = (short)(mItemLength + /* ITEM_LENGTH_LENGTH +*/ ITEM_TYPE_LENGTH);
+            if (DEBUG) {
+                Log.v(TAG, "MediaPlayerInfo: mPlayerId = " + mPlayerId);
+                Log.v(TAG, "mMajorPlayerType = " + mMajorPlayerType + " mPlayerSubType = "
+                                                                        + mPlayerSubType);
+                Log.v(TAG, "mPlayState = " + mPlayState + " mCharsetId = " + mCharsetId);
+                Log.v(TAG, "mPlayerPackageName = " + mPlayerPackageName +
+                            " mDisplayableNameLength = " + mDisplayableNameLength);
+                Log.v(TAG, "mItemLength = " + mItemLength + " mEntryLength = " + mEntryLength);
+                Log.v(TAG, "mFeatureMask = ");
+                for (int count = 0; count < FEATURE_BITMASK_FIELD_LENGTH; count ++) {
+                    Log.v(TAG, "mFeatureMask[" + count + "] = " + mFeatureMask[count]);
+                }
+                Log.v(TAG, "mDisplayableName=");
+                for (int count = 0; count < mDisplayableNameLength; count ++) {
+                    Log.v(TAG, "mDisplayableName[" + count + "] = " + mDisplayableName[count]);
+                }
+            }
+        }
+
+        public String getPlayerPackageName() {
+            return mPlayerPackageName;
+        }
+
+        public void SetPlayerAvailablility(boolean isAvailable) {
+            mIsAvailable = isAvailable;
+        }
+
+        public void SetPlayerFocus(boolean isFocussed) {
+            mIsFocussed = isFocussed;
+        }
+
+        public boolean GetPlayerAvailablility() {
+            return mIsAvailable;
+        }
+
+        public boolean GetPlayerFocus() {
+            return mIsFocussed;
+        }
+
+        public boolean IsPlayerBrowsable() {
+            if ((mFeatureMask[FEATURE_MASK_BROWSE_OFFSET] & FEATURE_MASK_BROWSE_MASK)
+                                                                                != 0) {
+                Log.v(TAG, "Player ID: " + mPlayerId + "is Browsable!");
+                return true;
+            } else {
+                Log.v(TAG, "Player ID: " + mPlayerId + "is not Browsable!");
+                return false;
+            }
+        }
+
+        public boolean IsPlayerBrowsableWhenAddressed() {
+            if ((mFeatureMask[FEATURE_MASK_BR_WH_ADDR_OFFSET] &
+                                    FEATURE_MASK_BR_WH_ADDR_MASK) != 0) {
+                Log.v(TAG, "Player ID: " + mPlayerId + "is Browsable only when addressed!");
+                return true;
+            } else {
+                Log.v(TAG, "Player ID: " + mPlayerId + "is always Browsable!");
+                return false;
+            }
+        }
+        /*This is set for the players which can be addressed by peer using setAddressedPlayer
+            command*/
+        public boolean IsRemoteAddressable() {
+            return mIsRemoteAddressable;
+        }
+
+        /*below apis are required while seraching for id by package name received from media players*/
+        public short RetrievePlayerId () {
+           return mPlayerId;
+        }
+
+        public String RetrievePlayerPackageName () {
+            return mPlayerPackageName;
+        }
+
+        public int RetrievePlayerEntryLength() {
+            return mEntryLength;
+        }
+
+        public byte[] RetrievePlayerItemEntry () {
+            byte[] playerEntry = new byte[mEntryLength];
+            int position =0;
+            int count;
+            playerEntry[position] = (byte)mItemType; position++;
+            playerEntry[position] = (byte)(mPlayerId & 0xff); position++;
+            playerEntry[position] = (byte)((mPlayerId >> 8) & 0xff); position++;
+            playerEntry[position] = (byte)mMajorPlayerType; position++;
+            for (count = 0; count < PLAYER_SUBTYPE_FIELD_LENGTH; count++) {
+                playerEntry[position] = (byte)((mPlayerSubType >> (8 * count)) & 0xff); position++;
+            }
+            playerEntry[position] = (byte)convertPlayStateToPlayStatus(mPlayState); position++;
+            for (count = 0; count < FEATURE_BITMASK_FIELD_LENGTH; count++) {
+                playerEntry[position] = (byte)mFeatureMask[count]; position++;
+            }
+            playerEntry[position] = (byte)(mCharsetId & 0xff); position++;
+            playerEntry[position] = (byte)((mCharsetId >> 8) & 0xff); position++;
+            playerEntry[position] = (byte)(mDisplayableNameLength & 0xff); position++;
+            playerEntry[position] = (byte)((mDisplayableNameLength >> 8) & 0xff); position++;
+            for (count = 0; count < mDisplayableNameLength; count++) {
+                playerEntry[position] = (byte)mDisplayableName[count]; position++;
+            }
+            if (position != mEntryLength) {
+                Log.e(TAG, "ERROR populating PlayerItemEntry: position:" +  position + "mEntryLength:" + mEntryLength);
+            }
+            if (DEBUG) {
+                Log.v(TAG, "MediaPlayerInfo: mPlayerId=" + mPlayerId);
+                Log.v(TAG, "mMajorPlayerType=" + mMajorPlayerType + " mPlayerSubType=" + mPlayerSubType);
+                Log.v(TAG, "mPlayState=" + mPlayState + " mCharsetId=" + mCharsetId);
+                Log.v(TAG, "mPlayerPackageName=" + mPlayerPackageName + " mDisplayableNameLength=" + mDisplayableNameLength);
+                Log.v(TAG, "mItemLength=" + mItemLength + "mEntryLength=" + mEntryLength);
+                Log.v(TAG, "mFeatureMask=");
+                for (count = 0; count < FEATURE_BITMASK_FIELD_LENGTH; count ++) {
+                    Log.v(TAG, "" + mFeatureMask[count]);
+                }
+                Log.v(TAG, "mDisplayableName=");
+                for (count = 0; count < mDisplayableNameLength; count ++) {
+                    Log.v(TAG, "" + mDisplayableName[count]);
+                }
+                Log.v(TAG, "playerEntry item is populated as below:=");
+                for (count = 0; count < position; count ++) {
+                    Log.v(TAG, "" + playerEntry[count]);
+                }
+            }
+            return playerEntry;
+        }
+    }
+
+    /**
+      * The media player instances
+      */
+    private ArrayList<MediaPlayerInfo> mMediaPlayers = new ArrayList<MediaPlayerInfo>(1);
 
 }
diff --git a/src/com/android/bluetooth/avrcp/AvrcpControllerService.java b/src/com/android/bluetooth/avrcp/AvrcpControllerService.java
index ed426ec..bab1cf2 100644
--- a/src/com/android/bluetooth/avrcp/AvrcpControllerService.java
+++ b/src/com/android/bluetooth/avrcp/AvrcpControllerService.java
@@ -1,4 +1,6 @@
 /*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Not a Contribution
  * Copyright (C) 2014 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -18,35 +20,317 @@ package com.android.bluetooth.avrcp;
 
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothAvrcpController;
+import android.bluetooth.BluetoothAvrcpInfo;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetoothAvrcpController;
+import android.content.BroadcastReceiver;
+import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ContentValues;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.Message;
-import android.util.Log;
+import android.media.AudioManager;
+import android.net.Uri;
+import android.database.Cursor;
 
+import com.android.bluetooth.avrcp.Avrcp.Metadata;
+import com.android.bluetooth.a2dp.A2dpSinkService;
 import com.android.bluetooth.btservice.ProfileService;
 import com.android.bluetooth.Utils;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.HashMap;
-
+import android.util.Log;
+import java.nio.charset.Charset;
+import java.nio.ByteBuffer;
 /**
  * Provides Bluetooth AVRCP Controller profile, as a service in the Bluetooth application.
  * @hide
  */
 public class AvrcpControllerService extends ProfileService {
-    private static final boolean DBG = false;
+    private static final boolean DBG = true;
     private static final String TAG = "AvrcpControllerService";
 
+    //private Context mContext;
+/*
+ *  Messages handled by mHandler
+ */
     private static final int MESSAGE_SEND_PASS_THROUGH_CMD = 1;
+    private static final int MESSAGE_GET_SUPPORTED_COMPANY_ID = 2;
+    private static final int MESSAGE_GET_SUPPORTED_EVENTS = 3;
+    private static final int MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB = 4;
+    private static final int MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES = 5;
+    private static final int MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS = 6;
+    private static final int MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS = 7;
+    private static final int MESSAGE_GET_ELEMENT_ATTRIBUTE = 8;
+    private static final int MESSAGE_GET_PLAY_STATUS = 9;
+    private static final int MESSAGE_DEINIT_AVRCP_DATABASE = 10;
+    private static final int MESSAGE_REGISTER_NOTIFICATION = 11;
+
+    private static final int MESSAGE_CMD_TIMEOUT = 100;
+    /* Timeout Defined as per Spec */
+    private static final int TIMEOUT_MTP = 1000;
+    private static final int TIMEOUT_MTC = 200;
+    private static final int TIMEOUT_RCP = 100;
+    /* we add 1000ms extra */
+    private static final int MSG_TIMEOUT_MTP = 1000 + TIMEOUT_MTP;
+    private static final int MSG_TIMEOUT_MTC = 1000 + TIMEOUT_MTC;
+    private static final int MSG_TIMEOUT_RCP = 1000 + TIMEOUT_RCP;
+    private static final int GET_PLAY_STATUS_INTERVAL = 5000; // every 5sec
+
+
+    private static final int MESSAGE_PROCESS_SUPPORTED_COMPANY_ID = 1002;
+    private static final int MESSAGE_PROCESS_SUPPORTED_EVENTS = 1003;
+    private static final int MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_ATTRIB = 1004;
+    private static final int MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_VALUES = 1005;
+    private static final int MESSAGE_PROCESS_CURRENT_PLAYER_APPLICATION_SETTINGS = 1006;
+    private static final int MESSAGE_PROCESS_ELEMENT_ATTRIBUTE = 1008;
+    private static final int MESSAGE_PROCESS_PLAY_STATUS = 1009;
+    private static final int MESSAGE_REGISTER_PLAYBACK_STATUS_CHANGED = 1010;
+    private static final int MESSAGE_REGISTER_TRACK_CHANGED = 1011;
+    private static final int MESSAGE_REGISTER_PLAYBACK_POS_CHANGED = 1012;
+    private static final int MESSAGE_REGISTER_PLAYER_APPLICATION_SETTINGS_CHANGED = 1013;
+    private static final int MESSAGE_REGISTER_PLAYER_APPLICATION_VOLUME_CHANGED = 1014;
+    private static final int MESSAGE_PROCESS_NOTIFICATION_RESPONSE = 1015;
+    private static final int MESSAGE_PROCESS_SET_ABS_VOL_CMD = 1016;
+    private static final int MESSAGE_PROCESS_REGISTER_ABS_VOL_REQUEST = 1017;
+
+    private static final int MESSAGE_PROCESS_RC_FEATURES = 1100;
+    private static final int MESSAGE_PROCESS_CONNECTION_CHANGE = 1200;
+    private static final int ABORT_FETCH_ELEMENT_ATTRIBUTE = 4000 + MESSAGE_GET_ELEMENT_ATTRIBUTE;
+
+
+/*
+ *  Capability IDs for GetCapabilities
+ */
+    private static final int COMPANY_ID = 2;
+    private static final int EVENTS_SUPPORTED = 3;
+
+    private static final int NOTIFICATION_RSP_TYPE_INTERIM = 0x0f;
+    private static final int NOTIFICATION_RSP_TYPE_CHANGED = 0x0d;
+
+    private static final int PLAYBACK_POS_INTERVAL = 1; // time in seconds
+/*
+ * Constants for Events Supported
+ */
+    private static final byte EVENT_NOTIFICAION_ID_NONE = 0x00;
+    private static final byte EVENT_PLAYBACK_STATUS_CHANGED = 0x01;
+    private static final byte EVENT_TRACK_CHANGED = 0x02;
+    private static final byte EVENT_PLAYBACK_POS_CHANGED = 0x05;
+    private static final byte EVENT_PLAYER_APPLICATION_SETTINGS_CHANGED = 0x08;
+    private static final byte EVENT_VOLUME_CHANGED = 0x0d;
+/*
+ * Timeout values for Events Supported
+ */
+    private static final int MESSAGE_TIMEOUT_PLAYBACK_STATUS_CHANGED = 2001;
+    private static final int MESSAGE_TIMEOUT_TRACK_CHANGED = 2002;
+    private static final int MESSAGE_TIMEOUT_PLAYBACK_POS_CHNAGED = 2005;
+    private static final int MESSAGE_TIMEOUT_APPL_SETTINGS_CHANGED = 2008;
+    private static final int MESSAGE_TIMEOUT_VOLUME_CHANGED = 2013;
+
+
+    private static final byte ATTRIB_EQUALIZER_STATUS = 0x01;
+    private static final byte ATTRIB_REPEAT_STATUS = 0x02;
+    private static final byte ATTRIB_SHUFFLE_STATUS = 0x03;
+    private static final byte ATTRIB_SCAN_STATUS = 0x04;
+
+/*
+ *  EQUALIZER State Values
+ */
+    private static final byte EQUALIZER_STATUS_OFF = 0x01;
+    private static final byte EQUALIZER_STATUS_ON = 0x02;
+
+/*
+ *  REPEAT State Values
+ */
+    private static final byte REPEAT_STATUS_OFF = 0x01;
+    private static final byte REPEAT_STATUS_SINGLE_TRACK_REPEAT = 0x02;
+    private static final byte REPEAT_STATUS_ALL_TRACK_REPEAT = 0x03;
+    private static final byte REPEAT_STATUS_GROUP_REPEAT = 0x04;
+/*
+ *  SHUFFLE State Values
+ */
+    private static final byte SHUFFLE_STATUS_OFF = 0x01;
+    private static final byte SHUFFLE_STATUS_ALL_TRACK_SHUFFLE = 0x02;
+    private static final byte SHUFFLE_STATUS_GROUP_SHUFFLE = 0x03;
+
+/*
+ *  Scan State Values
+ */
+    private static final byte SCAN_STATUS_OFF = 0x01;
+    private static final byte SCAN_STATUS_ALL_TRACK_SCAN = 0x02;
+    private static final byte SCAN_STATUS_GROUP_SCAN = 0x03;
+
+/*
+ *  Play State Values
+ */
+    private static final byte PLAY_STATUS_STOPPED = 0x00;
+    private static final byte PLAY_STATUS_PLAYING = 0x01;
+    private static final byte PLAY_STATUS_PAUSED = 0x02;
+    private static final byte PLAY_STATUS_FWD_SEEK = 0x03;
+    private static final byte PLAY_STATUS_REV_SEEK = 0x04;
+/*
+ *  values possible for notify_state
+ */
+    private static final byte NOTIFY_NOT_NOTIFIED = 0x01;
+    private static final byte NOTIFY_INTERIM_EXPECTED = 0x02;
+    private static final byte NOTIFY_CHANGED_EXPECTED = 0x03;
+    /*
+     * For Absolute volume we are in a TG role.
+     * Where we will receive notification and we have
+     * to send an interim/Chnaged response. So keeping
+     * those states seperate.
+     * Also we shld not send Chnaged response if change
+     * in volume  is because of setabsvol command send from
+     * remote.
+     */
+    private static final byte NOTIFY_NOT_REGISTERED = 0x01;
+    private static final byte NOTIFY_RSP_INTERIM_SENT = 0x02;
+    private static final byte NOTIFY_RSP_ABS_VOL_DEFERRED = 0x03;
+
+/*
+ *  Constants for GetElement Attribute
+ */
+    private static final int MEDIA_ATTRIBUTE_ALL = 0x00;
+    private static final int MEDIA_ATTRIBUTE_TITLE = 0x01;
+    private static final int MEDIA_ATTRIBUTE_ARTIST_NAME = 0x02;
+    private static final int MEDIA_ATTRIBUTE_ALBUM_NAME = 0x03;
+    private static final int MEDIA_ATTRIBUTE_TRACK_NUMBER = 0x04;
+    private static final int MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER = 0x05;
+    private static final int MEDIA_ATTRIBUTE_GENRE = 0x06;
+    private static final int MEDIA_ATTRIBUTE_PLAYING_TIME = 0x07;
+
+    private static final int MEDIA_PLAYSTATUS_ALL = 0x08;
+    private static final int MEDIA_PLAYSTATUS_SONG_TOTAL_LEN = 0x09;
+    private static final int MEDIA_PLAYSTATUS_SONG_CUR_POS = 0x0a;
+    private static final int MEDIA_PLAYSTATUS_SONG_PLAY_STATUS = 0x0b;
+    private static final int MEDIA_PLAYER_APPLICAITON_SETTING = 0x0c;
+
+    /*
+     * Timeout values for GetElement Attribute
+     */
+    private static final int GET_ELEMENT_ATTR_TIMEOUT_BASE = 3000;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_TITLE =
+                             GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_TITLE;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_ARTIST_NAME =
+                       GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_ARTIST_NAME;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_ALBUM_NAME =
+                        GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_ALBUM_NAME;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_TRACK_NUMBER =
+                      GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_TRACK_NUMBER;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_TOTAL_TRACK_NUMBER =
+                 GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_GENRE =
+                              GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_GENRE;
+    private static final int MESSAGE_TIMEOUT_ATTRIBUTE_PLAYING_TIME =
+                       GET_ELEMENT_ATTR_TIMEOUT_BASE + MEDIA_ATTRIBUTE_PLAYING_TIME;
+
+    private static final int ATTRIBUTE_FETCH_CONTINUE = 0;
+    private static final int ATTRIBUTE_FETCH_FRESH = 1; // discard all if we are already fetching
+    private static final int ATTRIBUTE_FETCH_SKIP = 3;// discard only current one
+
+    /* AVRCP Rsp Status */
+    private static final int  AVRC_RSP_NOT_IMPL =  8;
+    private static final int  AVRC_RSP_ACCEPT   =  9;
+    private static final int  AVRC_RSP_REJ      =  10;
+    private static final int  AVRC_RSP_IN_TRANS =  11;
+    private static final int  AVRC_RSP_IMPL_STBL = 12;
+    private static final int  AVRC_RSP_CHANGED  =  13;
+    private static final int  AVRC_RSP_INTERIM  =  15;
+
+    /*
+     * AVRCP Key event
+     */
+    public static final int AVRC_ID_PLAY = 0x44;
+    public static final int AVRC_ID_PAUSE = 0x46;
+    public static final int AVRC_ID_STOP = 0x45;
+    public static final int AVRC_ID_FF = 0x49;
+    public static final int AVRC_ID_REWIND = 0x48;
+    public static final int AVRC_ID_FORWARD = 0x4B;
+    public static final int AVRC_ID_BACKWARD = 0x4C;
+    public static final int AVRC_ID_VOL_UP = 0x41;
+    public static final int AVRC_ID_VOL_DOWN = 0x42;
+
+    public static final int ABS_VOL_BASE = 127;
+/*
+ *  Constant Variables Defined
+ */
+    private final int BTSIG_COMPANY_ID = 0x001958;
+
+    public static final int BTRC_FEAT_METADATA = 0x01;
+    public static final int BTRC_FEAT_ABSOLUTE_VOLUME = 0x02;
+    public static final int BTRC_FEAT_BROWSE = 0x04;
+
+    private class PlayerSettings
+    {
+        public byte attr_Id;
+        public byte attr_val;
+        public byte [] supported_values;
+    };
+    private class NotifyEvents
+    {
+        public byte notify_event_id; // these values will be one of Supported Events
+        public byte notify_state; // Current State of Notification
+    };
+    private class Metadata {
+        private String artist;
+        private String trackTitle;
+        private String albumTitle;
+        private String genre;
+        private long trackNum;
+        private long totalTrackNum;
+        private byte playStatus;
+        private long playTime;
+        private long totalTrackLen;
+        private int attributesFetchedId;
+
+        public Metadata() {
+            resetMetaData();
+        }
+       public void resetMetaData() {
+           artist = BluetoothAvrcpInfo.ARTIST_NAME_INVALID;
+           trackTitle = BluetoothAvrcpInfo.TITLE_INVALID;
+           albumTitle = BluetoothAvrcpInfo.ALBUM_NAME_INVALID;
+           genre = BluetoothAvrcpInfo.GENRE_INVALID;
+           trackNum = BluetoothAvrcpInfo.TRACK_NUM_INVALID;
+           totalTrackNum = BluetoothAvrcpInfo.TOTAL_TRACKS_INVALID;
+           playStatus = PLAY_STATUS_STOPPED;
+           playTime = BluetoothAvrcpInfo.PLAYING_TIME_INVALID;
+           totalTrackLen = BluetoothAvrcpInfo.TOTAL_TRACK_TIME_INVALID;
+           attributesFetchedId = -1; // id of the attribute being fetched, initialized by -1
+       }
+        public String toString() {
+            return "Metadata [artist=" + artist + " trackTitle= " + trackTitle + " albumTitle= " +
+            albumTitle + " genre= " +genre+" trackNum= "+Long.toString(trackNum) + " cur_time: "+
+            Long.toString(playTime)  + " total_time = "+ Long.toString(totalTrackLen) +
+            "playStatus=" + playStatus + "]";
+        }
+    };
+
+    private final class RemoteAvrcpData {
+        private ArrayList <Integer> mCompanyIDSupported; // company ID
+        private ArrayList <Byte> mEventsSupported;
+        private ArrayList <PlayerSettings> mSupportedApplicationSettingsAttribute;
+        private ArrayList <NotifyEvents> mNotifyEvent;
+        private Metadata mMetadata;
+        int mRemoteFeatures;
+        int absVolNotificationState;
+        int playerSettingAttribIdFetch;
+    };
+
+    RemoteAvrcpData mRemoteData;
+    int[] requestedElementAttribs;
 
     private AvrcpMessageHandler mHandler;
     private static AvrcpControllerService sAvrcpControllerService;
+    private static AudioManager mAudioManager;
+    private static boolean mDbInitialized = false;
 
     private final ArrayList<BluetoothDevice> mConnectedDevices
             = new ArrayList<BluetoothDevice>();
@@ -64,6 +348,7 @@ public class AvrcpControllerService extends ProfileService {
     }
 
     protected IProfileServiceBinder initBinder() {
+        Log.d(TAG," initBinder Called ");
         return new BluetoothAvrcpControllerBinder(this);
     }
 
@@ -72,25 +357,83 @@ public class AvrcpControllerService extends ProfileService {
         thread.start();
         Looper looper = thread.getLooper();
         mHandler = new AvrcpMessageHandler(looper);
-
+        mRemoteData = null;
         setAvrcpControllerService(this);
+        mAudioManager = (AudioManager)sAvrcpControllerService.
+                                  getSystemService(Context.AUDIO_SERVICE);
+        IntentFilter filter = new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION);
+        registerReceiver(mBroadcastReceiver, filter);
         return true;
     }
 
     protected boolean stop() {
+        unregisterReceiver(mBroadcastReceiver);
+         try {
+             deinitDatabase();
+             if (mRemoteData != null) {
+                 mRemoteData.mCompanyIDSupported.clear();
+                 mRemoteData.mEventsSupported.clear();
+                 mRemoteData.mMetadata.resetMetaData();
+                 mRemoteData.mNotifyEvent.clear();
+                 mRemoteData.mSupportedApplicationSettingsAttribute.clear();
+                 mRemoteData.absVolNotificationState = NOTIFY_NOT_REGISTERED;
+                 mRemoteData.mRemoteFeatures = 0;
+                 Log.d(TAG," RC_features, STOP " + mRemoteData.mRemoteFeatures);
+                 mRemoteData.playerSettingAttribIdFetch = 0;
+                 mRemoteData = null;
+             }
+         } catch (Exception e) {
+             Log.e(TAG, "Cleanup failed", e);
+         }
         return true;
     }
-
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (action.equals(AudioManager.VOLUME_CHANGED_ACTION)) {
+                int streamType = intent.getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, -1);
+                if (streamType == AudioManager.STREAM_MUSIC) {
+                    int streamValue = intent
+                            .getIntExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, -1);
+                    int streamPrevValue = intent.getIntExtra(
+                            AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, -1);
+                    if (streamValue != -1 && streamValue != streamPrevValue) {
+                        if ((mRemoteData == null)
+                            ||((mRemoteData.mRemoteFeatures & BTRC_FEAT_ABSOLUTE_VOLUME) == 0)
+                            ||(mConnectedDevices.isEmpty()))
+                            return;
+                        if(mRemoteData.absVolNotificationState == NOTIFY_RSP_INTERIM_SENT) {
+                            int maxVol = mAudioManager.
+                                                  getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+                            int currIndex = mAudioManager.
+                                                  getStreamVolume(AudioManager.STREAM_MUSIC);
+                            int percentageVol = ((currIndex*ABS_VOL_BASE)/maxVol);
+                            byte rspType = NOTIFICATION_RSP_TYPE_CHANGED;
+                            Log.d(TAG," Abs Vol Notify Rsp Changed val = "+ percentageVol);
+                            mRemoteData.absVolNotificationState = NOTIFY_NOT_REGISTERED;
+                            sendRegisterAbsVolRspNative(rspType,percentageVol);
+                        }
+                        else if (mRemoteData.absVolNotificationState == NOTIFY_RSP_ABS_VOL_DEFERRED) {
+                            Log.d(TAG," Don't Complete Notification Rsp. ");
+                            mRemoteData.absVolNotificationState = NOTIFY_RSP_INTERIM_SENT;
+                        }
+                    }
+                }
+            }
+        }
+    };
     protected boolean cleanup() {
         if (mHandler != null) {
             mHandler.removeCallbacksAndMessages(null);
             Looper looper = mHandler.getLooper();
             if (looper != null) looper.quit();
+            if (looper != null) {
+                looper.quit();
+            }
         }
-
         clearAvrcpControllerService();
         cleanupNative();
-
         return true;
     }
 
@@ -158,12 +501,356 @@ public class AvrcpControllerService extends ProfileService {
         if (device == null) {
             throw new NullPointerException("device == null");
         }
-        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-        Message msg = mHandler.obtainMessage(MESSAGE_SEND_PASS_THROUGH_CMD,
+        if (!(mConnectedDevices.contains(device))) {
+            Log.d(TAG," Device does not match");
+            return;
+        }
+        if ((mRemoteData == null)||(mRemoteData.mMetadata == null)) {
+            Log.d(TAG," Device connected but PlayState not present ");
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            Message msg = mHandler.obtainMessage(MESSAGE_SEND_PASS_THROUGH_CMD,
+                    keyCode, keyState, device);
+            mHandler.sendMessage(msg);
+            return;
+        }
+        boolean sendCommand = false;
+        switch(keyCode) {
+            case AVRC_ID_PLAY:
+                sendCommand  = (mRemoteData.mMetadata.playStatus == PLAY_STATUS_STOPPED)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PAUSED);
+                break;
+            case AVRC_ID_PAUSE:
+                sendCommand  = (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PLAYING)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_FWD_SEEK)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PAUSED)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_STOPPED)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_REV_SEEK);
+                break;
+            case AVRC_ID_STOP:
+                sendCommand  = (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PLAYING)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_FWD_SEEK)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_REV_SEEK)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_STOPPED)||
+                               (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PAUSED);
+                break;
+            case AVRC_ID_VOL_DOWN:
+            case AVRC_ID_VOL_UP:
+            case AVRC_ID_BACKWARD:
+            case AVRC_ID_FORWARD:
+            case AVRC_ID_FF:
+            case AVRC_ID_REWIND:
+                sendCommand = true; // we can send this command in all states
+                break;
+        }
+        if (sendCommand) {
+            enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+            Message msg = mHandler.obtainMessage(MESSAGE_SEND_PASS_THROUGH_CMD,
                 keyCode, keyState, device);
+            mHandler.sendMessage(msg);
+        }
+        else {
+            Log.e(TAG," Not in right state, don't send Pass Thru cmd ");
+        }
+    }
+    public void getMetaData(int[] attributeIds) {
+        Log.d(TAG, "num getMetaData = "+ attributeIds.length);
+        if (mRemoteData == null) {
+            return;
+        }
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        /*
+         * Check if GetElementAttribute is in progress
+         * Check if it already does not contain all Attributes
+         * If it is, append any missing attribute
+         */
+        if ((mRemoteData.mMetadata.attributesFetchedId != -1) &&
+           (requestedElementAttribs != null)&&
+           (requestedElementAttribs.length < 7)) {
+
+            int currAttributeId =
+                      requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId];
+            if (mHandler.hasMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + currAttributeId)) {
+                mHandler.removeMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + currAttributeId);
+                Log.d(TAG," Timeout CMD dequeued ID " + currAttributeId);
+            }
+            mHandler.sendEmptyMessage(ABORT_FETCH_ELEMENT_ATTRIBUTE);
+            requestedElementAttribs = Arrays.copyOf(attributeIds, attributeIds.length);
+            return;
+        }
+        else if ((attributeIds.length >= 0)&&(attributeIds[0] != MEDIA_ATTRIBUTE_ALL)) {
+            /* Subset sent by App, use them */
+            requestedElementAttribs = Arrays.copyOf(attributeIds, attributeIds.length);
+        }
+        else {
+            /* Use SuperSet */
+            requestedElementAttribs = new int [7];
+            for (int xx = 0; xx < 7; xx++)
+               requestedElementAttribs[xx] = xx+1;
+        }
+        Arrays.sort(requestedElementAttribs);
+        boolean mMetaDataPresent = true;
+        for (int attributeId: requestedElementAttribs) {
+            if (!isMetaDataPresent(attributeId)) {
+                mMetaDataPresent = false;
+                break;
+            }
+        }
+        Log.d(TAG," MetaDataPresent " + mMetaDataPresent);
+        if(mMetaDataPresent)
+            triggerNotification();
+        else
+            mHandler.sendEmptyMessage(MESSAGE_GET_ELEMENT_ATTRIBUTE);
+    }
+    public void getPlayStatus(int[] playStatusIds) {
+        if (DBG) Log.d(TAG, "num getPlayStatus ID = "+ playStatusIds.length);
+        if (mRemoteData == null) {
+            return;
+        }
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        int[] getApRequestedPlayStatusAttrib;
+        if ((playStatusIds.length >= 0)&&(playStatusIds[0] != MEDIA_PLAYSTATUS_ALL)) {
+            /* Subset sent by App, use them */
+            getApRequestedPlayStatusAttrib = Arrays.copyOf(playStatusIds, playStatusIds.length);
+        }
+        else {
+            /* Use SuperSet */
+            getApRequestedPlayStatusAttrib = new int [3];
+            for (int xx = 0; xx < 3; xx++)
+                getApRequestedPlayStatusAttrib[xx] = 9 + xx;
+        }
+        Arrays.sort(getApRequestedPlayStatusAttrib);
+        boolean mMetaDataPresent = true;
+        for (int attributeId: getApRequestedPlayStatusAttrib) {
+            if (!isMetaDataPresent(attributeId)) {
+                mMetaDataPresent = false;
+                break;
+            }
+        }
+        if(mMetaDataPresent)
+            triggerNotification();
+        else {
+            Log.d(TAG," Metadata not present");
+            mHandler.sendEmptyMessage(MESSAGE_GET_PLAY_STATUS);
+        }
+    }
+    public void getPlayerApplicationSetting() {
+        if (DBG) Log.d(TAG, "getPlayerApplicationSetting ");
+        if (mRemoteData == null) {
+            return;
+        }
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        if(isMetaDataPresent(MEDIA_PLAYER_APPLICAITON_SETTING)) {
+            triggerNotification();
+        }
+        else {
+            Log.d(TAG," Metadata not present, fetch it");
+            mHandler.sendEmptyMessage(MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+        }
+    }
+    public void setPlayerApplicationSetting(int attributeId, int attributeVal) {
+        if (mRemoteData == null) {
+            return;
+        }
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        Message msg = mHandler.obtainMessage(MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS,
+                                                                     attributeId, attributeVal);
         mHandler.sendMessage(msg);
     }
+    public BluetoothAvrcpInfo getSupportedPlayerAppSetting(BluetoothDevice device) {
+        if((mRemoteData == null)||(mRemoteData.mSupportedApplicationSettingsAttribute.isEmpty())
+                                ||(!mConnectedDevices.contains(device)))
+            return null;
+        byte[] attribIds = new byte[mRemoteData.mSupportedApplicationSettingsAttribute.size()];
+        byte[] numAttribVals = new byte[mRemoteData.mSupportedApplicationSettingsAttribute.size()];
+        ArrayList<Byte> supportedVals = new ArrayList<Byte>();
+        int index = 0;
+        for (PlayerSettings plSetting: mRemoteData.mSupportedApplicationSettingsAttribute) {
+            attribIds[index] = plSetting.attr_Id;
+            numAttribVals[index] = Integer.valueOf(plSetting.supported_values.length).byteValue();
+            for (int xx = 0; xx < numAttribVals[index]; xx++)
+                supportedVals.add(plSetting.supported_values[xx]);
+            index++;
+        }
+        byte[] supportedPlSettingsVals = new byte[supportedVals.size()];
+        for (int zz = 0; zz < supportedVals.size(); zz++)
+            supportedPlSettingsVals[zz] = supportedVals.get(zz);
+        if ((attribIds == null)||(numAttribVals == null)||(supportedPlSettingsVals == null)||
+           (attribIds.length == 0)||(numAttribVals.length == 0))
+            return null;
+        BluetoothAvrcpInfo btAvrcpMetaData = new BluetoothAvrcpInfo(attribIds,
+                                        numAttribVals, supportedPlSettingsVals);
+        return btAvrcpMetaData;
+    }
+    public int getSupportedFeatures(BluetoothDevice device) {
+        if (!mConnectedDevices.contains(device)||(mRemoteData == null)) {
+            Log.e(TAG," req Device " + device + " Internal List " + mConnectedDevices.get(0));
+            Log.e(TAG," remoteData " + mRemoteData);
+            if (mRemoteData != null)
+            Log.e(TAG," getSupportedFeatures returning  from here "+ mRemoteData.mRemoteFeatures);
+            return 0;
+        }
+        Log.d(TAG," getSupportedFeatures returning " + mRemoteData.mRemoteFeatures);
+        return mRemoteData.mRemoteFeatures;
+    }
+    private void triggerNotification() {
+        Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
+        sAvrcpControllerService.getContentResolver().notifyChange(avrcpDataUri, null);
+    }
+    private boolean isMetaDataPresent(int attributeId) {
+        Uri avrcpDataUri = BluetoothAvrcpInfo.CONTENT_URI;
+        Cursor cursor = sAvrcpControllerService.getContentResolver().query(avrcpDataUri,
+                                               null, null, null,BluetoothAvrcpInfo._ID);
+        if ((cursor == null) || (!cursor.moveToFirst())) {
+            Log.d(TAG," isMetaDataPresent cursor not valid, returing");
+            /*Fix for below klockworks issue */
+            /*Sql object 'cursor' is not closed on exit*/
+            if (cursor != null)
+               cursor.close();
+            return false;
+        }
+        int index = 0;
+        boolean metaDataPresent = false;
+        switch(attributeId)
+        {
+        case MEDIA_ATTRIBUTE_ALBUM_NAME:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.ALBUM_NAME);
+            if(cursor.getString(index) !=
+                BluetoothAvrcpInfo.ALBUM_NAME_INVALID)
+                metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_ARTIST_NAME:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.ARTIST_NAME);
+            if(cursor.getString(index) !=
+                BluetoothAvrcpInfo.ARTIST_NAME_INVALID)
+                metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_GENRE:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.GENRE);
+            if(cursor.getString(index) !=
+                BluetoothAvrcpInfo.GENRE_INVALID)
+                metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_TITLE:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TITLE);
+            if(cursor.getString(index) !=
+                BluetoothAvrcpInfo.TITLE_INVALID)
+                metaDataPresent = true;
+            break;
+        case MEDIA_PLAYSTATUS_SONG_CUR_POS:
+        case MEDIA_ATTRIBUTE_PLAYING_TIME:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAYING_TIME);
+            if(cursor.getInt(index) !=
+                    BluetoothAvrcpInfo.PLAYING_TIME_INVALID)
+                    metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACKS);
+            if(cursor.getInt(index) !=
+                    BluetoothAvrcpInfo.TOTAL_TRACKS_INVALID)
+                    metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_TRACK_NUMBER:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TRACK_NUM);
+            if(cursor.getInt(index) !=
+                    BluetoothAvrcpInfo.TRACK_NUM_INVALID)
+                    metaDataPresent = true;
+            break;
+        case MEDIA_ATTRIBUTE_ALL: // check all attribute
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TRACK_NUM);
+            if(cursor.getInt(index) ==
+                    BluetoothAvrcpInfo.TRACK_NUM_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACKS);
+            if(cursor.getInt(index) ==
+                    BluetoothAvrcpInfo.TOTAL_TRACKS_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAYING_TIME);
+            if(cursor.getInt(index) ==
+                    BluetoothAvrcpInfo.PLAYING_TIME_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TITLE);
+            if(cursor.getString(index) ==
+                BluetoothAvrcpInfo.TITLE_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.GENRE);
+            if(cursor.getString(index) ==
+                BluetoothAvrcpInfo.GENRE_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.ARTIST_NAME);
+            if(cursor.getString(index) ==
+                BluetoothAvrcpInfo.ARTIST_NAME_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.ALBUM_NAME);
+            if(cursor.getString(index) ==
+                BluetoothAvrcpInfo.ALBUM_NAME_INVALID)
+                break;
 
+            metaDataPresent = true;
+            break;
+        case MEDIA_PLAYSTATUS_SONG_PLAY_STATUS:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAY_STATUS);
+            if(cursor.getString(index) !=
+                    BluetoothAvrcpInfo.PLAY_STATUS_INVALID)
+                    metaDataPresent = true;
+            break;
+        case MEDIA_PLAYSTATUS_SONG_TOTAL_LEN:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACK_TIME);
+            if(cursor.getInt(index) !=
+                    BluetoothAvrcpInfo.TOTAL_TRACK_TIME_INVALID)
+                    metaDataPresent = true;
+            break;
+        case MEDIA_PLAYSTATUS_ALL:
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.PLAY_STATUS);
+            if(cursor.getString(index) ==
+                    BluetoothAvrcpInfo.PLAY_STATUS_INVALID)
+                break;
+            index = cursor.getColumnIndex(BluetoothAvrcpInfo.TOTAL_TRACK_TIME);
+            if(cursor.getInt(index) ==
+                    BluetoothAvrcpInfo.TOTAL_TRACK_TIME_INVALID)
+                break;
+
+            metaDataPresent = true;
+            break;
+        case MEDIA_PLAYER_APPLICAITON_SETTING:
+            boolean plSettingSupported = true;
+            for (PlayerSettings plSetting: mRemoteData.mSupportedApplicationSettingsAttribute) {
+                switch(plSetting.attr_Id)
+                {
+                case ATTRIB_REPEAT_STATUS:
+                    index = cursor.getColumnIndex(BluetoothAvrcpInfo.REPEAT_STATUS);
+                    if(cursor.getString(index) ==
+                        BluetoothAvrcpInfo.REPEAT_STATUS_INVALID)
+                        plSettingSupported = false;
+                    break;
+                case ATTRIB_EQUALIZER_STATUS:
+                    index = cursor.getColumnIndex(BluetoothAvrcpInfo.EQUALIZER_STATUS);
+                    if(cursor.getString(index) ==
+                        BluetoothAvrcpInfo.EQUALIZER_STATUS_INVALID)
+                        plSettingSupported = false;
+                    break;
+                case ATTRIB_SCAN_STATUS:
+                    index = cursor.getColumnIndex(BluetoothAvrcpInfo.SCAN_STATUS);
+                    if(cursor.getString(index) ==
+                        BluetoothAvrcpInfo.SCAN_STATUS_INVALID)
+                        plSettingSupported = false;
+                    break;
+                case ATTRIB_SHUFFLE_STATUS:
+                    index = cursor.getColumnIndex(BluetoothAvrcpInfo.SHUFFLE_STATUS);
+                    if(cursor.getString(index) ==
+                        BluetoothAvrcpInfo.SHUFFLE_STATUS_INVALID)
+                        plSettingSupported = false;
+                    break;
+                }
+                if(!plSettingSupported)
+                    break;
+            }
+            metaDataPresent = plSettingSupported;
+            break;
+        }
+        cursor.close();
+        Log.d(TAG," returning " + metaDataPresent + "for attrib " + attributeId);
+        return metaDataPresent;
+    }
     //Binder object: Must be static class or memory leak may occur
     private static class BluetoothAvrcpControllerBinder extends IBluetoothAvrcpController.Stub
         implements IProfileServiceBinder {
@@ -214,8 +901,744 @@ public class AvrcpControllerService extends ProfileService {
             if (service == null) return;
             service.sendPassThroughCmd(device, keyCode, keyState);
         }
+
+        public void getMetaData(int[] attributeIds) {
+            Log.v(TAG,"Binder Call: num getMetaData ID = "+ attributeIds.length);
+            AvrcpControllerService service = getService();
+            if (service == null) return;
+            service.getMetaData(attributeIds);
+        }
+        public void getPlayStatus(int[] playStatusIds) {
+            Log.v(TAG,"Binder Call: num getPlayStatus ID = "+ playStatusIds.length);
+            AvrcpControllerService service = getService();
+            if (service == null) return;
+            service.getPlayStatus(playStatusIds);
+        }
+        public void getPlayerApplicationSetting() {
+            Log.v(TAG,"Binder Call: getPlayerApplicationSetting ");
+            AvrcpControllerService service = getService();
+            if (service == null) return;
+            service.getPlayerApplicationSetting();
+        }
+        public void setPlayerApplicationSetting(int attributeId, int attributeVal) {
+            Log.v(TAG,"Binder Call: setPlayerApplicationSetting ID = "
+                              + attributeId +" attributeVal ="+ attributeVal);
+            AvrcpControllerService service = getService();
+            if (service == null) return;
+            service.setPlayerApplicationSetting(attributeId, attributeVal);
+        }
+        public BluetoothAvrcpInfo getSupportedPlayerAppSetting(BluetoothDevice device) {
+            Log.v(TAG,"Binder Call: getSupportedPlayerAppSetting Dev = " + device);
+            AvrcpControllerService service = getService();
+            if (service == null) return null;
+            return service.getSupportedPlayerAppSetting(device);
+        }
+        public int getSupportedFeatures(BluetoothDevice device) {
+            Log.v(TAG,"Binder Call: getSupportedFeatures Dev = " + device);
+            AvrcpControllerService service = getService();
+            if (service == null) return 0;
+            return service.getSupportedFeatures(device);
+        }
     };
 
+    private void getSupportedCapabilities(int capability_id)
+    {
+       Message msg = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,0,0,capability_id);
+       mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+       getCapabilitiesNative(capability_id);
+    }
+    private void getPlayerApplicationSettingsAttrib()
+    {
+        Message msg = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,
+                                 0,0,MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+        mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+        listPlayerApplicationSettingAttributeNative();
+    }
+    private void getCurrentPlayerApplicationSettingsValues()
+    {
+        int count = 0;
+        if ((mRemoteData == null)||
+            (mRemoteData.mSupportedApplicationSettingsAttribute == null)||
+            (mRemoteData.mSupportedApplicationSettingsAttribute.size() == 0)) {
+            Log.w(TAG," PlayerAppSettings not supporterd, returning");
+            return;
+        }
+        byte[] supported_attrib =
+            new byte[mRemoteData.mSupportedApplicationSettingsAttribute.size()];
+        byte numAttrib = Byte.valueOf((Integer.valueOf
+                    (mRemoteData.mSupportedApplicationSettingsAttribute.size())).byteValue());
+        for (PlayerSettings plSetting: mRemoteData.mSupportedApplicationSettingsAttribute)
+        {
+            supported_attrib[count++] = plSetting.attr_Id;
+        }
+        Message msg = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,
+                          0,0,MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+        mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+        getPlayerApplicationSettingValuesNative(numAttrib,supported_attrib);
+    }
+    private void setCurrentPlayerApplicationSettingsValues(int attribId, int attribVal)
+    {
+        Message msg = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,
+                                   0,0,MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+        mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+        byte numAttrib = 1;
+        byte[] attributeId = new byte[1];
+        byte[] attributeVal = new byte[1];
+        attributeId[0] = (byte)attribId;
+        attributeVal[0] = (byte)attribVal;
+        setPlayerApplicationSettingValuesNative(numAttrib, attributeId, attributeVal);
+    }
+    private void getFurtherElementAttribute(int operationId)
+    {
+        if ((requestedElementAttribs == null)||(requestedElementAttribs.length == 0))
+        {
+            Log.d(TAG," Applicaiton has not yet requested element attributes");
+            return;
+        }
+        Log.d(TAG," getFurtherElementAttribute  op_Id = "
+                 + operationId + " requestedIdLen = " + requestedElementAttribs.length);
+        byte numAttrib = 1;
+        if (operationId == ATTRIBUTE_FETCH_FRESH)
+            mRemoteData.mMetadata.attributesFetchedId = 0;  // reset fetched_id
+        else if ((operationId == ATTRIBUTE_FETCH_SKIP)||(operationId == ATTRIBUTE_FETCH_CONTINUE))
+            mRemoteData.mMetadata.attributesFetchedId += 1;  // skip this one, fetch next
+        if (mRemoteData.mMetadata.attributesFetchedId >= requestedElementAttribs.length)
+        {
+            /*
+             * we reached to last attribute. Update database now
+             */
+            mRemoteData.mMetadata.attributesFetchedId = -1;
+            updateElementAttribute();
+            mHandler.sendEmptyMessage(MESSAGE_GET_PLAY_STATUS);
+            return;
+        }
+        Message msg = mHandler.obtainMessage(GET_ELEMENT_ATTR_TIMEOUT_BASE
+                + requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId]);
+        mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+        Log.d(TAG," getElemAttrReq numAttr "+ numAttrib + " Id "
+             + requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId]);
+        getElementAttributeNative(numAttrib,
+                  requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId]);
+    }
+    private void getFurtherPlayerSettingAttrib(int operationId)
+    {
+        Log.d(TAG," getFurtherPlayerSettingAttrib  Id = " + operationId);
+        if (mRemoteData == null)
+            return;
+        if (operationId == ATTRIBUTE_FETCH_FRESH)
+            mRemoteData.playerSettingAttribIdFetch = 0;
+        else if(operationId == ATTRIBUTE_FETCH_SKIP)
+            mRemoteData.playerSettingAttribIdFetch ++;
+        int fetch_id = mRemoteData.playerSettingAttribIdFetch;
+        if (fetch_id >= mRemoteData.mSupportedApplicationSettingsAttribute.size())
+        {
+            Log.d(TAG," All Attrib Fetched " + fetch_id);
+            mHandler.sendEmptyMessage(MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+            return;
+        }
+        Log.d(TAG," fetching_id = " + fetch_id);
+        Message msg = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,
+                             0,0,MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES);
+        mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+        listPlayerApplicationSettingValueNative(mRemoteData.
+                   mSupportedApplicationSettingsAttribute.get(fetch_id).attr_Id);
+    }
+    /*
+     * Api to register notification.
+     * exemptNotificaionId = notificaiton ID for which notification will not be sent.
+     * in case of we have other notifications to be sent we will do nothing for
+     * exemptedID. In case exemptedId is the only one left we will send notification
+     * request for this one.
+     */
+    private void registerFurtherNotification(int exemptNotificaionId)
+    {
+        Log.d(TAG," ExemptedNotificationId " + exemptNotificaionId);
+        /*
+         * check through the list and send notification
+         * request if state is not waiting for changed
+         */
+        boolean notificationSent = false;
+        Message msg;
+        for (NotifyEvents notifyEvent: mRemoteData.mNotifyEvent)
+        {
+            Log.d(TAG," ID = " + notifyEvent.notify_event_id + " state = "
+                                                   + notifyEvent.notify_state);
+            if (notifyEvent.notify_event_id == exemptNotificaionId)
+                continue;
+            if (notifyEvent.notify_state == NOTIFY_NOT_NOTIFIED)
+            {
+                notificationSent = true;
+                notifyEvent.notify_state = NOTIFY_INTERIM_EXPECTED;
+                Log.d(TAG," queing notificaiton request id  " +
+                                         (2000+notifyEvent.notify_event_id));
+                msg = mHandler.obtainMessage(2000 + notifyEvent.notify_event_id);
+                mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+                if (notifyEvent.notify_event_id == EVENT_PLAYBACK_POS_CHANGED)
+                    registerNotificationNative(notifyEvent.notify_event_id, PLAYBACK_POS_INTERVAL);
+                else
+                    registerNotificationNative(notifyEvent.notify_event_id, 0);
+                break;
+            }
+        }
+        if ((!notificationSent) && (exemptNotificaionId != EVENT_NOTIFICAION_ID_NONE))
+        {
+            /*
+             * exempted value was valid and only this was not notified.
+             */
+            for (NotifyEvents notifyEvent: mRemoteData.mNotifyEvent)
+            {
+                if (notifyEvent.notify_event_id == exemptNotificaionId)
+                {
+                    notificationSent = true;
+                    notifyEvent.notify_state = NOTIFY_INTERIM_EXPECTED;
+                    msg = mHandler.obtainMessage(2000 + notifyEvent.notify_event_id);
+                    mHandler.sendMessageDelayed(msg, MSG_TIMEOUT_MTP);
+                    if (notifyEvent.notify_event_id == EVENT_PLAYBACK_POS_CHANGED)
+                        registerNotificationNative(notifyEvent.notify_event_id,
+                                           PLAYBACK_POS_INTERVAL);
+                    else
+                        registerNotificationNative(notifyEvent.notify_event_id, 0);
+                    break;
+                }
+            }
+        }
+    }
+    private void initializeDatabase()
+    {
+        if (mDbInitialized)
+            return;
+        ContentValues values = new ContentValues();
+        values.put(BluetoothAvrcpInfo.TRACK_NUM, BluetoothAvrcpInfo.TRACK_NUM_INVALID);
+        values.put(BluetoothAvrcpInfo.TITLE, BluetoothAvrcpInfo.TITLE_INVALID);
+        values.put(BluetoothAvrcpInfo.ARTIST_NAME, BluetoothAvrcpInfo.ARTIST_NAME_INVALID);
+        values.put(BluetoothAvrcpInfo.ALBUM_NAME, BluetoothAvrcpInfo.ALBUM_NAME_INVALID);
+        values.put(BluetoothAvrcpInfo.TOTAL_TRACKS, BluetoothAvrcpInfo.TOTAL_TRACKS_INVALID);
+        values.put(BluetoothAvrcpInfo.GENRE, BluetoothAvrcpInfo.GENRE_INVALID);
+        values.put(BluetoothAvrcpInfo.PLAYING_TIME, BluetoothAvrcpInfo.PLAYING_TIME_INVALID);
+        values.put(BluetoothAvrcpInfo.TOTAL_TRACK_TIME,
+                                                BluetoothAvrcpInfo.TOTAL_TRACK_TIME_INVALID);
+        values.put(BluetoothAvrcpInfo.PLAY_STATUS, BluetoothAvrcpInfo.PLAY_STATUS_INVALID);
+        values.put(BluetoothAvrcpInfo.REPEAT_STATUS, BluetoothAvrcpInfo.REPEAT_STATUS_INVALID);
+        values.put(BluetoothAvrcpInfo.SHUFFLE_STATUS, BluetoothAvrcpInfo.SHUFFLE_STATUS_INVALID);
+        values.put(BluetoothAvrcpInfo.SCAN_STATUS, BluetoothAvrcpInfo.SCAN_STATUS_INVALID);
+        values.put(BluetoothAvrcpInfo.EQUALIZER_STATUS,
+                                              BluetoothAvrcpInfo.EQUALIZER_STATUS_INVALID);
+        Cursor cursor = getContentResolver().query(BluetoothAvrcpInfo.CONTENT_URI, null, null, null,
+                BluetoothAvrcpInfo._ID);
+        if((cursor != null)&&(cursor.getCount() > 0)) {
+            int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                 update(BluetoothAvrcpInfo.CONTENT_URI, values, null, null);
+            Log.d(TAG," initializeDataBase num_rows_updated " + rowsUpdated);
+            mDbInitialized = true;
+            cursor.close();
+            return;
+        }
+        Uri contentUri = sAvrcpControllerService.getContentResolver().
+                              insert(BluetoothAvrcpInfo.CONTENT_URI, values);
+        Log.d(TAG," InitializeDatabase uri " + contentUri);
+        /*Fix for below klockworks issue */
+        /*Sql object 'cursor' is not closed on exit*/
+        if (cursor != null)
+            cursor.close();
+        mDbInitialized = true;
+    }
+    private void deinitDatabase()
+    {
+        mDbInitialized = false;
+        int rows_deleted = sAvrcpControllerService.getContentResolver().
+                               delete(BluetoothAvrcpInfo.CONTENT_URI, null, null);
+        Log.d(TAG, " DeinitDatabase rows_deleted "+ rows_deleted);
+    }
+    private String getPlayStatusString(byte playStatus)
+    {
+        switch(playStatus)
+        {
+        case PLAY_STATUS_STOPPED:
+             return "STOPPED";
+        case PLAY_STATUS_PLAYING:
+            return "PLAYING";
+        case PLAY_STATUS_PAUSED:
+            return "PAUSED";
+        case PLAY_STATUS_FWD_SEEK:
+            return "FWD_SEEK";
+        case PLAY_STATUS_REV_SEEK:
+            return "REV_SEEK";
+        }
+        return BluetoothAvrcpInfo.PLAY_STATUS_INVALID;
+    }
+    private String getShuffleStatusString()
+    {
+        for (PlayerSettings plSettings: mRemoteData.mSupportedApplicationSettingsAttribute)
+        {
+            if (plSettings.attr_Id == ATTRIB_SHUFFLE_STATUS)
+            {
+                switch(plSettings.attr_val)
+                {
+                case SHUFFLE_STATUS_OFF:
+                     return "SHUFFLE_OFF";
+                case SHUFFLE_STATUS_GROUP_SHUFFLE:
+                    return "SHUFFLE_GROUP_SHUFFLE";
+                case SHUFFLE_STATUS_ALL_TRACK_SHUFFLE:
+                    return "SHUFFLE_ALL_TRACK_SHUFFLE";
+                }
+            }
+        }
+        return BluetoothAvrcpInfo.SHUFFLE_STATUS_INVALID;
+    }
+    private String getScanStatusString()
+    {
+        for (PlayerSettings plSettings: mRemoteData.mSupportedApplicationSettingsAttribute)
+        {
+            if (plSettings.attr_Id == ATTRIB_SCAN_STATUS)
+            {
+                switch(plSettings.attr_val)
+                {
+                case SCAN_STATUS_OFF:
+                     return "SCAN_OFF";
+                case SCAN_STATUS_GROUP_SCAN:
+                    return "SCAN_GROUP_SCAN";
+                case SCAN_STATUS_ALL_TRACK_SCAN:
+                    return "SCAN_ALL_TRACK_SCAN";
+                }
+            }
+        }
+        return BluetoothAvrcpInfo.SCAN_STATUS_INVALID;
+    }
+    private String getEqualizerStatusString()
+    {
+        for (PlayerSettings plSettings: mRemoteData.mSupportedApplicationSettingsAttribute)
+        {
+            if (plSettings.attr_Id == ATTRIB_EQUALIZER_STATUS)
+            {
+                switch(plSettings.attr_val)
+                {
+                case EQUALIZER_STATUS_OFF:
+                     return "EQUALIZER_OFF";
+                case EQUALIZER_STATUS_ON:
+                    return "EQUALIZER_ON";
+                }
+            }
+        }
+        return BluetoothAvrcpInfo.EQUALIZER_STATUS_INVALID;
+    }
+    private String getRepeatStatusString()
+    {
+        for (PlayerSettings plSettings: mRemoteData.mSupportedApplicationSettingsAttribute)
+        {
+            if (plSettings.attr_Id == ATTRIB_REPEAT_STATUS)
+            {
+                switch(plSettings.attr_val)
+                {
+                case REPEAT_STATUS_OFF:
+                     return "REPEAT_OFF";
+                case REPEAT_STATUS_SINGLE_TRACK_REPEAT:
+                    return "REPEAT_SINGLE_TRACK_REPEAT";
+                case REPEAT_STATUS_GROUP_REPEAT:
+                    return "REPEAT_GROUP_REPEAT";
+                case REPEAT_STATUS_ALL_TRACK_REPEAT:
+                    return "REPEAT_ALL_TRACK_REPEAT";
+                }
+            }
+        }
+        return  BluetoothAvrcpInfo.REPEAT_STATUS_INVALID;
+    }
+
+    private void updateElementAttribute()
+    {
+        Log.d(TAG," updateElementAttribute " + mRemoteData.mMetadata.toString());
+        ContentValues values = new ContentValues();
+        values.put(BluetoothAvrcpInfo.TITLE, mRemoteData.mMetadata.trackTitle);
+        values.put(BluetoothAvrcpInfo.ARTIST_NAME, mRemoteData.mMetadata.artist);
+        values.put(BluetoothAvrcpInfo.ALBUM_NAME, mRemoteData.mMetadata.albumTitle);
+        values.put(BluetoothAvrcpInfo.TRACK_NUM, mRemoteData.mMetadata.trackNum);
+        values.put(BluetoothAvrcpInfo.TOTAL_TRACKS, mRemoteData.mMetadata.totalTrackNum);
+        values.put(BluetoothAvrcpInfo.GENRE, mRemoteData.mMetadata.genre);
+        values.put(BluetoothAvrcpInfo.PLAYING_TIME, mRemoteData.mMetadata.playTime);
+        values.put(BluetoothAvrcpInfo.TOTAL_TRACK_TIME, mRemoteData.mMetadata.totalTrackLen);
+        int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                  update(BluetoothAvrcpInfo.CONTENT_URI, values, null, null);
+        Log.d(TAG," updateElementAttribute num_rows_updated " + rowsUpdated);
+    }
+    private void updateTrackNum()
+    {
+        ContentValues values = new ContentValues();
+        values.put(BluetoothAvrcpInfo.TRACK_NUM, mRemoteData.mMetadata.trackNum);
+        int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                  update(BluetoothAvrcpInfo.CONTENT_URI, values, null, null);
+        Log.d(TAG," updateTrackNum num_rows_updated " + rowsUpdated);
+    }
+    private void updatePlayTime()
+    {
+        ContentValues values = new ContentValues();
+        values.put(BluetoothAvrcpInfo.PLAYING_TIME, mRemoteData.mMetadata.playTime);
+        int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                  update(BluetoothAvrcpInfo.CONTENT_URI, values, null, null);
+        Log.d(TAG," updatePlayTime num_rows_updated " + rowsUpdated);
+    }
+    private void updatePlayerApplicationSettings()
+    {
+        ContentValues values =  new ContentValues();
+        values.put(BluetoothAvrcpInfo.REPEAT_STATUS, getRepeatStatusString());
+        values.put(BluetoothAvrcpInfo.SHUFFLE_STATUS, getShuffleStatusString());
+        values.put(BluetoothAvrcpInfo.SCAN_STATUS, getScanStatusString());
+        values.put(BluetoothAvrcpInfo.EQUALIZER_STATUS, getEqualizerStatusString());
+        int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                    update(BluetoothAvrcpInfo.CONTENT_URI,values, null, null);
+        Log.d(TAG," updatePlayerApplicationSettings num_rows_updated " + rowsUpdated);
+    }
+    private void updatePlayStatus()
+    {
+        ContentValues values =  new ContentValues();
+        Log.d(TAG," updatePlayStatus " + mRemoteData.mMetadata.toString());
+        if(mRemoteData.mMetadata.playStatus == PLAY_STATUS_PLAYING) {
+            A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+            if((a2dpSinkService != null)&&(!mConnectedDevices.isEmpty())) {
+                Log.d(TAG," State = PLAYING, inform A2DP SINK");
+                a2dpSinkService.informAvrcpStatePlaying(mConnectedDevices.get(0));
+            }
+        }
+        values.put(BluetoothAvrcpInfo.PLAY_STATUS,
+                          getPlayStatusString(mRemoteData.mMetadata.playStatus));
+        values.put(BluetoothAvrcpInfo.PLAYING_TIME, mRemoteData.mMetadata.playTime);
+        values.put(BluetoothAvrcpInfo.TOTAL_TRACK_TIME, mRemoteData.mMetadata.totalTrackLen);
+        int rowsUpdated = sAvrcpControllerService.getContentResolver().
+                                   update(BluetoothAvrcpInfo.CONTENT_URI,values, null, null);
+        Log.d(TAG," updatePlayStatus num_rows_updated " + rowsUpdated);
+    }
+    private boolean isEventSupported(byte eventId)
+    {
+        if ((eventId == EVENT_PLAYBACK_STATUS_CHANGED)||
+            (eventId == EVENT_PLAYBACK_POS_CHANGED)||
+            (eventId == EVENT_PLAYER_APPLICATION_SETTINGS_CHANGED)||
+            (eventId == EVENT_TRACK_CHANGED))
+            return true;
+        else
+            return false;
+    }
+    private void handleNotificationTimeout(int cmd)
+    {
+        Log.d(TAG," handleNotificationTimeout cmd " + cmd);
+        int notificaitonId = cmd - 2000;
+        int index;
+        for (index = 0; index < mRemoteData.mNotifyEvent.size(); index++) {
+            if (notificaitonId == mRemoteData.mNotifyEvent.get(index).notify_event_id)
+                break;
+        }
+        if (index == mRemoteData.mNotifyEvent.size())
+            return;
+        NotifyEvents notifyEvent = mRemoteData.mNotifyEvent.get(index);
+        if ((notifyEvent.notify_event_id == notificaitonId) &&
+            (notifyEvent.notify_state == NOTIFY_INTERIM_EXPECTED))
+        {
+            notifyEvent.notify_state = NOTIFY_NOT_NOTIFIED;
+            registerFurtherNotification(notificaitonId);
+        }
+    }
+    private void handleCmdTimeout(int cmd)
+    {
+        Log.d(TAG," CMD " + cmd + " Timeout Happened");
+        switch(cmd)
+        {
+        case MESSAGE_GET_SUPPORTED_COMPANY_ID:
+            mHandler.sendEmptyMessage(MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+            break;
+        case MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB:
+        case MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS:
+            mHandler.sendEmptyMessage(MESSAGE_GET_SUPPORTED_EVENTS);
+            break;
+        case MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES:
+            getFurtherPlayerSettingAttrib(ATTRIBUTE_FETCH_SKIP);
+            break;
+        case MESSAGE_GET_SUPPORTED_EVENTS:
+            /*
+             * If Timeout for these command happened, We would not do anything
+             * We will wait for Application to send request for
+             * ElementAttributes/PlayStatus. Only after that MetaData/Playstatus will resume
+             */
+            break;
+        case MESSAGE_TIMEOUT_APPL_SETTINGS_CHANGED:
+        case MESSAGE_TIMEOUT_PLAYBACK_POS_CHNAGED:
+        case MESSAGE_TIMEOUT_PLAYBACK_STATUS_CHANGED:
+        case MESSAGE_TIMEOUT_TRACK_CHANGED:
+        case MESSAGE_TIMEOUT_VOLUME_CHANGED:
+            handleNotificationTimeout(cmd);
+            break;
+        case MESSAGE_TIMEOUT_ATTRIBUTE_TITLE:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_ARTIST_NAME:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_ALBUM_NAME:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_GENRE:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_PLAYING_TIME:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_TOTAL_TRACK_NUMBER:
+        case MESSAGE_TIMEOUT_ATTRIBUTE_TRACK_NUMBER:
+            getFurtherElementAttribute(ATTRIBUTE_FETCH_SKIP);
+            break;
+        case MESSAGE_GET_PLAY_STATUS:
+            mHandler.sendEmptyMessage(MESSAGE_GET_PLAY_STATUS); // reque this command
+            break;
+        case MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS:
+            // do nothing here
+            break;
+        }
+    }
+    private String utf8ToString(byte[] input)
+    {
+        Charset UTF8_CHARSET = Charset.forName("UTF-8");
+        return new String(input,UTF8_CHARSET);
+    }
+    private int asciiToInt(int len, byte[] array)
+    {
+        return Integer.parseInt(utf8ToString(array));
+    }
+    private void resetElementAttribute(int attributeId, int asciiStringLen) {
+        if(asciiStringLen == 0) {
+            switch(attributeId)
+            {
+            case MEDIA_ATTRIBUTE_TITLE:
+                mRemoteData.mMetadata.trackTitle = BluetoothAvrcpInfo.TITLE_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_ARTIST_NAME:
+                mRemoteData.mMetadata.artist = BluetoothAvrcpInfo.ARTIST_NAME_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_ALBUM_NAME:
+                mRemoteData.mMetadata.albumTitle = BluetoothAvrcpInfo.ALBUM_NAME_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_GENRE:
+                mRemoteData.mMetadata.genre = BluetoothAvrcpInfo.GENRE_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_TRACK_NUMBER:
+                mRemoteData.mMetadata.trackNum = BluetoothAvrcpInfo.TRACK_NUM_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER:
+                mRemoteData.mMetadata.totalTrackNum = BluetoothAvrcpInfo.TOTAL_TRACKS_INVALID;
+                break;
+            case MEDIA_ATTRIBUTE_PLAYING_TIME:
+                mRemoteData.mMetadata.totalTrackLen = BluetoothAvrcpInfo.TOTAL_TRACK_TIME_INVALID;
+                break;
+            }
+        }
+    }
+    private int parseElementAttributes(int currentIndex, int attributeId, ByteBuffer attribBuffer)
+    {
+        Log.d(TAG,"parseElementAttributes Id = " + attributeId);
+        currentIndex += 2; // for character set
+        int asciiStringLen = attribBuffer.getChar(currentIndex);
+        Log.d(TAG," asciiStringLen "+ asciiStringLen);
+        currentIndex += 2;// for string len
+        if((asciiStringLen <= 0) || ((currentIndex + asciiStringLen) > attribBuffer.capacity()))
+        {
+            Log.d(TAG," parseElementAttribute wrong buffer");
+            resetElementAttribute(attributeId, asciiStringLen);
+            return currentIndex;
+        }
+        byte[] asciiString = new byte[asciiStringLen];
+        attribBuffer.position(currentIndex);
+        attribBuffer.get(asciiString, 0, asciiStringLen);
+        currentIndex += asciiStringLen;
+        switch(attributeId)
+        {
+        case MEDIA_ATTRIBUTE_TITLE:
+            mRemoteData.mMetadata.trackTitle = utf8ToString(asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_ARTIST_NAME:
+            mRemoteData.mMetadata.artist = utf8ToString(asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_ALBUM_NAME:
+            mRemoteData.mMetadata.albumTitle = utf8ToString(asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_GENRE:
+            mRemoteData.mMetadata.genre = utf8ToString(asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_TRACK_NUMBER:
+            mRemoteData.mMetadata.trackNum = asciiToInt(asciiStringLen,asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_TOTAL_TRACK_NUMBER:
+            mRemoteData.mMetadata.totalTrackNum = asciiToInt(asciiStringLen,asciiString);
+            break;
+        case MEDIA_ATTRIBUTE_PLAYING_TIME:
+            mRemoteData.mMetadata.totalTrackLen = asciiToInt(asciiStringLen,asciiString);
+            break;
+        }
+        return currentIndex;
+    }
+    private void handleProcessGetElementAttribute(int numAttributes, ByteBuffer attribBuffer)
+    {
+        Log.d(TAG,"handleProcessGetElementAttribute numAttrib ="+ numAttributes);
+        int attributeId = 0;
+        int currentIndex = 0;
+        for (int count = 0; count < numAttributes; count++)
+        {
+            /*
+             * In case remote sends rsp for more attributes that we can accomodate.
+             * Basically to avoid erroneous conditions.
+             */
+            if (mRemoteData.mMetadata.attributesFetchedId >= requestedElementAttribs.length)
+                continue;
+            attributeId = attribBuffer.getInt(currentIndex);
+            if (requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId] != attributeId)
+            {
+                Log.e(TAG," Received Rsp for attributeId "+ attributeId +" Requested ID = " +
+                       requestedElementAttribs[mRemoteData.mMetadata.attributesFetchedId]);
+                break;
+            }
+            currentIndex += 4; // 4 bytes for Int
+            Log.d(TAG," attributeID = "+ attributeId);
+            /*
+             * remove timeout message if it is present already in que.
+             */
+            if (mHandler.hasMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + attributeId))
+            {
+                mHandler.removeMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + attributeId);
+                Log.d(TAG," Timeout CMD = " + attributeId + "dequed");
+            }
+            currentIndex = parseElementAttributes(currentIndex,attributeId,attribBuffer);
+        }
+        getFurtherElementAttribute(ATTRIBUTE_FETCH_CONTINUE);
+    }
+    private void handleProcessNotificationResponse(int notificationId, int notificationType,
+                                             ByteBuffer notificationRsp)
+    {
+        Log.d(TAG,"handleProcessNotificationResponse id " + notificationId +
+                   " type = " + notificationType);
+        /*
+         * First remove timeout if already queued
+         */
+        byte oldState = NOTIFY_NOT_NOTIFIED;
+        if (mHandler.hasMessages(2000 + notificationId))
+        {
+            mHandler.removeMessages(2000 + notificationId);
+            Log.d(TAG," Timeout Notification CMD dequeued ");
+        }
+        for (NotifyEvents notifyEvent: mRemoteData.mNotifyEvent)
+        {
+            if (notificationId != notifyEvent.notify_event_id)
+                continue;
+            oldState = notifyEvent.notify_state;
+            if ((oldState == NOTIFY_INTERIM_EXPECTED) &&
+                (notificationType == NOTIFICATION_RSP_TYPE_INTERIM)) {
+                notifyEvent.notify_state = NOTIFY_CHANGED_EXPECTED;
+            }
+            else if ((oldState == NOTIFY_CHANGED_EXPECTED) &&
+                    (notificationType == NOTIFICATION_RSP_TYPE_CHANGED)) {
+                 notifyEvent.notify_state = NOTIFY_NOT_NOTIFIED;
+            }
+            break;
+        }
+            switch(notificationId)
+            {
+            case EVENT_PLAYBACK_STATUS_CHANGED:
+                byte oldPlayStatus = mRemoteData.mMetadata.playStatus;
+                mRemoteData.mMetadata.playStatus = notificationRsp.get(1);
+                /*
+                 * Check if there is a transition from Stopped/Paused to Playing
+                 * and Remote does not support EVENT_PLAYBACK_POS
+                 * We need to Que GetPlayBackStatus command.
+                 */
+                if (((oldPlayStatus == PLAY_STATUS_STOPPED)||
+                   (oldPlayStatus == PLAY_STATUS_PAUSED))&&
+                   (mRemoteData.mMetadata.playStatus == PLAY_STATUS_PLAYING)) {
+                    if (!(mRemoteData.mEventsSupported.contains(EVENT_PLAYBACK_POS_CHANGED))||
+                        !(mRemoteData.mEventsSupported.contains(EVENT_PLAYBACK_STATUS_CHANGED))) {
+                        Log.d(TAG," State Transition Triggered, Que GetPlayStatus ");
+                        mHandler.sendEmptyMessage(MESSAGE_GET_PLAY_STATUS);
+                    }
+                }
+                updatePlayStatus();
+                break;
+            case EVENT_PLAYBACK_POS_CHANGED:
+                mRemoteData.mMetadata.playTime = notificationRsp.getInt(1);
+                updatePlayTime();
+                break;
+            case EVENT_PLAYER_APPLICATION_SETTINGS_CHANGED:
+                int numPlayerSettingAttribs = notificationRsp.get(1);
+                int attribIndex = 2; // first attribute will be at 2 index
+                for (int count = 0; count < numPlayerSettingAttribs; count ++)
+                {
+                    Byte attributeId = notificationRsp.get(attribIndex);
+                    for (PlayerSettings plSettings:
+                         mRemoteData.mSupportedApplicationSettingsAttribute)
+                    {
+                        if (plSettings.attr_Id == attributeId)
+                        {
+                            plSettings.attr_val = notificationRsp.get(attribIndex+1);
+                        }
+                    }
+                    attribIndex = attribIndex + 2;
+                }
+                updatePlayerApplicationSettings();
+                if ((oldState == NOTIFY_CHANGED_EXPECTED) &&
+                    (notificationType == NOTIFICATION_RSP_TYPE_CHANGED))
+                {
+                    mHandler.sendEmptyMessage(MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+                }
+                break;
+            case EVENT_TRACK_CHANGED:
+                if ((oldState == NOTIFY_CHANGED_EXPECTED) &&
+                    (notificationType == NOTIFICATION_RSP_TYPE_CHANGED))
+                {
+                    Log.d(TAG," Track change Happened, que GetElement, PlayerSetting ");
+                    mHandler.sendEmptyMessage(MESSAGE_GET_ELEMENT_ATTRIBUTE);
+                    mHandler.sendEmptyMessage(MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+                }
+                break;
+            }
+        registerFurtherNotification(EVENT_NOTIFICAION_ID_NONE);
+    }
+    private void handleProcessPlayStatus(ByteBuffer bb)
+    {
+        int currentIndex = 0;
+        int bufSize = bb.capacity();
+        mRemoteData.mMetadata.totalTrackLen = bb.getInt(currentIndex);
+        currentIndex += 4;
+        mRemoteData.mMetadata.playTime = bb.getInt(currentIndex);
+        currentIndex += 4;
+        mRemoteData.mMetadata.playStatus = bb.get(currentIndex);
+        updatePlayStatus();
+        if (!(mRemoteData.mEventsSupported.contains(EVENT_PLAYBACK_POS_CHANGED))||
+           !(mRemoteData.mEventsSupported.contains(EVENT_PLAYBACK_STATUS_CHANGED)))
+        {
+            if ((mRemoteData.mMetadata.playStatus != PLAY_STATUS_STOPPED)&&
+                (mRemoteData.mMetadata.playStatus != PLAY_STATUS_PAUSED)) {
+                Log.d(TAG," POS and Status changed not supported");
+                mHandler.sendEmptyMessageDelayed(MESSAGE_GET_PLAY_STATUS, GET_PLAY_STATUS_INTERVAL);
+            }
+        }
+    }
+    private void setAbsVolume(int absVol)
+    {
+        int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+        int currIndex = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+        int newIndex = (maxVolume*absVol)/ABS_VOL_BASE;
+        Log.d(TAG," setAbsVolume ="+absVol + " maxVol = " + maxVolume + " cur = " + currIndex +
+                                              " new = "+newIndex);
+        /*
+         * In some cases change in percentage is not sufficient enough to warrant
+         * change in index values which are in range of 0-15. For such cases
+         * no action is required
+         */
+        if (newIndex != currIndex) {
+            if (mRemoteData.absVolNotificationState == NOTIFY_RSP_INTERIM_SENT)
+                mRemoteData.absVolNotificationState = NOTIFY_RSP_ABS_VOL_DEFERRED;
+            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newIndex, 0);
+        }
+        sendAbsVolRspNative(absVol);
+    }
+    private void handleProcessAbsVolNotification()
+    {
+        Log.d(TAG," handleProcessAbsVolNotification ");
+        if(mRemoteData == null)
+            return;
+        if(mRemoteData.absVolNotificationState == NOTIFY_NOT_REGISTERED)
+        {
+            int maxVol = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
+            int currIndex = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+            int percentageVol = ((currIndex*ABS_VOL_BASE)/maxVol);
+            Log.d(TAG," maxVol ="+maxVol+" currentIndex ="+currIndex+
+                                                   " percentageVol ="+percentageVol);
+            byte rspType = NOTIFICATION_RSP_TYPE_INTERIM;
+            mRemoteData.absVolNotificationState = NOTIFY_RSP_INTERIM_SENT;
+            sendRegisterAbsVolRspNative(rspType,percentageVol);
+        }
+    }
     /** Handles Avrcp messages. */
     private final class AvrcpMessageHandler extends Handler {
         private AvrcpMessageHandler(Looper looper) {
@@ -224,12 +1647,203 @@ public class AvrcpControllerService extends ProfileService {
 
         @Override
         public void handleMessage(Message msg) {
+            Log.d(TAG," HandleMessage: "+ msg.what +
+                  " Remote Connected " + !mConnectedDevices.isEmpty());
             switch (msg.what) {
             case MESSAGE_SEND_PASS_THROUGH_CMD:
-                if (DBG) Log.v(TAG, "MESSAGE_SEND_PASS_THROUGH_CMD");
                 BluetoothDevice device = (BluetoothDevice)msg.obj;
                 sendPassThroughCommandNative(getByteAddress(device), msg.arg1, msg.arg2);
                 break;
+            case MESSAGE_GET_SUPPORTED_COMPANY_ID: //first command in AVRCP 1.3 that we send.
+                /*
+                 * If Sink is not active we won't allow AVRCP MetaData
+                 */
+                A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+                if (a2dpSinkService == null) {
+                    Log.e(TAG," A2DP Sink service not started, MetaData will not proceed");
+                    return;
+                }
+                initializeDatabase();
+                getSupportedCapabilities(COMPANY_ID);
+                break;
+            case MESSAGE_GET_SUPPORTED_EVENTS:
+                if ((mRemoteData.mNotifyEvent != null)&&(mRemoteData.mNotifyEvent.isEmpty()))
+                    getSupportedCapabilities(EVENTS_SUPPORTED);
+                break;
+            case MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB:
+                getPlayerApplicationSettingsAttrib();
+                break;
+            case MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES:
+                getFurtherPlayerSettingAttrib(ATTRIBUTE_FETCH_FRESH);
+                break;
+            case MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS:
+                if (!(mHandler.hasMessages(MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS)))
+                    getCurrentPlayerApplicationSettingsValues();
+                break;
+            case MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS:
+                setCurrentPlayerApplicationSettingsValues(msg.arg1, msg.arg2);
+                break;
+            case MESSAGE_DEINIT_AVRCP_DATABASE:
+                deinitDatabase();
+                break;
+            case MESSAGE_CMD_TIMEOUT:
+                int cmd = (Integer)msg.obj;
+                handleCmdTimeout(cmd);
+                break;
+            case MESSAGE_TIMEOUT_APPL_SETTINGS_CHANGED:
+            case MESSAGE_TIMEOUT_PLAYBACK_POS_CHNAGED:
+            case MESSAGE_TIMEOUT_PLAYBACK_STATUS_CHANGED:
+            case MESSAGE_TIMEOUT_TRACK_CHANGED:
+            case MESSAGE_TIMEOUT_VOLUME_CHANGED:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_TITLE:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_ARTIST_NAME:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_ALBUM_NAME:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_GENRE:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_PLAYING_TIME:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_TOTAL_TRACK_NUMBER:
+            case MESSAGE_TIMEOUT_ATTRIBUTE_TRACK_NUMBER:
+                handleCmdTimeout(msg.what);
+                break;
+
+            case MESSAGE_GET_ELEMENT_ATTRIBUTE:
+                getFurtherElementAttribute(ATTRIBUTE_FETCH_FRESH);
+                break;
+            case ABORT_FETCH_ELEMENT_ATTRIBUTE:
+                if ((mRemoteData != null) && (mRemoteData.mMetadata != null))
+                    mRemoteData.mMetadata.attributesFetchedId = -1; // reset it to -1 again.
+                break;
+            case MESSAGE_GET_PLAY_STATUS:
+                if (mHandler.hasMessages(MESSAGE_GET_PLAY_STATUS)) {
+                    Log.d(TAG," Get Play Status Already There, return ");
+                    return;
+                }
+                Message messsag = mHandler.obtainMessage(MESSAGE_CMD_TIMEOUT,
+                                           0,0,MESSAGE_GET_PLAY_STATUS);
+                mHandler.sendMessageDelayed(messsag, MSG_TIMEOUT_MTP);
+                getPlayStatusNative();
+                break;
+            case MESSAGE_PROCESS_RC_FEATURES:
+                /* check if we have already initiated MetaData Procedure */
+               if ((mRemoteData != null)&&(mRemoteData.mRemoteFeatures != 0))
+                   break;
+               /* this is first time */
+                int remoteFeatures = msg.arg1;
+                BluetoothDevice remoteDevice =  (BluetoothDevice)msg.obj;
+                if (mConnectedDevices.contains(remoteDevice)) {
+                    /*Fix for below klockworks issue */
+                    /*Null pointer dereference of 'mRemoteData' where null comes from condition */
+                    if (mRemoteData != null) {
+                        mRemoteData.mRemoteFeatures = remoteFeatures;
+                        if ((mRemoteData.mRemoteFeatures & BTRC_FEAT_METADATA) != 0)
+                            mHandler.sendMessage(mHandler.
+                            obtainMessage(MESSAGE_GET_SUPPORTED_COMPANY_ID,0, 0, remoteDevice));
+                    }
+                }
+                break;
+            case MESSAGE_PROCESS_CONNECTION_CHANGE:
+                int connected = msg.arg1;
+                BluetoothDevice rtDevice =  (BluetoothDevice)msg.obj;
+                if (connected == 1)
+                {
+                    /*
+                     * Connection up but RC features not received yet. We will
+                     * send get_company_ID later.
+                     */
+                    if (mRemoteData == null)
+                        mRemoteData = new RemoteAvrcpData();
+                    mRemoteData.mCompanyIDSupported = new ArrayList<Integer>();
+                    mRemoteData.mEventsSupported = new ArrayList<Byte>();
+                    mRemoteData.mMetadata = new Metadata();
+                    mRemoteData.mNotifyEvent = new ArrayList<NotifyEvents>();
+                    mRemoteData.mSupportedApplicationSettingsAttribute =
+                                             new ArrayList<PlayerSettings>();
+                    mRemoteData.absVolNotificationState = NOTIFY_NOT_REGISTERED;
+                    mRemoteData.playerSettingAttribIdFetch = 0;
+                    mRemoteData.mRemoteFeatures = 0;
+                }
+                else
+                {
+                    mHandler.removeCallbacksAndMessages(null);
+                    mHandler.sendEmptyMessage(MESSAGE_DEINIT_AVRCP_DATABASE);
+                    if (mRemoteData != null)
+                    {
+                        mRemoteData.mCompanyIDSupported.clear();
+                        mRemoteData.mEventsSupported.clear();
+                        mRemoteData.mMetadata.resetMetaData();
+                        mRemoteData.mNotifyEvent.clear();
+                        mRemoteData.mSupportedApplicationSettingsAttribute.clear();
+                        mRemoteData.absVolNotificationState = NOTIFY_NOT_REGISTERED;
+                        mRemoteData.mRemoteFeatures = 0;
+                        Log.d(TAG," RC_features, conn_change down " + mRemoteData.mRemoteFeatures);
+                        mRemoteData.playerSettingAttribIdFetch = 0;
+                        mRemoteData = null;
+                    }
+                }
+                break;
+            case MESSAGE_PROCESS_SUPPORTED_COMPANY_ID:
+                List<Integer> company_ids = (List<Integer>)msg.obj;
+                mRemoteData.mCompanyIDSupported.addAll(company_ids);
+                mHandler.sendEmptyMessage(MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+                break;
+            case MESSAGE_PROCESS_SUPPORTED_EVENTS:
+                List<Byte> events_supported = (List<Byte>)msg.obj;
+                mRemoteData.mEventsSupported.addAll(events_supported);
+                for (Byte event: mRemoteData.mEventsSupported)
+                {
+                    NotifyEvents notifyevent = new NotifyEvents();
+                    notifyevent.notify_event_id = event;
+                    notifyevent.notify_state = NOTIFY_NOT_NOTIFIED;
+                    mRemoteData.mNotifyEvent.add(notifyevent);
+                }
+                registerFurtherNotification(EVENT_NOTIFICAION_ID_NONE);
+                break;
+            case MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_ATTRIB:
+                List<PlayerSettings> player_settings_supported = (List<PlayerSettings>)msg.obj;
+                mRemoteData.mSupportedApplicationSettingsAttribute.
+                                     addAll(player_settings_supported);
+                mHandler.sendEmptyMessage(MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES);
+                break;
+            case MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_VALUES:
+                mRemoteData.playerSettingAttribIdFetch ++;
+                getFurtherPlayerSettingAttrib(msg.arg1);
+                break;
+            case MESSAGE_PROCESS_CURRENT_PLAYER_APPLICATION_SETTINGS:
+                updatePlayerApplicationSettings();
+                if ((mRemoteData.mNotifyEvent != null)&&(mRemoteData.mNotifyEvent.isEmpty()))
+                    mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_GET_SUPPORTED_EVENTS));
+                break;
+            case MESSAGE_PROCESS_NOTIFICATION_RESPONSE:
+                int notificationId = msg.arg1;
+                int notificationType = msg.arg2;
+                ByteBuffer bb = (ByteBuffer)msg.obj;
+                handleProcessNotificationResponse(notificationId, notificationType, bb);
+                break;
+            case MESSAGE_PROCESS_ELEMENT_ATTRIBUTE:
+                if ((mRemoteData.mMetadata.attributesFetchedId == -1) ||
+                   (mHandler.hasMessages(ABORT_FETCH_ELEMENT_ATTRIBUTE))) {
+                   Log.d(TAG," ID reset, Fetch from Fresh");
+                   mHandler.sendEmptyMessage(MESSAGE_GET_ELEMENT_ATTRIBUTE);
+                   break;
+                }
+                int processMode = msg.arg2;
+                if (processMode == ATTRIBUTE_FETCH_CONTINUE)
+                {
+                    int numAttributes = msg.arg1;
+                    ByteBuffer bbRsp = (ByteBuffer)msg.obj;
+                    handleProcessGetElementAttribute(numAttributes, bbRsp);
+                }
+                else if(processMode == ATTRIBUTE_FETCH_SKIP)
+                    getFurtherElementAttribute(ATTRIBUTE_FETCH_SKIP);
+                break;
+            case MESSAGE_PROCESS_PLAY_STATUS:
+                ByteBuffer playStatusRsp = (ByteBuffer)msg.obj;
+                handleProcessPlayStatus(playStatusRsp);
+                break;
+            case MESSAGE_PROCESS_SET_ABS_VOL_CMD:
+                setAbsVolume(msg.arg1);
+                break;
+            case MESSAGE_PROCESS_REGISTER_ABS_VOL_REQUEST:
+                handleProcessAbsVolNotification();
             }
         }
     }
@@ -237,29 +1851,140 @@ public class AvrcpControllerService extends ProfileService {
     private void onConnectionStateChanged(boolean connected, byte[] address) {
         BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
             (Utils.getAddressStringFromByte(address));
-        Log.d(TAG, "onConnectionStateChanged " + connected + " " + device);
+        Log.d(TAG, "onConnectionStateChanged " + connected + " " + device+ " size "+
+                    mConnectedDevices.size());
+        if (device == null)
+            return;
         Intent intent = new Intent(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
         int oldState = (mConnectedDevices.contains(device) ? BluetoothProfile.STATE_CONNECTED
                                                         : BluetoothProfile.STATE_DISCONNECTED);
         int newState = (connected ? BluetoothProfile.STATE_CONNECTED
                                   : BluetoothProfile.STATE_DISCONNECTED);
-        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, oldState);
-        intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
-        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
-//        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
-        sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
+
         if (connected && oldState == BluetoothProfile.STATE_DISCONNECTED) {
+            /* AVRCPControllerService supports single connection */
+            if(mConnectedDevices.size() >0) {
+                Log.d(TAG,"A Connection already exists, returning");
+                return;
+            }
             mConnectedDevices.add(device);
+            Message msg =  mHandler.obtainMessage(MESSAGE_PROCESS_CONNECTION_CHANGE, 1, 0, device);
+            mHandler.sendMessage(msg);
         } else if (!connected && oldState == BluetoothProfile.STATE_CONNECTED) {
             mConnectedDevices.remove(device);
+            Message msg =  mHandler.obtainMessage(MESSAGE_PROCESS_CONNECTION_CHANGE, 0, 0, device);
+            mHandler.sendMessage(msg);
         }
+        intent.putExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, oldState);
+        intent.putExtra(BluetoothProfile.EXTRA_STATE, newState);
+        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device);
+//      intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
+        sendBroadcast(intent, ProfileService.BLUETOOTH_PERM);
+    }
+
+    private void getRcFeatures(byte[] address, int features) {
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        Message msg = mHandler.obtainMessage(MESSAGE_PROCESS_RC_FEATURES, features, 0,
+                                             device);
+        mHandler.sendMessage(msg);
     }
 
     private void handlePassthroughRsp(int id, int keyState) {
         Log.d(TAG, "passthrough response received as: key: "
                                 + id + " state: " + keyState);
     }
+    private void handleGetCapabilitiesResponse(byte[] address, int capability_id,
+                                           int[] supported_values,int num_supported, byte rsp_type)
+    {
+        Log.d(TAG, "handleGetCapabilitiesResponse cap_id" + capability_id + " num_supported "
+                                                          + num_supported+ "rsp_type " + rsp_type);
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (num_supported <= 0) {
+            /*
+             *  supported values are not reliable. Drop further processing
+             *  Remove Timeout Commands
+             */
+             if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,COMPANY_ID))
+                 mHandler.removeMessages(MESSAGE_CMD_TIMEOUT, COMPANY_ID);
+             else if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,EVENTS_SUPPORTED))
+                mHandler.removeMessages(MESSAGE_CMD_TIMEOUT, EVENTS_SUPPORTED);
+             return;
+        }
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT, capability_id))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT, capability_id);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        if (rsp_type != AVRC_RSP_IMPL_STBL)
+        {
+            if(capability_id == COMPANY_ID)
+                mHandler.sendEmptyMessage(MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+            /* for events supported failure, we don't do anything */
+            return;
+        }
+        Message msg;
+        switch(capability_id)
+        {
+            case COMPANY_ID:
+                ArrayList<Integer> supportedCompanyIds = new ArrayList<Integer>();
+                for (int count = 0; count<num_supported; ++count)
+                supportedCompanyIds.add(supported_values[count]);
+                msg = mHandler.
+                    obtainMessage(MESSAGE_PROCESS_SUPPORTED_COMPANY_ID,supportedCompanyIds);
+                mHandler.sendMessage(msg);
+                break;
+            case EVENTS_SUPPORTED:
+                ArrayList<Byte> supportedEvents = new ArrayList<Byte>();
+                for (int count = 0; count<num_supported; ++count)
+                {
+                    Byte supported_event =
+                      Byte.valueOf((Integer.valueOf(supported_values[count])).byteValue());
+                    if (!isEventSupported(supported_event))
+                        continue;
+                    supportedEvents.add(supported_event);
+                }
+                msg = mHandler.obtainMessage(MESSAGE_PROCESS_SUPPORTED_EVENTS,supportedEvents);
+                mHandler.sendMessage(msg);
+                break;
+        }
+    }
 
+    private void handleListPlayerApplicationSettingsAttrib(byte[] address,
+            byte[] supported_setting_attrib,int num_attrib, byte rsp_type)
+    {
+        Log.d(TAG, "handleListPlayerApplicationSettingsAttrib "
+             + num_attrib + " rsp_type " + rsp_type);
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,
+                 MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT,
+                 MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_ATTRIB);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        if ((rsp_type != AVRC_RSP_IMPL_STBL)||(num_attrib <= 0))
+        {
+            mHandler.sendEmptyMessage(MESSAGE_GET_SUPPORTED_EVENTS);
+            return;
+        }
+        ArrayList<PlayerSettings> supported_attrib = new ArrayList<PlayerSettings>();
+        for (int count = 0; count < num_attrib; count++)
+        {
+            PlayerSettings attrib = new PlayerSettings();
+            attrib.attr_Id = supported_setting_attrib[count];
+            attrib.supported_values = null;
+            supported_attrib.add(attrib);
+        }
+        mHandler.sendMessage(mHandler.
+            obtainMessage(MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_ATTRIB,supported_attrib));
+    }
     private byte[] getByteAddress(BluetoothDevice device) {
         return Utils.getBytesFromAddress(device.getAddress());
     }
@@ -269,8 +1994,207 @@ public class AvrcpControllerService extends ProfileService {
         super.dump(sb);
     }
 
+    private void handleListPlayerApplicationSettingValue(byte[] address, byte[] supported_val,
+                        byte num_supported_val, byte rsp_type)
+    {
+        Log.d(TAG,"handleListPlayerApplicationSettingValue num_supported " + num_supported_val
+             + " rsp_type " + rsp_type);
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,
+             MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT,
+                MESSAGE_GET_PLAYER_APPLICATION_SETTINGS_VALUES);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        if ((rsp_type != AVRC_RSP_IMPL_STBL)||(num_supported_val <= 0))
+        {
+            mHandler.sendMessage(mHandler.obtainMessage(
+                MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_VALUES, ATTRIBUTE_FETCH_SKIP, 0));
+            return;
+        }
+        int fetch_id = mRemoteData.playerSettingAttribIdFetch;
+        PlayerSettings plSetting = mRemoteData.mSupportedApplicationSettingsAttribute.get(fetch_id);
+        plSetting.supported_values = new byte [num_supported_val];
+        for (int count = 0; count < num_supported_val; ++count)
+            plSetting.supported_values[count] = supported_val[count];
+        mHandler.sendMessage(mHandler.obtainMessage(
+              MESSAGE_PROCESS_PLAYER_APPLICATION_SETTINGS_VALUES, ATTRIBUTE_FETCH_CONTINUE, 0));
+    }
+    private void handleCurrentPlayerApplicationSettingsResponse(byte[] address,
+                                     byte[] ids, byte[] values,byte num_attrib, byte rsp_type)
+    {
+        Log.d(TAG,"handleCurrentPlayerApplicationSettingsResponse num_attrib =" + num_attrib);
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,
+               MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT,
+                MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        if ((rsp_type != AVRC_RSP_IMPL_STBL)||(num_attrib <= 0))
+        {
+            mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_GET_SUPPORTED_EVENTS));
+            return;
+        }
+        for (int count = 0; count < num_attrib; count++)
+        {
+            byte attribute = ids[count]; // count increment to point to value of attrib_id.
+            for (PlayerSettings plSetting: mRemoteData.mSupportedApplicationSettingsAttribute)
+            {
+                if (plSetting.attr_Id == attribute) {
+                    plSetting.attr_val = values[count];
+                }
+            }
+        }
+        mHandler.sendEmptyMessage(MESSAGE_PROCESS_CURRENT_PLAYER_APPLICATION_SETTINGS);
+    }
+    /*
+     * response contains array from Event-ID ( first byte of the array ).
+     * rspLen is same as Parameter Length field of PDU.
+     * rspType - either Interim or Notify.
+     */
+    private void handleNotificationRsp(byte[] address, byte rspType, int rspLen, byte[] response)
+    {
+        Log.d(TAG,"handleNotificationRsp ");
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if ((!mConnectedDevices.contains(device))||(rspLen <= 0))
+            return;
+        int notificationEventId = response[0];
+        int notificaionRspType = rspType;
+        Log.d(TAG," rsp_type " + rspType +" notificationId " + notificationEventId);
+        if ((rspType != AVRC_RSP_INTERIM)&&(rspType != AVRC_RSP_CHANGED))
+        {
+            if (mHandler.hasMessages(2000 + notificationEventId))
+            {
+                mHandler.removeMessages(2000 + notificationEventId);
+                Log.d(TAG," Timeout CMD dequeued ");
+            }
+            handleNotificationTimeout(2000 + notificationEventId);
+            return;
+        }
+        ByteBuffer bb = ByteBuffer.wrap(response, 0, rspLen);
+        mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_PROCESS_NOTIFICATION_RESPONSE,
+              notificationEventId, notificaionRspType, bb));
+    }
+    /*
+     * attribRsp contains array after Number of Attributes
+     * First byte would be attribute ID ( 4 octets )of first attribute.
+     * attribRspLen - total length of attribRsp
+     */
+    private void handleGetElementAttributes(byte[] address, byte numAttributes, int attribRspLen,
+                                                  byte[] attribRsp, byte rsp_type)
+    {
+        Log.d(TAG,"handleGetElementAttributes ");
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if ((!mConnectedDevices.contains(device))||(attribRspLen <= 0))
+            return;
+
+        ByteBuffer bb = ByteBuffer.wrap(attribRsp, 0, attribRspLen);
+        int attributeId = bb.getInt(0);
+        Log.d(TAG," numAttrib " + numAttributes + " attribRspLen " + attribRspLen +
+                  " rsp_type " + rsp_type + " attribId " + attributeId);
+        if (rsp_type != AVRC_RSP_IMPL_STBL)
+        {
+            if (mHandler.hasMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + attributeId))
+            {
+                mHandler.removeMessages(GET_ELEMENT_ATTR_TIMEOUT_BASE + attributeId);
+                Log.d(TAG," Timeout CMD dequeued ");
+            }
+            mHandler.sendMessage(mHandler.obtainMessage(MESSAGE_PROCESS_ELEMENT_ATTRIBUTE,
+                                                                  0, ATTRIBUTE_FETCH_SKIP));
+            return;
+        }
+        Message msg = mHandler.obtainMessage(MESSAGE_PROCESS_ELEMENT_ATTRIBUTE, numAttributes,
+                                                                  ATTRIBUTE_FETCH_CONTINUE, bb);
+        mHandler.sendMessage(msg);
+    }
+    /*
+     * playStatusRsp will be after Parameter Length Feild
+     * first byte will be from Total Song Length
+     */
+    private void handleGetPlayStatus(byte[] address, int paramLen,
+                                    byte[] playStatusRsp, byte rsp_type)
+    {
+        Log.d(TAG,"handleGetPlayStatus ");
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT, MESSAGE_GET_PLAY_STATUS))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT, MESSAGE_GET_PLAY_STATUS);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        if ((rsp_type!= AVRC_RSP_IMPL_STBL)||(paramLen <= 0)) {
+            return;
+        }
+        ByteBuffer bb = ByteBuffer.wrap(playStatusRsp, 0, paramLen);
+        Message msg = mHandler.obtainMessage(MESSAGE_PROCESS_PLAY_STATUS, 0, 0, bb);
+        mHandler.sendMessage(msg);
+    }
+    private void handleSetAbsVolume(byte[] address, byte absVol)
+    {
+        Log.d(TAG,"handleSetAbsVolume ");
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        Message msg = mHandler.obtainMessage(MESSAGE_PROCESS_SET_ABS_VOL_CMD, absVol, 0);
+        mHandler.sendMessage(msg);
+    }
+    private void handleRegisterNotificationAbsVol(byte[] address)
+    {
+        Log.d(TAG,"handleRegisterNotificationAbsVol ");
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        mHandler.sendEmptyMessage(MESSAGE_PROCESS_REGISTER_ABS_VOL_REQUEST);
+    }
+    private void handleSetPlayerApplicationResponse(byte[] address, byte rsp_type)
+    {
+        Log.d(TAG,"handleSetPlayerApplicationResponse rsp_type = "+ rsp_type);
+        BluetoothDevice device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice
+                (Utils.getAddressStringFromByte(address));
+        if (!mConnectedDevices.contains(device))
+            return;
+        if (mHandler.hasMessages(MESSAGE_CMD_TIMEOUT,
+                    MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS))
+        {
+            mHandler.removeMessages(MESSAGE_CMD_TIMEOUT,
+                    MESSAGE_SET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+            Log.d(TAG," Timeout CMD dequeued ");
+        }
+        /*
+         * Send GetPlayerAppSetting if we do not support EVENT_PLAYER_APPLICATION_SETTINGS_CHANGED
+         * Some Devices don't reply with Changed. So we have to send this command, though its a
+         * overhead for other devices.
+         */
+         mHandler.sendEmptyMessage(MESSAGE_GET_CURRENT_PLAYER_APPLICATION_SETTINGS);
+    }
     private native static void classInitNative();
     private native void initNative();
     private native void cleanupNative();
     private native boolean sendPassThroughCommandNative(byte[] address, int keyCode, int keyState);
+    private native void getCapabilitiesNative(int capId);
+    private native void listPlayerApplicationSettingAttributeNative();
+    private native void listPlayerApplicationSettingValueNative(byte attribId);
+    private native void getPlayerApplicationSettingValuesNative(byte numAttrib, byte[] attribIds);
+    private native void setPlayerApplicationSettingValuesNative(byte numAttrib,
+                                                  byte[] atttibIds, byte[]attribVal);
+    private native void registerNotificationNative(byte eventId, int value);
+    private native void getElementAttributeNative(byte numAttributes, int attribId);
+    private native void getPlayStatusNative();
+    private native void sendAbsVolRspNative(int absVol);
+    private native void sendRegisterAbsVolRspNative(byte rspType, int absVol);
 }
diff --git a/src/com/android/bluetooth/avrcp/BluetoothAvrcpDataProvider.java b/src/com/android/bluetooth/avrcp/BluetoothAvrcpDataProvider.java
new file mode 100644
index 0000000..7bee7c1
--- /dev/null
+++ b/src/com/android/bluetooth/avrcp/BluetoothAvrcpDataProvider.java
@@ -0,0 +1,382 @@
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.android.bluetooth.avrcp;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.content.UriMatcher;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.util.Log;
+import android.bluetooth.BluetoothAvrcpController;
+import android.bluetooth.BluetoothAvrcpInfo;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+
+/**
+ * This content-provider implements AVRCP-MetaData database.
+ */
+
+public final class BluetoothAvrcpDataProvider extends ContentProvider {
+
+    private static final String TAG = "BluetoothAvrcpDataProvider";
+    private static final String DB_NAME = "btavrcp_ct.db";
+    private static final int DB_VERSION = 1;
+    private static final int DB_VERSION_NOP_UPGRADE_FROM = 0;
+    private static final int DB_VERSION_NOP_UPGRADE_TO = 1;
+    private static final String DB_TABLE = "btavrcp_ct";
+    private static final String TRACK_LIST_TYPE = "vnd.android.cursor.dir/vnd.android.btavrcp_ct";
+    private static final String TRACK_TYPE = "vnd.android.cursor.item/vnd.android.btavrcp_ct";
+    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);
+    /** For all TrackList */
+    private static final int TRACKS = 1;
+    /** For a single Track ID */
+    private static final int TRACK_ID = 2;
+
+    static {
+        sURIMatcher.addURI("com.android.bluetooth.avrcp", "btavrcp_ct", TRACKS);
+        sURIMatcher.addURI("com.android.bluetooth.avrcp", "btavrcp_ct/#", TRACK_ID);
+    }
+    private SQLiteOpenHelper mOpenHelper = null;
+
+    private final class DbHelper extends SQLiteOpenHelper {
+
+        public DbHelper(final Context context) {
+            super(context, DB_NAME, null, DB_VERSION);
+        }
+
+        @Override
+        public void onCreate(final SQLiteDatabase db) {
+             Log.v(TAG, "populating new database");
+            createTable(db);
+        }
+
+        @Override
+        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {
+            if (oldV == DB_VERSION_NOP_UPGRADE_FROM) {
+                if (newV == DB_VERSION_NOP_UPGRADE_TO) { // that's a no-op
+                    return;
+                }
+                oldV = DB_VERSION_NOP_UPGRADE_TO;
+            }
+            Log.i(TAG, "Upgrading downloads database from version " + oldV + " to "
+                    + newV + ", which will destroy all old data");
+            dropTable(db);
+            createTable(db);
+        }
+    }
+
+    private void createTable(SQLiteDatabase db) {
+        try {
+            db.execSQL("CREATE TABLE " + DB_TABLE + "("
+                    + BluetoothAvrcpInfo._ID + " INTEGER PRIMARY KEY AUTOINCREMENT,"
+                    + BluetoothAvrcpInfo.TRACK_NUM + " INTEGER, "
+                    + BluetoothAvrcpInfo.TITLE + " TEXT, "
+                    + BluetoothAvrcpInfo.ARTIST_NAME + " TEXT, "
+                    + BluetoothAvrcpInfo.ALBUM_NAME + " TEXT, "
+                    + BluetoothAvrcpInfo.TOTAL_TRACKS + " INTEGER, "
+                    + BluetoothAvrcpInfo.GENRE + " TEXT, "
+                    + BluetoothAvrcpInfo.PLAYING_TIME + " INTEGER, "
+                    + BluetoothAvrcpInfo.TOTAL_TRACK_TIME + " INTEGER, "
+                    + BluetoothAvrcpInfo.PLAY_STATUS + " TEXT, "
+                    + BluetoothAvrcpInfo.REPEAT_STATUS + " TEXT, "
+                    + BluetoothAvrcpInfo.SHUFFLE_STATUS + " TEXT, "
+                    + BluetoothAvrcpInfo.SCAN_STATUS + " TEXT, "
+                    + BluetoothAvrcpInfo.EQUALIZER_STATUS + " TEXT); ");
+        } catch (SQLException ex) {
+            Log.e(TAG, "couldn't create table in downloads database");
+            throw ex;
+        }
+    }
+
+    private void dropTable(SQLiteDatabase db) {
+        try {
+            db.execSQL("DROP TABLE IF EXISTS " + DB_TABLE);
+        } catch (SQLException ex) {
+            Log.e(TAG, "Couldn't Drop table");
+            throw ex;
+        }
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        int match = sURIMatcher.match(uri);
+        switch (match) {
+            case TRACKS: {
+                return TRACK_LIST_TYPE;
+            }
+            case TRACK_ID: {
+                return TRACK_TYPE;
+            }
+            default: {
+                Log.d(TAG, "getType called on unknown URI: " + uri);
+                throw new IllegalArgumentException("Unknown URI: " + uri);
+            }
+        }
+    }
+
+    private static final void copyString(String key, ContentValues from, ContentValues to) {
+        String s = from.getAsString(key);
+        if (s != null) {
+            to.put(key, s);
+        }
+    }
+
+    private static final void copyInteger(String key, ContentValues from, ContentValues to) {
+        Integer i = from.getAsInteger(key);
+        if (i != null) {
+            to.put(key, i);
+        }
+    }
+
+    private static final void copyLong(String key, ContentValues from, ContentValues to) {
+        Long i = from.getAsLong(key);
+        if (i != null) {
+            to.put(key, i);
+        }
+    }
+
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+        if (sURIMatcher.match(uri) != TRACKS) {
+            Log.d(TAG, "calling insert on an unknown/invalid URI: " + uri);
+            throw new IllegalArgumentException("Unknown/Invalid URI " + uri);
+        }
+
+        ContentValues filteredValues = new ContentValues();
+
+        copyLong(BluetoothAvrcpInfo.TRACK_NUM, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.TITLE, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.ARTIST_NAME, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.ALBUM_NAME, values, filteredValues);
+        copyLong(BluetoothAvrcpInfo.TOTAL_TRACKS, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.GENRE, values, filteredValues);
+        copyLong(BluetoothAvrcpInfo.PLAYING_TIME, values, filteredValues);
+        copyLong(BluetoothAvrcpInfo.TOTAL_TRACK_TIME, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.PLAY_STATUS, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.REPEAT_STATUS, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.SHUFFLE_STATUS, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.SCAN_STATUS, values, filteredValues);
+        copyString(BluetoothAvrcpInfo.EQUALIZER_STATUS, values, filteredValues);
+
+        long rowID = db.insert(DB_TABLE, null, filteredValues);
+
+        Uri ret = null;
+        Context context = getContext();
+
+        if (rowID != -1) {
+            ret = Uri.parse(BluetoothAvrcpInfo.CONTENT_URI + "/" + rowID);
+            context.getContentResolver().notifyChange(uri, null);
+        } else {
+            Log.d(TAG, "couldn't insert into database");
+            }
+
+        return ret;
+    }
+
+    @Override
+    public boolean onCreate() {
+        mOpenHelper = new DbHelper(getContext());
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
+            String sortOrder) {
+        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
+
+        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+
+        int match = sURIMatcher.match(uri);
+        switch (match) {
+            case TRACKS: {
+                qb.setTables(DB_TABLE);
+                break;
+            }
+            case TRACK_ID: {
+                qb.setTables(DB_TABLE);
+                qb.appendWhere(BluetoothAvrcpInfo._ID + "=");
+                qb.appendWhere(uri.getPathSegments().get(1));
+                break;
+            }
+            default: {
+                Log.d(TAG, "querying unknown URI: " + uri);
+                throw new IllegalArgumentException("Unknown URI: " + uri);
+            }
+        }
+
+        {
+            java.lang.StringBuilder sb = new java.lang.StringBuilder();
+            sb.append("starting query, database is ");
+            if (db != null) {
+                sb.append("not ");
+            }
+            sb.append("null; ");
+            if (projection == null) {
+                sb.append("projection is null; ");
+            } else if (projection.length == 0) {
+                sb.append("projection is empty; ");
+            } else {
+                for (int i = 0; i < projection.length; ++i) {
+                    sb.append("projection[");
+                    sb.append(i);
+                    sb.append("] is ");
+                    sb.append(projection[i]);
+                    sb.append("; ");
+                }
+            }
+            sb.append("selection is ");
+            sb.append(selection);
+            sb.append("; ");
+            if (selectionArgs == null) {
+                sb.append("selectionArgs is null; ");
+            } else if (selectionArgs.length == 0) {
+                sb.append("selectionArgs is empty; ");
+            } else {
+                for (int i = 0; i < selectionArgs.length; ++i) {
+                    sb.append("selectionArgs[");
+                    sb.append(i);
+                    sb.append("] is ");
+                    sb.append(selectionArgs[i]);
+                    sb.append("; ");
+                }
+            }
+            sb.append("sort is ");
+            sb.append(sortOrder);
+            sb.append(".");
+            Log.v(TAG, sb.toString());
+        }
+
+        Cursor ret = qb.query(db, projection, selection, selectionArgs, null, null, sortOrder);
+        Log.v(TAG," Query Done ");
+        if (ret != null) {
+            ret.setNotificationUri(getContext().getContentResolver(), uri);
+             Log.v(TAG, "created cursor " + ret + " on behalf of ");
+        } else {
+             Log.d(TAG, "query failed in downloads database");
+            }
+
+        return ret;
+    }
+
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+
+        int count;
+        long rowId = 0;
+
+        int match = sURIMatcher.match(uri);
+        switch (match) {
+            case TRACKS:
+            case TRACK_ID: {
+                String myWhere;
+                if (selection != null) {
+                    if (match == TRACKS) {
+                        myWhere = "( " + selection + " )";
+                    } else {
+                        myWhere = "( " + selection + " ) AND ";
+                    }
+                } else {
+                    myWhere = "";
+                }
+                if (match == TRACK_ID) {
+                    String segment = uri.getPathSegments().get(1);
+                    rowId = Long.parseLong(segment);
+                    myWhere += " ( " + BluetoothAvrcpInfo._ID + " = " + rowId + " ) ";
+                }
+
+                if (values.size() > 0) {
+                    count = db.update(DB_TABLE, values, myWhere, selectionArgs);
+                } else {
+                    count = 0;
+                }
+                break;
+            }
+            default: {
+                Log.d(TAG, "updating unknown/invalid URI: " + uri);
+                throw new UnsupportedOperationException("Cannot update URI: " + uri);
+            }
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+
+        return count;
+    }
+
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
+        int count;
+        int match = sURIMatcher.match(uri);
+        switch (match) {
+            case TRACKS:
+            case TRACK_ID: {
+                String myWhere;
+                if (selection != null) {
+                    if (match == TRACKS) {
+                        myWhere = "( " + selection + " )";
+                    } else {
+                        myWhere = "( " + selection + " ) AND ";
+                    }
+                } else {
+                    myWhere = "";
+                }
+                if (match == TRACK_ID) {
+                    String segment = uri.getPathSegments().get(1);
+                    long rowId = Long.parseLong(segment);
+                    myWhere += " ( " + BluetoothAvrcpInfo._ID + " = " + rowId + " ) ";
+                }
+
+                count = db.delete(DB_TABLE, myWhere, selectionArgs);
+                break;
+            }
+            default: {
+                Log.d(TAG, "deleting unknown/invalid URI: " + uri);
+                throw new UnsupportedOperationException("Cannot delete URI: " + uri);
+            }
+        }
+        getContext().getContentResolver().notifyChange(uri, null);
+        return count;
+    }
+}
\ No newline at end of file
diff --git a/src/com/android/bluetooth/btservice/AdapterProperties.java b/src/com/android/bluetooth/btservice/AdapterProperties.java
index 242e271..d0dcdb2 100644
--- a/src/com/android/bluetooth/btservice/AdapterProperties.java
+++ b/src/com/android/bluetooth/btservice/AdapterProperties.java
@@ -75,6 +75,33 @@ class AdapterProperties {
     // can be added here.
     private Object mObject = new Object();
 
+    private class DeviceState {
+        private BluetoothDevice device = null;
+        private int currentState = 0;
+        private int profileId = 0;
+
+        public DeviceState(BluetoothDevice device, int profile,
+                int state) {
+            this.device = device;
+            this.profileId = profile;
+            this.currentState = state;
+        }
+        @Override
+        public boolean equals(Object o) {
+            if (o instanceof DeviceState) {
+                if (this.device.equals(((DeviceState) o).device) &&
+                        this.profileId == ((DeviceState) o).profileId &&
+                        this.currentState == ((DeviceState) o).currentState) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    };
+
+    private ArrayList<DeviceState> mConnectedDeviceList =
+                new ArrayList<DeviceState>();
+
     public AdapterProperties(AdapterService service) {
         mService = service;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
@@ -350,6 +377,26 @@ class AdapterProperties {
     }
 
     void sendConnectionStateChange(BluetoothDevice device, int profile, int state, int prevState) {
+        // add device in connection list for first connected
+        // and remove it in disconnected
+        if (state == BluetoothProfile.STATE_CONNECTED) {
+            DeviceState newDevice = new DeviceState(device, profile, state);
+            if (!mConnectedDeviceList.contains(newDevice)) {
+                mConnectedDeviceList.add(newDevice);
+                Log.v(TAG,"device is added to list");
+            } else {
+                Log.v(TAG,"Fake broadcast for device, ignore");
+                return;
+            }
+        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
+            DeviceState deviceState = new DeviceState(device, profile,
+                    BluetoothProfile.STATE_CONNECTED);
+            if(mConnectedDeviceList.contains(deviceState)) {
+                Log.v(TAG,"device is removed from list");
+                mConnectedDeviceList.remove(deviceState);
+            }
+        }
+
         if (!validateProfileConnectionState(state) ||
                 !validateProfileConnectionState(prevState)) {
             // Previously, an invalid state was broadcast anyway,
@@ -408,15 +455,24 @@ class AdapterProperties {
     private boolean updateCountersAndCheckForConnectionStateChange(int state, int prevState) {
         switch (prevState) {
             case BluetoothProfile.STATE_CONNECTING:
-                mProfilesConnecting--;
+                if (mProfilesConnecting > 0)
+                    mProfilesConnecting--;
+                else
+                    Log.e(TAG, "mProfilesConnecting " + mProfilesConnecting);
                 break;
 
             case BluetoothProfile.STATE_CONNECTED:
-                mProfilesConnected--;
+                if (mProfilesConnected > 0)
+                    mProfilesConnected--;
+                else
+                    Log.e(TAG, "mProfilesConnected " + mProfilesConnected);
                 break;
 
             case BluetoothProfile.STATE_DISCONNECTING:
-                mProfilesDisconnecting--;
+                if (mProfilesDisconnecting > 0)
+                    mProfilesDisconnecting--;
+                else
+                    Log.e(TAG, "mProfilesDisconnecting " + mProfilesDisconnecting);
                 break;
         }
 
@@ -653,7 +709,7 @@ class AdapterProperties {
         infoLog("Callback:discoveryStateChangeCallback with state:" + state);
         synchronized (mObject) {
             Intent intent;
-            if (state == AbstractionLayer.BT_DISCOVERY_STOPPED) {
+            if ((state == AbstractionLayer.BT_DISCOVERY_STOPPED) && mDiscovering) {
                 mDiscovering = false;
                 intent = new Intent(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
                 mService.sendBroadcast(intent, mService.BLUETOOTH_PERM);
diff --git a/src/com/android/bluetooth/btservice/AdapterService.java b/src/com/android/bluetooth/btservice/AdapterService.java
index 78dd579..12ac4e8 100644
--- a/src/com/android/bluetooth/btservice/AdapterService.java
+++ b/src/com/android/bluetooth/btservice/AdapterService.java
@@ -51,14 +51,17 @@ import android.os.Process;
 import android.os.RemoteCallbackList;
 import android.os.RemoteException;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.provider.Settings;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.Pair;
 
 import com.android.bluetooth.a2dp.A2dpService;
+import com.android.bluetooth.a2dp.A2dpSinkService;
 import com.android.bluetooth.hid.HidService;
 import com.android.bluetooth.hfp.HeadsetService;
+import com.android.bluetooth.hfpclient.HeadsetClientService;
 import com.android.bluetooth.hdp.HealthService;
 import com.android.bluetooth.pan.PanService;
 import com.android.bluetooth.sdp.SdpManager;
@@ -71,6 +74,7 @@ import java.io.FileWriter;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Set;
 import java.util.Map;
 import java.util.Iterator;
@@ -87,8 +91,15 @@ public class AdapterService extends Service {
     private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;
     private static final int MIN_OFFLOADED_FILTERS = 10;
     private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;
+    private static final String delayConnectTimeoutDevice[] =
+            {"00:23:3D", // volkswagen carkit
+             "00:23:01", // Roman 9020 HS
+             "00:0C:8A", // Bose HS
+             "E0:75:0A", // Toyota Camry
+             "00:0C:36"};// Bose series 2 HS
     //For Debugging only
     private static int sRefCount=0;
+    private static int mScanmode;
 
     private int mStackReportedState;
     private int mTxTimeTotalMs;
@@ -111,6 +122,12 @@ public class AdapterService extends Service {
 
     public static final String BLUETOOTH_ADMIN_PERM =
         android.Manifest.permission.BLUETOOTH_ADMIN;
+
+    static final ParcelUuid[] A2DP_SOURCE_SINK_UUIDS = {
+        BluetoothUuid.AudioSource,
+        BluetoothUuid.AudioSink
+    };
+
     public static final String BLUETOOTH_PRIVILEGED =
                 android.Manifest.permission.BLUETOOTH_PRIVILEGED;
     static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
@@ -126,6 +143,7 @@ public class AdapterService extends Service {
     private static final int ADAPTER_SERVICE_TYPE=Service.START_STICKY;
 
     static {
+        System.load("/system/lib/libbluetooth_jni.so");
         classInitNative();
     }
 
@@ -195,6 +213,7 @@ public class AdapterService extends Service {
         if (TRACE_REF) {
             synchronized (AdapterService.class) {
                 sRefCount++;
+                mScanmode = BluetoothAdapter.SCAN_MODE_CONNECTABLE;
                 debugLog("AdapterService() - REFCOUNT: CREATED. INSTANCE_COUNT" + sRefCount);
             }
         }
@@ -227,6 +246,7 @@ public class AdapterService extends Service {
     private void processInitProfilePriorities (BluetoothDevice device, ParcelUuid[] uuids){
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
+        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
 
         // Set profile priorities only for the profiles discovered on the remote device.
@@ -240,12 +260,19 @@ public class AdapterService extends Service {
 
         // If we do not have a stored priority for A2DP then default to on.
         if ((a2dpService != null) &&
-            (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink) ||
+            ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink) ||
             BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AdvAudioDist)) &&
-            (a2dpService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
+            (a2dpService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED))){
             a2dpService.setPriority(device,BluetoothProfile.PRIORITY_ON);
         }
 
+        if ((a2dpSinkService != null) &&
+            ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource) ||
+                BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AdvAudioDist)) &&
+            (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED))){
+            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_ON);
+        }
+
         if ((headsetService != null) &&
             ((BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP) ||
                     BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree)) &&
@@ -255,12 +282,16 @@ public class AdapterService extends Service {
     }
 
     private void processProfileStateChanged(BluetoothDevice device, int profileId, int newState, int prevState) {
-        if (((profileId == BluetoothProfile.A2DP) ||(profileId == BluetoothProfile.HEADSET)) &&
-             (newState == BluetoothProfile.STATE_CONNECTED)){
-            debugLog( "Profile connected. Schedule missing profile connection if any");
+        if (((profileId == BluetoothProfile.A2DP) || (profileId == BluetoothProfile.HEADSET) ||
+            (profileId == BluetoothProfile.HEADSET_CLIENT) || (profileId == BluetoothProfile.A2DP_SINK)) &&
+            (newState == BluetoothProfile.STATE_CONNECTED)){
+            if (DBG) debugLog( "Profile connected. Schedule missing profile connection if any");
             connectOtherProfile(device, PROFILE_CONN_CONNECTED);
             setProfileAutoConnectionPriority(device, profileId);
         }
+        if ((profileId == BluetoothProfile.A2DP_SINK) && (newState == BluetoothProfile.STATE_CONNECTED)) {
+            setProfileAutoConnectionPriority(device, profileId);
+        }
         IBluetooth.Stub binder = mBinder;
         if (binder != null) {
             try {
@@ -304,7 +335,7 @@ public class AdapterService extends Service {
                 doUpdate=true;
             }
         }
-        debugLog("onProfileServiceStateChange() serviceName=" + serviceName
+        Log.w(TAG, "onProfileServiceStateChange() serviceName=" + serviceName
             + ", state=" + state +", doUpdate=" + doUpdate);
 
         if (!doUpdate) {
@@ -350,18 +381,20 @@ public class AdapterService extends Service {
                         continue;
                     }
                     if (BluetoothAdapter.STATE_OFF != entry.getValue()) {
-                        debugLog("onProfileServiceStateChange() - Profile still running: "
+                        Log.w(TAG,"onProfileServiceStateChange() - Profile still running: "
                             + entry.getKey());
                         return;
                     }
                 }
             }
-            debugLog("onProfileServiceStateChange() - All profile services stopped...");
+            Log.w(TAG,"onProfileServiceStateChange() - All profile services stopped...");
             //Send message to state machine
             mProfilesStarted=false;
             mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STOPPED));
 
         } else if (isTurningOn) {
+            updateInteropDatabase();
+
             //Process start pending
             //Check if all services are started if so, update state
             synchronized (mProfileServicesState) {
@@ -370,23 +403,77 @@ public class AdapterService extends Service {
                     Map.Entry<String,Integer> entry = i.next();
                     debugLog("Service: " + entry.getKey());
                     if (entry.getKey().equals("com.android.bluetooth.gatt.GattService")) {
-                        debugLog("Skip GATT service - already started before");
+                        Log.w(TAG, "Skip GATT service - already started before");
                         continue;
                     }
+
                     if (BluetoothAdapter.STATE_ON != entry.getValue()) {
-                        debugLog("onProfileServiceStateChange() - Profile still not running:"
-                            + entry.getKey());
+                        Log.w(TAG, "onProfileServiceStateChange() - Profile still not running:"
+                              + entry.getKey());
                         return;
                     }
                 }
             }
-            debugLog("onProfileServiceStateChange() - All profile services started.");
+            Log.w(TAG,"onProfileServiceStateChange() - All profile services started.");
             mProfilesStarted=true;
             //Send message to state machine
             mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
         }
     }
 
+    private void updateInteropDatabase() {
+        interopDatabaseClearNative();
+
+        String interop_string = Settings.Global.getString(getContentResolver(),
+                                            Settings.Global.BLUETOOTH_INTEROPERABILITY_LIST);
+        if (interop_string == null) return;
+        Log.d(TAG, "updateInteropDatabase: [" + interop_string + "]");
+
+        String[] entries = interop_string.split(";");
+        for (String entry : entries) {
+            String[] tokens = entry.split(",");
+            if (tokens.length != 2) continue;
+
+            // Get feature
+            int feature = 0;
+            try {
+                feature = Integer.parseInt(tokens[1]);
+            } catch (NumberFormatException e) {
+                Log.e(TAG, "updateInteropDatabase: Invalid feature '" + tokens[1] + "'");
+                continue;
+            }
+
+            // Get address bytes and length
+            int length = (tokens[0].length() + 1) / 3;
+            if (length < 1 || length > 6) {
+                Log.e(TAG, "updateInteropDatabase: Malformed address string '" + tokens[0] + "'");
+                continue;
+            }
+
+            byte[] addr = new byte[6];
+            int offset = 0;
+            for (int i = 0; i < tokens[0].length(); ) {
+                if (tokens[0].charAt(i) == ':') {
+                    i += 1;
+                } else {
+                    try {
+                        addr[offset++] = (byte) Integer.parseInt(tokens[0].substring(i, i + 2), 16);
+                    } catch (NumberFormatException e) {
+                        offset = 0;
+                        break;
+                    }
+                    i += 2;
+                }
+            }
+
+            // Check if address was parsed ok, otherwise, move on...
+            if (offset == 0) continue;
+
+            // Add entry
+            interopDatabaseAddNative(feature, addr, length);
+        }
+    }
+
     @Override
     public void onCreate() {
         super.onCreate();
@@ -406,6 +493,8 @@ public class AdapterService extends Service {
 
         mSdpManager = SdpManager.init(this);
         registerReceiver(mAlarmBroadcastReceiver, new IntentFilter(ACTION_ALARM_WAKEUP));
+        setAdapterService(this);
+
         mProfileObserver = new ProfileObserver(getApplicationContext(), this, new Handler());
         mProfileObserver.start();
     }
@@ -416,9 +505,12 @@ public class AdapterService extends Service {
         return mBinder;
     }
     public boolean onUnbind(Intent intent) {
-        debugLog("onUnbind() - calling cleanup");
-        cleanup();
-        return super.onUnbind(intent);
+        if (getState() == BluetoothAdapter.STATE_OFF) {
+            Log.w(TAG, "onUnbind, calling cleanup");
+            cleanup();
+            return super.onUnbind(intent);
+        }
+        return false;
     }
 
     public void onDestroy() {
@@ -443,13 +535,10 @@ public class AdapterService extends Service {
         mAdapterProperties.init(mRemoteDevices);
 
         debugLog("BleOnProcessStart() - Make Bond State Machine");
-        mBondStateMachine = BondStateMachine.make(this, mAdapterProperties, mRemoteDevices);
+        mBondStateMachine = BondStateMachine.make(mPowerManager, this, mAdapterProperties, mRemoteDevices);
 
         mJniCallbacks.init(mBondStateMachine,mRemoteDevices);
 
-        //FIXME: Set static instance here???
-        setAdapterService(this);
-
         //Start Gatt service
         setGattProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_ON);
     }
@@ -464,7 +553,7 @@ public class AdapterService extends Service {
             //Startup all profile services
             setProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_ON);
         }else {
-            debugLog("startCoreProfiles(): Profile Services alreay started");
+            Log.w(TAG,"startCoreProfiles(): Profile Services alreay started");
             mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BREDR_STARTED));
         }
     }
@@ -584,11 +673,15 @@ public class AdapterService extends Service {
         System.exit(0);
     }
 
-    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED =1;
-    private static final int MESSAGE_PROFILE_CONNECTION_STATE_CHANGED=20;
+    private static final int MESSAGE_PROFILE_SERVICE_STATE_CHANGED = 1;
+    private static final int MESSAGE_PROFILE_CONNECTION_STATE_CHANGED = 20;
     private static final int MESSAGE_CONNECT_OTHER_PROFILES = 30;
-    private static final int MESSAGE_PROFILE_INIT_PRIORITIES=40;
-    private static final int CONNECT_OTHER_PROFILES_TIMEOUT= 6000;
+    private static final int MESSAGE_PROFILE_INIT_PRIORITIES = 40;
+    private static final int CONNECT_OTHER_PROFILES_TIMEOUT = 6000;
+    private static final int CONNECT_OTHER_PROFILES_TIMEOUT_DELAYED = 10000;
+    private static final int CONNECT_OTHER_PROFILES_TIMEOUT_AUTO = 2000;
+    private static final int MESSAGE_AUTO_CONNECT_PROFILES = 50;
+    private static final int AUTO_CONNECT_PROFILES_TIMEOUT = 500;
 
     private final Handler mHandler = new Handler() {
         @Override
@@ -621,6 +714,11 @@ public class AdapterService extends Service {
                     processConnectOtherProfiles((BluetoothDevice) msg.obj,msg.arg1);
                 }
                     break;
+                case MESSAGE_AUTO_CONNECT_PROFILES: {
+                    if (DBG) debugLog( "MESSAGE_AUTO_CONNECT_PROFILES");
+                    autoConnectProfilesDelayed();
+                    break;
+                }
             }
         }
     };
@@ -657,7 +755,6 @@ public class AdapterService extends Service {
                 debugLog("setProfileServiceState() - "
                     + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting")
                     + " service " + serviceName);
-
                 mProfileServicesState.put(serviceName,pendingState);
                 Intent intent = new Intent(this,services[i]);
                 intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
@@ -682,6 +779,7 @@ public class AdapterService extends Service {
             expectedCurrentState= BluetoothAdapter.STATE_ON;
             pendingState = BluetoothAdapter.STATE_TURNING_OFF;
         }
+        Log.w(TAG, "Total profiles ="+ (services.length));
 
         for (int i=0; i <services.length;i++) {
             String serviceName = services[i].getName();
@@ -691,14 +789,14 @@ public class AdapterService extends Service {
 
             Integer serviceState = mProfileServicesState.get(serviceName);
             if(serviceState != null && serviceState != expectedCurrentState) {
-                debugLog("setProfileServiceState() - Unable to "
+                Log.w(TAG, "setProfileServiceState() - Unable to "
                     + (state == BluetoothAdapter.STATE_OFF ? "start" : "stop" )
                     + " service " + serviceName
                     + ". Invalid state: " + serviceState);
                 continue;
             }
 
-            debugLog("setProfileServiceState() - "
+            Log.w(TAG, "setProfileServiceState() - "
                 + (state == BluetoothAdapter.STATE_OFF ? "Stopping" : "Starting")
                 + " service " + serviceName);
 
@@ -706,6 +804,7 @@ public class AdapterService extends Service {
             Intent intent = new Intent(this,services[i]);
             intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
             intent.putExtra(BluetoothAdapter.EXTRA_STATE,state);
+            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
             startService(intent);
         }
     }
@@ -859,9 +958,22 @@ public class AdapterService extends Service {
                 return false;
             }
 
+            //do not allow setmode when multicast is active
+            A2dpService a2dpService = A2dpService.getA2dpService();
+            if (a2dpService != null &&
+                    a2dpService.isMulticastOngoing(null)) {
+                Log.i(TAG,"A2dp Multicast is Ongoing, ignore setmode " + mode);
+                mScanmode = mode;
+                return false;
+            }
+
             AdapterService service = getService();
             if (service == null) return false;
-            return service.setScanMode(mode,duration);
+            // when scan mode is not changed during multicast, reset it last to
+            // scan mode, as we will set mode to none for multicast
+            mScanmode = service.getScanMode();
+            Log.i(TAG,"setScanMode: prev mode: " + mScanmode + " new mode: " + mode);
+            return service.setScanMode(mode, duration);
         }
 
         public int getDiscoverableTimeout() {
@@ -1208,6 +1320,29 @@ public class AdapterService extends Service {
             return service.sdpSearch(device,uuid);
         }
 
+        public int setSocketOpt(int type, int channel, int optionName, byte [] optionVal,
+                                                    int optionLen) {
+            if (!Utils.checkCaller()) {
+                Log.w(TAG,"setSocketOpt(): not allowed for non-active user");
+                return -1;
+            }
+
+            AdapterService service = getService();
+            if (service == null) return -1;
+            return service.setSocketOpt(type, channel, optionName, optionVal, optionLen);
+        }
+
+        public int getSocketOpt(int type, int channel, int optionName, byte [] optionVal) {
+            if (!Utils.checkCaller()) {
+                Log.w(TAG,"getSocketOpt(): not allowed for non-active user");
+                return -1;
+            }
+
+            AdapterService service = getService();
+            if (service == null) return -1;
+            return service.getSocketOpt(type, channel, optionName, optionVal);
+        }
+
         public boolean configHciSnoopLog(boolean enable) {
             if (Binder.getCallingUid() != Process.SYSTEM_UID) {
                 EventLog.writeEvent(0x534e4554 /* SNET */, "Bluetooth", Binder.getCallingUid(),
@@ -1301,6 +1436,26 @@ public class AdapterService extends Service {
              if (service == null) return;
              service.onBrEdrDown();
          }
+
+         public int createMapMnsSdpRecord(String serviceName, int rfcommChannel,
+                 int l2capPsm, int version, int features) {
+             AdapterService service = getService();
+             if (service == null) return -1;
+             return service.createMapMnsSdpRecord(serviceName, rfcommChannel,
+                     l2capPsm, version, features);
+         }
+
+         public int createPbapPceSdpRecord(String serviceName, int version) {
+             AdapterService service = getService();
+             if (service == null) return -1;
+             return service.createPbapPceSdpRecord(serviceName, version);
+         }
+
+         public boolean removeSdpRecord(int recordHandle){
+             AdapterService service = getService();
+             if (service == null) return false;
+             return service.removeSdpRecord(recordHandle);
+         }
     };
 
     // ----API Methods--------
@@ -1386,7 +1541,6 @@ public class AdapterService extends Service {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
 
         setDiscoverableTimeout(duration);
-
         int newMode = convertScanModeToHal(mode);
         return mAdapterProperties.setScanMode(newMode);
     }
@@ -1406,6 +1560,13 @@ public class AdapterService extends Service {
      boolean startDiscovery() {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
+        //do not allow new connections with active multicast
+        A2dpService a2dpService = A2dpService.getA2dpService();
+        if (a2dpService != null &&
+                a2dpService.isMulticastOngoing(null)) {
+            Log.i(TAG,"A2dp Multicast is Ongoing, ignore discovery");
+            return false;
+        }
 
         return startDiscoveryNative();
     }
@@ -1456,6 +1617,13 @@ public class AdapterService extends Service {
         if (deviceProp != null && deviceProp.getBondState() != BluetoothDevice.BOND_NONE) {
             return false;
         }
+        // Multicast: Do not allow bonding while multcast
+        A2dpService a2dpService = A2dpService.getA2dpService();
+        if (a2dpService != null &&
+                a2dpService.isMulticastOngoing(null)) {
+            Log.i(TAG,"A2dp Multicast is ongoing, ignore bonding");
+            return false;
+        }
 
         // Pairing is unreliable while scanning, so cancel discovery
         // Note, remove this when native stack improves
@@ -1473,19 +1641,32 @@ public class AdapterService extends Service {
           return mQuietmode;
      }
 
-     public void autoConnect(){
+    // Delaying Auto Connect to make sure that all clients
+    // are up and running, specially BluetoothHeadset.
+    public void autoConnect() {
+        debugLog( "delay auto connect by 500 ms");
+        if ((mHandler.hasMessages(MESSAGE_AUTO_CONNECT_PROFILES) == false) &&
+            (isQuietModeEnabled()== false)) {
+            Message m = mHandler.obtainMessage(MESSAGE_AUTO_CONNECT_PROFILES);
+            mHandler.sendMessageDelayed(m,AUTO_CONNECT_PROFILES_TIMEOUT);
+        }
+    }
+
+    private void autoConnectProfilesDelayed(){
         if (getState() != BluetoothAdapter.STATE_ON){
-             errorLog("autoConnect() - BT is not ON. Exiting autoConnect");
-             return;
-         }
-         if (isQuietModeEnabled() == false) {
-             debugLog( "autoConnect() - Initiate auto connection on BT on...");
-             autoConnectHeadset();
-             autoConnectA2dp();
-         }
-         else {
-             debugLog( "autoConnect() - BT is in quiet mode. Not initiating auto connections");
-         }
+            errorLog("BT is not ON. Exiting autoConnect");
+            return;
+        }
+        if (isQuietModeEnabled() == false) {
+            debugLog("Initiate auto connection on BT on...");
+            autoConnectHeadset();
+            autoConnectA2dp();
+            autoConnectHandsfree();
+            autoConnectA2dpSink();
+        }
+        else {
+            debugLog("BT is in Quiet mode. No auto connections");
+        }
     }
 
      private void autoConnectHeadset(){
@@ -1516,30 +1697,129 @@ public class AdapterService extends Service {
             }
         }
     }
+     private void autoConnectA2dpSink(){
+         A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+         BluetoothDevice bondedDevices[] = getBondedDevices();
+         if ((bondedDevices == null) ||(a2dpSinkService == null)) {
+             return;
+         }
+         for (BluetoothDevice device : bondedDevices) {
+             if (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT ){
+                 debugLog("autoConnectA2dp() - Connecting A2DP Sink with " + device.toString());
+                 a2dpSinkService.connect(device);
+             }
+         }
+     }
+
+     private void autoConnectHandsfree() {
+        HeadsetClientService headsetClientService =
+                HeadsetClientService.getHeadsetClientService();
+        BluetoothDevice bondedDevices[] = getBondedDevices();
+        if ((bondedDevices == null) ||(headsetClientService == null)) {
+            return;
+        }
+        for (BluetoothDevice device : bondedDevices) {
+            if (headsetClientService.getPriority(device) ==
+                    BluetoothProfile.PRIORITY_AUTO_CONNECT ) {
+                Log.d(TAG,"Auto Connecting Headset Profile with device " + device.toString());
+                headsetClientService.connect(device);
+            }
+        }
+    }
+
+     private boolean isConnectTimeoutDelayApplicable(BluetoothDevice device){
+        String deviceAddress = device.getAddress();
+        boolean isConnectionTimeoutDelayed = false;
+        for (int i = 0; i < delayConnectTimeoutDevice.length;i++) {
+            if (deviceAddress.indexOf(delayConnectTimeoutDevice[i]) == 0) {
+                isConnectionTimeoutDelayed = true;
+            }
+        }
+        return isConnectionTimeoutDelayed;
+    }
 
      public void connectOtherProfile(BluetoothDevice device, int firstProfileStatus){
         if ((mHandler.hasMessages(MESSAGE_CONNECT_OTHER_PROFILES) == false) &&
             (isQuietModeEnabled()== false)){
+            ParcelUuid[] featureUuids = device.getUuids();
+            // Some Carkits disconnect just after pairing,Initiate SDP for missing UUID's support
+            if ((!(BluetoothUuid.containsAnyUuid(featureUuids, A2DP_SOURCE_SINK_UUIDS))) ||
+                    (!(BluetoothUuid.isUuidPresent(featureUuids, BluetoothUuid.Handsfree)))) {
+                Log.v(TAG,"Initiate SDP for Missing UUID's support in remote");
+                device.fetchUuidsWithSdp();
+            }
             Message m = mHandler.obtainMessage(MESSAGE_CONNECT_OTHER_PROFILES);
             m.obj = device;
             m.arg1 = (int)firstProfileStatus;
-            mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT);
+            // for auto PL's use lower value of connection time-out
+            boolean isA2dpSink = SystemProperties.getBoolean("persist.service.bt.a2dp.sink",
+                    false);
+            boolean isHfpClient = SystemProperties.getBoolean("persist.service.bt.hfp.client",
+                    false);
+            if (isA2dpSink || isHfpClient) {
+                mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT_AUTO);
+            }
+            else if (isConnectTimeoutDelayApplicable(device)) {
+                mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT_DELAYED);
+            }
+            else {
+                mHandler.sendMessageDelayed(m,CONNECT_OTHER_PROFILES_TIMEOUT);
+            }
         }
     }
 
      private void processConnectOtherProfiles (BluetoothDevice device, int firstProfileStatus){
+        // initiate connection for missing profile on device
+        Log.i(TAG,"device is " + device);
         if (getState()!= BluetoothAdapter.STATE_ON){
             return;
         }
-        HeadsetService  hsService = HeadsetService.getHeadsetService();
-        A2dpService a2dpService = A2dpService.getA2dpService();
+        boolean isA2dpSink = SystemProperties.getBoolean("persist.service.bt.a2dp.sink",
+                false);
+        boolean isHfpClient = SystemProperties.getBoolean("persist.service.bt.hfp.client",
+                false);
+
+        A2dpService a2dpService = null;
+        HeadsetService hsService = null;
+        A2dpSinkService a2dpSinkService = null;
+        HeadsetClientService hsClientService = null;
+
+        if (isA2dpSink) {
+            a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+        } else {
+            a2dpService = A2dpService.getA2dpService();
+        }
+        if (isHfpClient) {
+            hsClientService = HeadsetClientService.getHeadsetClientService();
+        } else {
+            hsService = HeadsetService.getHeadsetService();
+        }
 
         // if any of the profile service is  null, second profile connection not required
-        if ((hsService == null) ||(a2dpService == null )){
+        if (((hsService == null) || (a2dpService == null )) &&
+                (!isA2dpSink && !isHfpClient)){
+            return;
+        }
+        else if (((a2dpSinkService == null) || (hsClientService == null)) &&
+                (isA2dpSink && isHfpClient)){
             return;
         }
-        List<BluetoothDevice> a2dpConnDevList= a2dpService.getConnectedDevices();
-        List<BluetoothDevice> hfConnDevList= hsService.getConnectedDevices();
+        boolean a2dpConnected = false;
+        boolean hsConnected = false;
+        List<BluetoothDevice> a2dpConnDevList;
+        List<BluetoothDevice> hfConnDevList;
+
+        if (isA2dpSink) {
+            a2dpConnDevList = a2dpSinkService.getConnectedDevices();
+        } else {
+            a2dpConnDevList = a2dpService.getConnectedDevices();
+        }
+        if (isHfpClient) {
+            hfConnDevList = hsClientService.getConnectedDevices();
+        } else {
+            hfConnDevList = hsService.getConnectedDevices();
+        }
+
         // Check if the device is in disconnected state and if so return
         // We ned to connect other profile only if one of the profile is still in connected state
         // This is required to avoide a race condition in which profiles would
@@ -1549,18 +1829,88 @@ public class AdapterService extends Service {
             (PROFILE_CONN_CONNECTED  == firstProfileStatus)){
             return;
         }
-        if((hfConnDevList.isEmpty()) &&
-            (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
-            hsService.connect(device);
+        if(!a2dpConnDevList.isEmpty()) {
+            for (BluetoothDevice a2dpDevice : a2dpConnDevList)
+            {
+                if(a2dpDevice.equals(device))
+                {
+                    a2dpConnected = true;
+                }
+            }
+        }
+        if(!hfConnDevList.isEmpty()) {
+            for (BluetoothDevice hsDevice : hfConnDevList)
+            {
+                if(hsDevice.equals(device))
+                {
+                    hsConnected = true;
+                }
+            }
+        }
+       // This change makes sure that we try to re-connect
+       // the profile if its connection failed and priority
+       // for desired profile is ON.
+        Log.i(TAG, "HF connected for device : " + device + " " + hfConnDevList.contains(device));
+        Log.i(TAG, "A2DP connected for device : " + device + " " + a2dpConnDevList.contains(device));
+        // check for auto PL first
+        if((hfConnDevList.isEmpty()) && (hsClientService != null) &&
+                (hsClientService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)) {
+            hsClientService.connect(device);
+            return;
+        }
+        else if ((a2dpConnDevList.isEmpty()) && (a2dpSinkService != null) &&
+                (a2dpSinkService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)) {
+            a2dpSinkService.connect(device);
+            return;
+        }
+
+        // check for MTP now
+        if((hfConnDevList.isEmpty() || !(hfConnDevList.contains(device))) &&
+            (hsService != null) &&
+            (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_ON) &&
+            (a2dpConnected || (a2dpService.getPriority(device) == BluetoothProfile.PRIORITY_OFF))) {
+            int maxHfpConnectionSysProp =
+                    SystemProperties.getInt("persist.bt.max.hs.connections", 1);
+
+            if (!hfConnDevList.isEmpty() && maxHfpConnectionSysProp == 1) {
+                Log.v(TAG,"HFP is already connected, ignore");
+                return;
+            }
+
+            // proceed connection only if a2dp is connected to this device
+            // add here as if is already overloaded
+            if (a2dpConnDevList.contains(device) ||
+                (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)) {
+                hsService.connect(device);
+            } else {
+                Log.d(TAG, "do not initiate connect as A2dp is not connected");
+            }
         }
-        else if((a2dpConnDevList.isEmpty()) &&
-            (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
-            a2dpService.connect(device);
+        else if((a2dpConnDevList.isEmpty() || !(a2dpConnDevList.contains(device))) &&
+            (a2dpService != null) &&
+            (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_ON) &&
+            (hsConnected || (hsService.getPriority(device) == BluetoothProfile.PRIORITY_OFF))) {
+            int maxA2dpConnectionSysProp =
+                    SystemProperties.getInt("persist.bt.max.a2dp.connections", 1);
+
+            if (!a2dpConnDevList.isEmpty() && maxA2dpConnectionSysProp == 1) {
+                Log.v(TAG,"A2DP is already connected, ignore");
+                return;
+            }
+
+            // proceed connection only if HFP is connected to this device
+            // add here as if is already overloaded
+            if (hfConnDevList.contains(device) ||
+                (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)) {
+                a2dpService.connect(device);
+            } else {
+                Log.v(TAG, "do not initiate connect as HFP is not connected");
+            }
         }
     }
 
      private void adjustOtherHeadsetPriorities(HeadsetService  hsService,
-                                                    List<BluetoothDevice> connectedDeviceList) {
+            List<BluetoothDevice> connectedDeviceList) {
         for (BluetoothDevice device : getBondedDevices()) {
            if (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
                !connectedDeviceList.contains(device)) {
@@ -1569,22 +1919,43 @@ public class AdapterService extends Service {
         }
      }
 
+     private void adjustOtherHandsfreePriorities(HeadsetClientService headsetClientService,
+                                                    BluetoothDevice connectedDevice) {
+        for (BluetoothDevice device : getBondedDevices()) {
+           if (headsetClientService.getPriority(device) >=
+                BluetoothProfile.PRIORITY_AUTO_CONNECT &&
+                !device.equals(connectedDevice)) {
+               headsetClientService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+           }
+        }
+     }
+
      private void adjustOtherSinkPriorities(A2dpService a2dpService,
-                                                BluetoothDevice connectedDevice) {
+            List<BluetoothDevice> connectedDeviceList) {
          for (BluetoothDevice device : getBondedDevices()) {
              if (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
-                 !device.equals(connectedDevice)) {
+                 !connectedDeviceList.contains(device)) {
                  a2dpService.setPriority(device, BluetoothProfile.PRIORITY_ON);
              }
          }
      }
 
+     private void adjustOtherSrcPriorities(A2dpSinkService a2dpSinkService,
+                                               BluetoothDevice connectedDevice) {
+         for (BluetoothDevice device : getBondedDevices()) {
+             if (a2dpSinkService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
+                  !device.equals(connectedDevice)) {
+                a2dpSinkService.setPriority(device, BluetoothProfile.PRIORITY_ON);
+            }
+         }
+     }
+
      void setProfileAutoConnectionPriority (BluetoothDevice device, int profileId){
          if (profileId == BluetoothProfile.HEADSET) {
              HeadsetService  hsService = HeadsetService.getHeadsetService();
-             List<BluetoothDevice> deviceList = hsService.getConnectedDevices();
              if ((hsService != null) &&
                 (BluetoothProfile.PRIORITY_AUTO_CONNECT != hsService.getPriority(device))){
+                 List<BluetoothDevice> deviceList = hsService.getConnectedDevices();
                  adjustOtherHeadsetPriorities(hsService, deviceList);
                  hsService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
              }
@@ -1593,10 +1964,29 @@ public class AdapterService extends Service {
              A2dpService a2dpService = A2dpService.getA2dpService();
              if ((a2dpService != null) &&
                 (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpService.getPriority(device))){
-                 adjustOtherSinkPriorities(a2dpService, device);
+                 List<BluetoothDevice> deviceList = a2dpService.getConnectedDevices();
+                 adjustOtherSinkPriorities(a2dpService, deviceList);
                  a2dpService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
              }
          }
+         else if (profileId ==  BluetoothProfile.A2DP_SINK) {
+             A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
+             if ((a2dpSinkService != null) &&
+                (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpSinkService.getPriority(device))){
+                 adjustOtherSrcPriorities(a2dpSinkService, device);
+                 a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
+            }
+        }
+         else if (profileId ==  BluetoothProfile.HEADSET_CLIENT) {
+             HeadsetClientService headsetClientService =
+                    HeadsetClientService.getHeadsetClientService();
+             if ((headsetClientService != null) &&
+                (BluetoothProfile.PRIORITY_AUTO_CONNECT !=
+                        headsetClientService.getPriority(device))) {
+                 adjustOtherHandsfreePriorities(headsetClientService, device);
+                 headsetClientService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
+             }
+         }
     }
 
      boolean cancelBondProcess(BluetoothDevice device) {
@@ -1832,6 +2222,19 @@ public class AdapterService extends Service {
         return ParcelFileDescriptor.adoptFd(fd);
     }
 
+     int setSocketOpt(int type, int channel, int optionName, byte [] optionVal,
+             int optionLen) {
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        return setSocketOptNative(type, channel, optionName, optionVal, optionLen);
+     }
+
+     int getSocketOpt(int type, int channel, int optionName, byte [] optionVal) {
+        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+
+        return getSocketOptNative(type, channel, optionName, optionVal);
+     }
+
     boolean configHciSnoopLog(boolean enable) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return configHciSnoopLogNative(enable);
@@ -1926,6 +2329,23 @@ public class AdapterService extends Service {
         mAdapterStateMachine.sendMessage(m);
     }
 
+    public int createMapMnsSdpRecord(String serviceName, int rfcommChannel,
+            int l2capPsm, int version, int features) {
+        SdpManager manager = SdpManager.getDefaultManager();
+        return manager.createMapMnsRecord(serviceName, rfcommChannel,
+                l2capPsm, version, features);
+    }
+
+    public int createPbapPceSdpRecord(String serviceName, int version) {
+        SdpManager manager = SdpManager.getDefaultManager();
+        return manager.createPbapPceRecord(serviceName, version);
+    }
+
+    public boolean removeSdpRecord(int recordHandle){
+        SdpManager manager = SdpManager.getDefaultManager();
+        return manager.removeSdpRecord(recordHandle);
+    }
+
     private static int convertScanModeToHal(int mode) {
         switch (mode) {
             case BluetoothAdapter.SCAN_MODE_NONE:
@@ -2086,6 +2506,13 @@ public class AdapterService extends Service {
         dumpNative(fd);
     }
 
+    // do not use this API.It is called only from A2spstatemachine for
+    // restoring SCAN mode after multicast is stopped
+    public boolean restoreScanMode() {
+        Log.i(TAG, "restoreScanMode: " + mScanmode);
+        return setScanMode(mScanmode, getDiscoverableTimeout());
+    }
+
     private void debugLog(String msg) {
         if (DBG) Log.d(TAG, msg);
     }
@@ -2107,6 +2534,7 @@ public class AdapterService extends Service {
     private native static void classInitNative();
     private native boolean initNative();
     private native void cleanupNative();
+    /*package*/ native void ssrcleanupNative(boolean cleanup);
     /*package*/ native boolean enableNative(boolean startRestricted);
     /*package*/ native boolean disableNative();
     /*package*/ native boolean setAdapterPropertyNative(int type, byte[] val);
@@ -2141,12 +2569,21 @@ public class AdapterService extends Service {
     private native int createSocketChannelNative(int type, String serviceName,
                                                  byte[] uuid, int port, int flag);
 
+    private native int setSocketOptNative(int fd, int type, int optionName,
+                                byte [] optionVal, int optionLen);
+
+    private native int  getSocketOptNative(int fd, int type, int optionName,
+                                byte [] optionVal);
+
     /*package*/ native boolean configHciSnoopLogNative(boolean enable);
     /*package*/ native boolean factoryResetNative();
 
     private native void alarmFiredNative();
     private native void dumpNative(FileDescriptor fd);
 
+    private native void interopDatabaseClearNative();
+    private native void interopDatabaseAddNative(int feature, byte[] address, int length);
+
     protected void finalize() {
         cleanup();
         if (TRACE_REF) {
@@ -2156,4 +2593,5 @@ public class AdapterService extends Service {
             }
         }
     }
+
 }
diff --git a/src/com/android/bluetooth/btservice/AdapterState.java b/src/com/android/bluetooth/btservice/AdapterState.java
index b47d324..26c2821 100644
--- a/src/com/android/bluetooth/btservice/AdapterState.java
+++ b/src/com/android/bluetooth/btservice/AdapterState.java
@@ -443,8 +443,10 @@ final class AdapterState extends StateMachine {
 
                 case ENABLE_TIMEOUT:
                     errorLog("Error enabling Bluetooth (enable timeout)");
+                    adapterService.ssrcleanupNative(false);
                     mPendingCommandState.setBleTurningOn(false);
                     transitionTo(mOffState);
+                    adapterService.stopProfileServices();
                     notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                     break;
 
@@ -453,6 +455,8 @@ final class AdapterState extends StateMachine {
                     mPendingCommandState.setTurningOff(false);
                     transitionTo(mBleOnState);
                     notifyAdapterStateChange(BluetoothAdapter.STATE_BLE_ON);
+                    errorLog("BREDR_STOP_TIMEOUT:Killing the process to force a restart as part cleanup");
+                    android.os.Process.killProcess(android.os.Process.myPid());
                     break;
 
                 case BLE_STOP_TIMEOUT:
@@ -469,6 +473,7 @@ final class AdapterState extends StateMachine {
                     adapterService.stopProfileServices();
                     adapterService.stopGattProfileService();
                     mPendingCommandState.setTurningOff(false);
+                    adapterService.ssrcleanupNative(true);
                     setBleTurningOff(false);
                     transitionTo(mOffState);
                     notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
diff --git a/src/com/android/bluetooth/btservice/BondStateMachine.java b/src/com/android/bluetooth/btservice/BondStateMachine.java
index 7bed94a..1bc8223 100644
--- a/src/com/android/bluetooth/btservice/BondStateMachine.java
+++ b/src/com/android/bluetooth/btservice/BondStateMachine.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2014 The Linux Foundation. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +29,7 @@ import android.content.Intent;
 import android.os.Message;
 import android.os.UserHandle;
 import android.util.Log;
+import android.os.PowerManager;
 
 import com.android.bluetooth.Utils;
 import com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;
@@ -63,10 +65,17 @@ final class BondStateMachine extends StateMachine {
     private RemoteDevices mRemoteDevices;
     private BluetoothAdapter mAdapter;
 
+    /* The WakeLock is used for bringing up the LCD during a pairing request
+     * from remote device when Android is in Suspend state.*/
+    private PowerManager.WakeLock mWakeLock;
+
     private PendingCommandState mPendingCommandState = new PendingCommandState();
     private StableState mStableState = new StableState();
 
-    private BondStateMachine(AdapterService service,
+    private final ArrayList<BluetoothDevice> mDevices =
+        new ArrayList<BluetoothDevice>();
+
+    private BondStateMachine(PowerManager pm, AdapterService service,
             AdapterProperties prop, RemoteDevices remoteDevices) {
         super("BondStateMachine:");
         addState(mStableState);
@@ -76,12 +85,17 @@ final class BondStateMachine extends StateMachine {
         mAdapterProperties = prop;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
         setInitialState(mStableState);
+
+        //WakeLock instantiation in RemoteDevices class
+        mWakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP
+                       | PowerManager.ON_AFTER_RELEASE, TAG);
+        mWakeLock.setReferenceCounted(false);
     }
 
-    public static BondStateMachine make(AdapterService service,
+    public static BondStateMachine make(PowerManager pm, AdapterService service,
             AdapterProperties prop, RemoteDevices remoteDevices) {
         Log.d(TAG, "make");
-        BondStateMachine bsm = new BondStateMachine(service, prop, remoteDevices);
+        BondStateMachine bsm = new BondStateMachine(pm, service, prop, remoteDevices);
         bsm.start();
         return bsm;
     }
@@ -120,6 +134,9 @@ final class BondStateMachine extends StateMachine {
                 /* if incoming pairing, transition to pending state */
                 if (newState == BluetoothDevice.BOND_BONDING)
                 {
+                    if(!mDevices.contains(dev)) {
+                        mDevices.add(dev);
+                    }
                     sendIntent(dev, newState, 0);
                     transitionTo(mPendingCommandState);
                 }
@@ -145,8 +162,6 @@ final class BondStateMachine extends StateMachine {
 
 
     private class PendingCommandState extends State {
-        private final ArrayList<BluetoothDevice> mDevices =
-            new ArrayList<BluetoothDevice>();
 
         @Override
         public void enter() {
@@ -185,6 +200,14 @@ final class BondStateMachine extends StateMachine {
                     sendIntent(dev, newState, reason);
                     if(newState != BluetoothDevice.BOND_BONDING )
                     {
+                        // check if bond none is received from device which
+                        // was in pairing state otherwise don't transition to
+                        // stable state.
+                        if (newState == BluetoothDevice.BOND_NONE &&
+                            !mDevices.contains(dev) && mDevices.size() != 0) {
+                            infoLog("not transitioning to stable state");
+                            break;
+                        }
                         /* this is either none/bonded, remove and transition */
                         result = !mDevices.remove(dev);
                         if (mDevices.isEmpty()) {
@@ -221,11 +244,21 @@ final class BondStateMachine extends StateMachine {
                 case SSP_REQUEST:
                     int passkey = msg.arg1;
                     int variant = msg.arg2;
+                    if(devProp == null)
+                    {
+                        Log.e(TAG,"Received msg from an unknown device");
+                        return false;
+                    }
                     sendDisplayPinIntent(devProp.getAddress(), passkey, variant);
                     break;
                 case PIN_REQUEST:
                     BluetoothClass btClass = dev.getBluetoothClass();
                     int btDeviceClass = btClass.getDeviceClass();
+                    if(devProp == null)
+                    {
+                        Log.e(TAG,"Received msg from an unknown device");
+                        return false;
+                    }
                     if (btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD ||
                          btDeviceClass == BluetoothClass.Device.PERIPHERAL_KEYBOARD_POINTING) {
                         // Its a keyboard. Follow the HID spec recommendation of creating the
@@ -263,6 +296,7 @@ final class BondStateMachine extends StateMachine {
     }
 
     private boolean cancelBond(BluetoothDevice dev) {
+        if(mAdapterService == null) return false;
         if (dev.getBondState() == BluetoothDevice.BOND_BONDING) {
             byte[] addr = Utils.getBytesFromAddress(dev.getAddress());
             if (!mAdapterService.cancelBondNative(addr)) {
@@ -275,6 +309,7 @@ final class BondStateMachine extends StateMachine {
     }
 
     private boolean removeBond(BluetoothDevice dev, boolean transition) {
+        if(mAdapterService == null) return false;
         if (dev.getBondState() == BluetoothDevice.BOND_BONDED) {
             byte[] addr = Utils.getBytesFromAddress(dev.getAddress());
             if (!mAdapterService.removeBondNative(addr)) {
@@ -289,6 +324,7 @@ final class BondStateMachine extends StateMachine {
     }
 
     private boolean createBond(BluetoothDevice dev, int transport, boolean transition) {
+        if(mAdapterService == null) return false;
         if (dev.getBondState() == BluetoothDevice.BOND_NONE) {
             infoLog("Bond address is:" + dev);
             byte[] addr = Utils.getBytesFromAddress(dev.getAddress());
@@ -305,6 +341,9 @@ final class BondStateMachine extends StateMachine {
     }
 
     private void sendDisplayPinIntent(byte[] address, int pin, int variant) {
+
+        // Acquire wakelock during PIN code request to bring up LCD display
+        mWakeLock.acquire();
         Intent intent = new Intent(BluetoothDevice.ACTION_PAIRING_REQUEST);
         intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mRemoteDevices.getDevice(address));
         if (pin != 0) {
@@ -313,6 +352,8 @@ final class BondStateMachine extends StateMachine {
         intent.putExtra(BluetoothDevice.EXTRA_PAIRING_VARIANT, variant);
         intent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
         mAdapterService.sendOrderedBroadcast(intent, mAdapterService.BLUETOOTH_ADMIN_PERM);
+        // Release wakelock to allow the LCD to go off after the PIN popup notification.
+        mWakeLock.release();
     }
 
     private void sendIntent(BluetoothDevice device, int newState, int reason) {
diff --git a/src/com/android/bluetooth/btservice/ProfileService.java b/src/com/android/bluetooth/btservice/ProfileService.java
index 7a6908f..b470aaf 100644
--- a/src/com/android/bluetooth/btservice/ProfileService.java
+++ b/src/com/android/bluetooth/btservice/ProfileService.java
@@ -109,16 +109,12 @@ public abstract class ProfileService extends Service {
         super.onCreate();
         mAdapter = BluetoothAdapter.getDefaultAdapter();
         mBinder = initBinder();
-        mAdapterService = AdapterService.getAdapterService();
-        if (mAdapterService != null) {
-            mAdapterService.addProfile(this);
-        } else {
-            Log.w(TAG, "onCreate, null mAdapterService");
-        }
     }
 
     public int onStartCommand(Intent intent, int flags, int startId) {
         if (DBG) log("onStartCommand()");
+        if(mAdapterService == null)
+            mAdapterService = AdapterService.getAdapterService();
         if (mStartError || mAdapter == null) {
             Log.w(mName, "Stopping profile service: device does not have BT");
             doStop(intent);
@@ -142,6 +138,13 @@ public abstract class ProfileService extends Service {
                     doStop(intent);
                 } else if (state == BluetoothAdapter.STATE_ON) {
                     Log.d(mName, "Received start request. Starting profile...");
+                    mAdapterService = AdapterService.getAdapterService();
+                    if (mAdapterService != null) {
+                        mAdapterService.addProfile(this);
+                    } else {
+                        Log.w(TAG, "onStart, null mAdapterService, this should never happen ");
+                    }
+
                     doStart(intent);
                 }
             }
@@ -199,6 +202,7 @@ public abstract class ProfileService extends Service {
             if (DBG) log("start()");
             mStartError = !start();
             if (!mStartError) {
+                Log.d(mName, " profile started successfully");
                 notifyProfileServiceStateChanged(BluetoothAdapter.STATE_ON);
             } else {
                 Log.e(mName, "Error starting profile. BluetoothAdapter is null");
@@ -209,8 +213,9 @@ public abstract class ProfileService extends Service {
     private void doStop(Intent intent) {
         if (stop()) {
             if (DBG) log("stop()");
-            notifyProfileServiceStateChanged(BluetoothAdapter.STATE_OFF);
             stopSelf();
+            Log.d(mName, " profile stopped successfully");
+            notifyProfileServiceStateChanged(BluetoothAdapter.STATE_OFF);
         } else {
             Log.e(mName, "Unable to stop profile");
         }
diff --git a/src/com/android/bluetooth/sdp/SdpManager.java b/src/com/android/bluetooth/sdp/SdpManager.java
index 679bc95..944048a 100644
--- a/src/com/android/bluetooth/sdp/SdpManager.java
+++ b/src/com/android/bluetooth/sdp/SdpManager.java
@@ -27,6 +27,7 @@ import android.os.Message;
 import android.os.ParcelUuid;
 import android.os.Parcelable;
 import android.util.Log;
+import com.android.bluetooth.OolConnManager;
 
 import com.android.bluetooth.Utils;
 import com.android.bluetooth.btservice.AbstractionLayer;
@@ -77,7 +78,7 @@ public class SdpManager {
     static Object mTrackerLock = new Object();
 
     /* The timeout to wait for reply from native. Should never fire. */
-    private static final int SDP_INTENT_DELAY = 6000;
+    private static final int SDP_INTENT_DELAY = 11000;
     private static final int MESSAGE_SDP_INTENT = 2;
 
     // We need a reference to the adapter service, to be able to send intents
@@ -102,6 +103,9 @@ public class SdpManager {
     private native int sdpCreateMapMnsRecordNative(String serviceName,
             int rfcommChannel, int l2capPsm, int version, int features);
 
+    private native int sdpCreatePbapPceRecordNative(String serviceName,
+            int version);
+
     private native int sdpCreatePbapPseRecordNative(String serviceName, int rfcommChannel,
             int l2capPsm, int version, int repositories, int features);
 
@@ -365,6 +369,7 @@ public class SdpManager {
             if(D) Log.d(TAG, "UUID: " + Arrays.toString(uuid));
             if(D) Log.d(TAG, "UUID in parcel: " + ((Utils.byteArrayToUuid(uuid))[0]).toString());
             sendSdpIntent(inst, sdpRecord, moreResults);
+            OolConnManager.saveOppSdpRecord (sdpRecord,inst.getDevice());
         }
     }
 
@@ -561,6 +566,31 @@ public class SdpManager {
     }
 
     /**
+     * Create a client side Phonebook Access Profile Service Record.
+     * Create the record once, and reuse it for all connections.
+     * If changes to a record is needed remove the old record using {@link removeSdpRecord}
+     * and then create a new one.
+     * @param serviceName   The textual name of the service
+     * @param rfcommChannel The RFCOMM channel that clients can connect to
+     *                      (obtain from BluetoothServerSocket)
+     * @param l2capPsm      The L2CAP PSM channel that clients can connect to
+     *                      (obtain from BluetoothServerSocket)
+     *                      Supply -1 to omit the L2CAP PSM from the record.
+     * @param version       The Profile version number (As specified in the Bluetooth
+     *                      PBAP specification)
+     * @return a handle to the record created. The record can be removed again
+     *          using {@link removeSdpRecord}(). The record is not linked to the
+     *          creation/destruction of BluetoothSockets, hence SDP record cleanup
+     *          is a separate process.
+     */
+    public int createPbapPceRecord(String serviceName, int version) {
+        if(sNativeAvailable == false) {
+            throw new RuntimeException(TAG + " sNativeAvailable == false - native not initialized");
+        }
+        return sdpCreatePbapPceRecordNative(serviceName, version);
+    }
+
+    /**
      * Create a Server side Phone Book Access Profile Service Record.
      * Create the record once, and reuse it for all connections.
      * If changes to a record is needed remove the old record using {@link removeSdpRecord}
-- 
1.9.1

